---
layout: post
title:  "프로그램의 기계수준 표현(Machine-Level Representation of Programs)"
date:   2025-04-04
categories: computer_system
tags: [기계수준, 프로그램, Machine, Level, Representation, Program]
hide_last_modified: true
---

* toc  
{:toc .large-only}

컴퓨터는 데이터를 처리하고, 메모리를 관리하고, 저장장치에 데이터를 읽거나 쓰고, 네트워크를 통해 통신하는 등의 하위 동작들을 인코딩한 연속된 바이트인 기계어 코드를 실행한다. 

## 프래그로머로써 왜 어셈블리어를 배워야 할까? 

최신 최적화 컴파일러가 만들어 낸 코드는 대부분 잘 훈련된 어셈블리어 프래그로머가 손으로 작성한 것과 유사한 효율성을 갖는다. 그 말은 잘 훈련된 프로그래머의 어셈블리어가 최신 최적화 컴파일러가 만들어 낸 코드만큼의 효율성을 갖는다는 얘기다. 어셈블리어 코드를 읽고 이해할 수 있으면, 컴파일러의 최적화 성능을 알 수 있으며, 코드에 내재된 비효율성을 분석할 수 있다

## 기계수준 코드

기계수준 프로그래밍에 중요한 특징 두가지가 있어

- 1. 기계수준 프로그램의 형식과 동작은 인스트럭션 집합구조(Instruction set architecture) 즉, "ISA"에 의해 정의된다

- 2. 기계수준 프로그램이 사용하는 주소는 가상주소이며, 메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델 제공

그리고 프로세서 내부 구조에 대해서 설명할게

- ***프로그램 카운터***(일반적으로 PC라고 하며, x86-64에서는 %rip라고 함)는 실행할 다음 인스트럭션의 메모리 주소를 가리킴

- ***정수 레지스터*** 파일은 64비트 값을 저장하기 위한 16개의 이름을 붙인 위치를 갖는다. 이들 레지스터는 주소(C언어의 포인터에 해당하는)나 정수 데이터를 저장할 수 있다. 일부 레지스터는 프로그램의 중요한 상태를 추적하는데 사용할 수 있으며, 다른 레지스터들은 함수의 리턴 값뿐만 아니라 프로시저의 지역변수와 인자 같은 임시 값을 저장하는 데 사용한다

- ***조건코드 레지스터***들은 가장 최근에 실행한 산술 또는 논리 인스트럭션에 관한 상태 정보를 저장한다. 이들은 if나 while문을 구현할 때 필요한 제어나 조건에 따른 데이터 흐름의 변경을 구현하기 위해 사용된다

- ***벡터 레지스터***들의 집합은 하나 이상의 정수나 부동소수점 값들을 각각 저장할 수 있다

### 프로그램 메모리

프로그램 메모리는 프로그램의 실행 기계어 코드, 운영체제를 위한 일부 정보, 프로시저 호출과 리턴을 관리하는 런타임 스택, 사용자에 의해 할당된(예를 들어 malloc 라이브러리 함수를 사용해서) 메모리 블록들을 포함하고 있다

## 코드 예제

----

## 정보 접근하기

인스트럭션들은 16개의 레지스터 하위 바이트들에 저장된 다양한 크기의 데이터에 대해 연산할 수 있다. 바이트수준 연산들은 가장 덜 중요한 바이트에 대해 연산을 할 수 있으며, 16비트 연산들은 가장 덜 중요한 2바이트에 접근하고, 32비트 연산은 덜 중요한 4바이트에, 64비트 연산은 레지스터 전체에 접근할 수 있다.

### 오퍼랜드 식별자(Operand specifier)

대부분의 인스트럭션은 하나 이상의 오퍼랜드를 가진다. 오퍼랜드는 연산을 수행할 소스(source)값과 그 결과를 저장할 목적지(destination)의 위치를 명시한다.

## 데이터 이동 예제

| 명령어 접미사 | 크기 | 예시 레지스터 |
|:---:|:---:|:---:|
| b (byte) | 8 비트 | %al, %bl |
| w (word) | 16 비트 | %ax, %bx |
| l (long) | 32 비트 | %eax, %ebx |
| q (quad) | 64 비트 | %rax, %rbx |

### 자료형 변환 (Type Casting)

#### 작은 타입 → 큰 타입 (확장)

예 : char(8bit) → int(32bit)

같은 경우 두 가지 방식으로 확장 가능 : 

- Zero extension (0으로 채움) : 부호 없는 확장

- Sign extenstion (부호비트 복사) : 부호 있는 확장

~~~assembly
; 예: 8비트 AL 레지스터 → 32비트 EAX로 확장

movzx eax, al     ; zero-extension: AL을 EAX로 확장
movsx eax, al     ; sign-extension: AL을 EAX로 확장 (AL이 음수면 1로 채움)
~~~

#### 큰 타입 → 작은 타입 (축소)

예 : int(32bit) → char(8bit)

이건 단순히 상위 비트를 버림. 잘못하면 값이 잘릴 수 있음

~~~assembly
mov al, bl       ; 단순 복사 → 상위 비트 무시
~~~

### 정수형 확장

자료형 변환과 확장되는데 다사 정리하자면 :

| 종류 | 설명 | 어셈블리어 명령어 |
|:---:|:---:|:---:|
| Zero Extension | 상위 비트를 0으로 채움 | MOVZX |
| Sign Extension | 상위 비트를 부호 비트로 채움 | MOVSX |

- C언어에서 unsigned char → int 변환하면 zero-extension

- signed char → int은 sign-extension 됨

### 부호성과 크기의 변환

부호성(sign)은 같은 비트 패턴이라도 해석 방법이 다름

| 이진수 | 부호 있음(signed) | 부호 없음(unsigned) |
|:---:|:---:|:---:|
| 11111111 (8bit) | -1 | 255 |
| 10000000 | -128 | 128 |

예시 : 이런 식으로, 같은 al = 0xFF 값을 어떻게 해석하냐에 따라 완전히 다른 결과가 나와.
~~~assembly
mov al, -1         ; al = 0xFF (-1)
movzx eax, al      ; eax = 0x000000FF (255) ← zero-extension
movsx eax, al      ; eax = 0xFFFFFFFF (-1) ← sign-extension
~~~

#### 그러면 부호성은 언제 사용하냐?

- 함수 호출 시 작은 자료형을 큰 레지스터에 넣을 때

- 시스템 콜에 인자 전달할 때 정수형 확장 필수

- 부호 있는 비교 (cmp) vs 부호 없는 비교 (cmp + ja/jb 등)에서 차이 발생

- imul, mul 등 부호 여부에 따라 다른 명령어 사용

### 자료형, 정수형 확장, 부호성과 크기의 변환 요약

| 개념 | 설명 |
|:---:|:---:|
| 자료형 없음 | 어셈블리는 타입보다 "크기"와 "부호 여부"에 집중 |
| Zero-extension | unsigned 확장. 상위 비트를 0으로 채움 |
| Sign-extension | signed 확장. 부호 비트를 상위에 복사 |
| 축소(Casting down) | 상위 비트 잘림 (주의 필요) |
| 부호 해석 | 같은 비트라도 signed/unsigned로 다르게 해석됨 |
| 주요 명령어 | mov, movzx, movsx, cmp, imul, mul |

### C언어에서의 signed vs unsigned 기본 개념

| 타입 | 표현 가능한 값 |
|:---:|:---:|
| signed(기본) | 음수 ~ 양수 |
| unsigned | 0 ~ 양수 (두 배 범위) |

예 : char는 1바이트니까 총 256개의 값을 표현할 수 있음

- signed char : -128 ~ 127

- unsigned char : 0 ~ 255

#### 왜 굳이 unsigned를 쓸까?

**음수가 절대 나올 수 없는 값에 적절함**

예 : 나이, 인덱스, 배열 크기, 파일 크기, 시간 등

→ 당연히 음수가 될 수 없으니 unsigned를 쓰면 안전하고 의미도 더 분명함

~~~c
unsigned int age = 23;
~~~

**저장 범위를 최대한 활용하고 싶을 때**

unsigned는 같은 크기에서 더 큰 수까지 표현 가능하니까, 한정된 메모리로 최대한 많은 값을 표현하고 싶을 때 유용해.

예 : 색상값 (0~255)
~~~c
unsigned char red = 255;  // 딱 1바이트로 0~255 표현
~~~

** 비트 연산을 명확하게 할 때

unsigned는 부호 비트(맨 앞 비트) 를 걱정하지 않아도 돼서 비트 마스크, 쉬프트 연산 등을 더 안정적으로 할 수 있어
~~~c
unsigned char mask = 0xF0;
value = value & mask;
~~~

#### 그럼 signed는 왜 따로 쓸까?

사실 C에서는 int, char는 기본적으로 signed야.(char는 컴파일러마다 다름) 명시적으로 부호 있는 정수라는 걸 강조하거나, 플랫폼 독립적으로 정확한 표현 범위를 보장하고 싶을 때 signed를 명시해
~~~c
signed char temperature = -20;
~~~

#### C에서 char, signed char, unsigned char의 차이

| 타입 | 범위 | 용도 |
|:---:|:---:|:---:|
| char | 컴파일러에 따라 signed/unsigned 다름 | 문자 표현용 |
| signed char | -128 ~ 127 | 음수 포함할 때 |
| unsigned char | 0 ~ 255 | 바이트 데이터 처리, 파일 읽기 등 |

예를 들어 이미지 파일을 바이트 단위로 읽을 때는 unsigned char가 더 적절해. 0xFF(255)가 음수로 해석되면 문제가 생기거든

#### 정수 오버플로/언더플로와 관련 

**unsigned**는 overflow/underflow 시 모듈로 연산처럼 동작

**signed**는 overflow시 동작이 정의되지 않음(UB, undefined behavior)

~~~c
unsigned int x = 0;
x--;  // x = 4294967295 (underflow)

int y = 2147483647;
y++;  // UB (비정상 동작 가능성)
~~~

#### unsigned/signed 정리

| 쓰는 이유 | 설명 |
|:---:|:---:|
| 의미 명확히 하기 | 나이는 음수가 될 수 없으니 unsigned 사용 |
| 범위 확장 | 같은 바이트로 더 큰 수 저장 |
| 비트 연산 안전성 | 부호 없는 연산이 더 예측 가능함 |
| 성능/메모리 최적화 | char 1바이트 단위로 다루고 싶을 때 등 |

## %rsp(스택 포인터)의 감소

- %rsp는 데이터를 push하거나 스택 프레임을 만들 때 감소하는데, 이때의 감소량은 저장되는 데이터의 크기를 기준으로 해

~~~assembly
push %rbp   ; 8바이트 감소 (64비트 시스템에서 레지스터는 8바이트)
sub $16, %rsp  ; 스택에 16바이트 공간 확보 -> %rsp는 16바이트 감소
~~~

예제 : 함수 진입 시 흔한 패턴:
~~~assembly
push %rbp         ; 이전 프레임 포인터 저장 -> %rsp -= 8
mov %rsp, %rbp    ; 현재 스택 포인터를 프레임 포인터로 복사
sub $32, %rsp     ; 로컬 변수 32바이트 공간 확보 -> %rsp -= 32
~~~

예제 : 반대로 함수가 끝날 때:
~~~assembly
leave             ; mov %rbp, %rsp + pop %rbp와 동일 (프레임 복구)
ret               ; 스택에서 리턴 주소 pop -> %rsp += 8
~~~

