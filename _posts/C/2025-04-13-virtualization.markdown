---
layout: post
title:  "가상화(Virtualization)"
date:   2025-04-13
tags: [C, 가상화, Virtualization]
hide_last_modified: true
---

* toc  
{:toc .large-only}

하드웨어 자원을 소프트웨어적으로 추상화해서, 여러 개의 독립된 시스템처럼 사용하는 기술 **가상화(Virtualization)**에 대해 알아볼게

가상화를 통해 하나의 물리 컴퓨터 위에서

- 여러 운영처제(OS)

- 여러 어플리케이션 환경

을 독립적이고 격리된 상태로 실행할 수 있도록 해줘

## 가상화의 종류

| 항목 | VM(Virtual Machine) | Docker(Container) |
|:---:|:---:|:---:|
| OS 포함 | 각 VM마다 Guest OS 포함 | 커널 공유, OS는 없음 |
| 부팅 속도 | 느림(분 단위) | 매우 빠름(초 단위) |
| 성능 | 비교적 낮음 | 거의 네이티브 수준 |
| 자원 사용 | 무거움(OS 단위로 메모리 사용) | 가벼움(커널 공유하기 때문) |
| 격리성 | 강력함 | 비교적 약함(같은 커널 공유) |
| 이미지 크기 | 수 GB | 수 MB ~ GB |
| 사용 사례 | 전체 OS 시뮬레이션, 강한 격리 필요시 | 마이크로서비스, CI/CD, 빠른 배포 |

### 전통적인 VM

~~~css
[ 물리 하드웨어 ]
       ↓
[ 호스트 OS ]
       ↓
[ 하이퍼바이저 (Hypervisor) ]
       ↓↓↓↓↓
 ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
 │   VM 1       │  │   VM 2       │  │   VM 3       │
 │ Guest OS     │  │ Guest OS     │  │ Guest OS     │
 │ App + Libs   │  │ App + Libs   │  │ App + Libs   │
 └──────────────┘  └──────────────┘  └──────────────┘
~~~

- 하드웨어 위에 Hypervisor 설치

- 각 VM마다 운영체제(Guest OS) 전체를 포함

- 리소스 무거움

### 컨테이너(Docker)

~~~css
[ 물리 하드웨어 ]
       ↓
[ 호스트 OS (Linux 등) ]
       ↓
[ Docker Engine ]
       ↓↓↓↓↓
 ┌──────────────┐  ┌──────────────┐  ┌──────────────┐
 │ Container 1  │  │ Container 2  │  │ Container 3  │
 │ App + Libs   │  │ App + Libs   │  │ App + Libs   │
 └──────────────┘  └──────────────┘  └──────────────┘
~~~

- 컨테이너들은 호스트 OS의 커널을 공유

- 애플리케이션 + 라이브러리만 포함된 컨테이너 단위로 실행

- 불필요한 OS가 없음 → 가볍고 빠름

- 자원 사용이 효율적

## 왜 가상화가 필요한 걸까?

**리소스 효율화**

- 서버 1대를 여러 대처럼 나눠서 사용 가능

- 하드웨어 낭비 줄일 수 있음

**격리성(Isolation)**

- 서로 다른 환경을 완전히 분리

- 한 앱이 죽어도 다른 앱에 영향 없음

**테스트/배포 자동화**

- 개발 → 테스트 → 배포까지 동일한 환경 유지 가능 (특히 Docker)

**보안성**

- 서로 다른 사용자/프로세스를 독립적으로 운영 가능

## 가상화의 장점

| 장점 | 설명 |
|:---:|:---:|
| 자원 효율성 | 물리 서버 하나로 여러 작업 가능 |
| 유연성 | 필요한 환경만 골라서 빠르게 만들 수 있음 |
| 테스트에 용이 | 다양한 OS, 설정 실험 가능 |
| 격리성 보장 | 하나가 망가져도 다른 프로세스에는 영향 X |
| 배포 자동화 | Dockerfile로 같은 환경을 어디서든 재현 가능 |

## 가상화의 단점

| 단점 | 설명 |
|:---:|:---:|
| 성능 오버헤드 | 특히 VM은 OS 전체를 돌리므로 무거움 |
| 복잡도 증가 | 관리, 설정, 보안 측면에서 신경 쓸 게 많음 |
| 네트워크/디스크 이슈 | 가상화 계층이 개입되면 속도 손해 가능성 |
| Docker : 커널 공유 | 호스트 커널에 의존 → 커널 레벨 취약점에 취약 |

## C언어 할때 우리가 Docker 사용하는 이유

### 개발 환경 일관성 유지

- 시스템마다 컴파일러 버전, 라이브러리, 경로 다름 → 내 컴퓨터에서는 되지만, 다른 컴퓨터에선느 안될 수 있음

- Docker는 Dockerfile에 환경을 정의해두면 → 어디서든 똑같은 환경에서 C 코드 실행 가능

~~~Dockerfile
FROM gcc:latest
COPY . /app
WORKDIR /app
RUN gcc main.c -o main
CMD ["./main"]
~~~

이렇게 하면, 어디서든 gcc main.c 빌드 환경이 같아짐

### 빌드 자동화 & 테스트 자동화

- Makefile, Cmake 빌드 시스템을 컨테이너에 넣어서 → 코드 푸시하면 자동 빌드가 가능해짐

- CI/CD (예 : Github Actions, Jenkins)와 연동 쉬움

### 실행 환경과 호환 문제 해결

- 예를 들어, 코드가 리눅스에서만 돌아간다? → 맥북이나 윈도우에서도 Docker로 리눅스 환경 돌리면 끝!

- 특정 라이브러리나 커널 기능이 필요한 프로젝트일 때 → 해당 환경을 Docker로 재현 가능능

### 학생 / 강의 / 과제 제출용

- 실습 환경 다르면 문제 생기니까 Docker로 통일하면 편해

- 교수님 팀원한테 "이 Dockerfile 돌리면 됩니다"라고 주면 끝!

### 보안성

- 악성 코드 실험, 위험한 시스템 호출 시 Docker에서 격리된 환경에서 안전하게 테스트 가능