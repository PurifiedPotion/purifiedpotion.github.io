<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-05-11T09:42:19+00:00</updated><id>/feed.xml</id><title type="html">PurifiedPotion’s Blog</title><subtitle>A blog for computer science
</subtitle><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><entry><title type="html">CS:APP 11장 네트워크 프로그래밍 &amp;amp; Proxy 서버 C언어로 구현</title><link href="/blog/computersystem/network-programming/" rel="alternate" type="text/html" title="CS:APP 11장 네트워크 프로그래밍 &amp;amp; Proxy 서버 C언어로 구현" /><published>2025-05-08T00:00:00+00:00</published><updated>2025-05-08T00:00:00+00:00</updated><id>/blog/computersystem/network-programming</id><content type="html" xml:base="/blog/computersystem/network-programming/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#클라이언트---서버-프로그래밍-모델" id="markdown-toc-클라이언트---서버-프로그래밍-모델">클라이언트 - 서버 프로그래밍 모델</a></li>
  <li><a href="#네트워크" id="markdown-toc-네트워크">네트워크</a>    <ul>
      <li><a href="#nic-network-interface-card" id="markdown-toc-nic-network-interface-card">NIC (Network Interface Card)</a></li>
      <li><a href="#이더넷-ethernet" id="markdown-toc-이더넷-ethernet">이더넷 (Ethernet)</a>        <ul>
          <li><a href="#더-큰-lan---브릿지의-등장" id="markdown-toc-더-큰-lan---브릿지의-등장">더 큰 LAN - 브릿지의 등장</a></li>
          <li><a href="#브릿지와-허브의-차이점" id="markdown-toc-브릿지와-허브의-차이점">브릿지와 허브의 차이점</a></li>
        </ul>
      </li>
      <li><a href="#wan-wide-area-network" id="markdown-toc-wan-wide-area-network">WAN (Wide Area Network)</a></li>
      <li><a href="#internet" id="markdown-toc-internet">internet</a></li>
    </ul>
  </li>
  <li><a href="#글로벌-ip-인터넷" id="markdown-toc-글로벌-ip-인터넷">글로벌 IP 인터넷</a>    <ul>
      <li><a href="#ip-주소" id="markdown-toc-ip-주소">IP 주소</a>        <ul>
          <li><a href="#dotted-decimal" id="markdown-toc-dotted-decimal">Dotted-decimal</a></li>
        </ul>
      </li>
      <li><a href="#인터넷-도메인-이름" id="markdown-toc-인터넷-도메인-이름">인터넷 도메인 이름</a></li>
      <li><a href="#인터넷-연결" id="markdown-toc-인터넷-연결">인터넷 연결</a></li>
    </ul>
  </li>
  <li><a href="#소켓-인터페이스" id="markdown-toc-소켓-인터페이스">소켓 인터페이스</a>    <ul>
      <li><a href="#소켓-주소-구조체" id="markdown-toc-소켓-주소-구조체">소켓 주소 구조체</a></li>
    </ul>
  </li>
</ul>

<p>흥미로운 것은 모든 네트워크 응용들은 동일한 기본적인 프로그래밍 모델에 기초하고 있으며, 이들은 비슷한 전체 논리 구조를 가지며, 동일한 프로그래밍 인터페이스를 사용한다는 점이다. 개념들을 설명하고 난 후 개념들을 모두 연결해서 아주 작지만 실제로 동작하는 웹 서버를 개발할 것이다.</p>

<h2 id="클라이언트---서버-프로그래밍-모델">클라이언트 - 서버 프로그래밍 모델</h2>

<p>** 모든 네트워크 응용 프로그램은 클라이언트-서버 모델에 기초하고 있다.** 아래와 같은 사진과 같이 한 개의 서버 프로세스와 한 개 이상의 클라이언트 프로세스로 구성된다.</p>

<p><img src="/assets/img/blog/computerscience/clientservertransaction.png" alt="클라이언트 서버 모델" /></p>

<ol>
  <li>
    <p>클라이언트가 한 개의 요청(request)을 서버에 보내는 것으로 트랜잭션을 개시한다. 예를 들어, 웹 브라우저가 파일을 필요로 할때, 웹 서버로 요청을 보낸다.</p>
  </li>
  <li>
    <p>서버는 요청을 받고, 해석하고, 자신의 자원들을 적절한 방법으로 조작한다. 예를 들어, 웹 서버가 브라우저로부터 요청을 받을 때, 디스크 파일을 읽는다.</p>
  </li>
  <li>
    <p>서버는 응답(response)을 클라이언트로 보내고, 그 후에 다음 요청을 기다린다. 예를 들어, 웹 서버는 이 파일을 다시 클라이언트로 돌려보낸다.</p>
  </li>
  <li>
    <p>클라이언트는 응답을 받고 이걸을 처리한다. 예를 들어, 웹 브라우저가 서버로부터 페이지를 한 개 받은 후, 이것을 스크린에 디스플레이한다.</p>
  </li>
</ol>

<h2 id="네트워크">네트워크</h2>

<p>물리적으로 네트워크는 기하학적 위치로 구성된 <strong>계층구조 시스템</strong>이다 하위수준은 <strong>LAN(Local Area Network)</strong>으로 빌딩이나 캠퍼스에 설치된다. 가장 대중적인 LAN기술은 현재까지는 이더넷(Ehternet)이며, 시간에 따라서 엄청 발전되어 왔다. 이더넷(Ethernet)에 관련한 설명은 아래에 있다.</p>

<h3 id="nic-network-interface-card">NIC (Network Interface Card)</h3>

<p>호스트에게 네트워크는 단지 또 다른 I/O 디바이스이다. 아래 사진과 같이 네트워크에서 수신한 데이터는 I/O와 메모리 버스를 거쳐서 어댑터에서 메모리로, 대개 DMA 전송으로 복사된다. 비슷하게 데이터는 또한 메모리에서 네트워크로 복사될 수 있다.</p>

<p><img src="/assets/img/blog/computerscience/hosthardwareorganization.png" alt="호스트의 네트워크 구성" /></p>

<h3 id="이더넷-ethernet">이더넷 (Ethernet)</h3>

<p>이더넷 세그먼트는 아래 사진과 같이 몇 개의 전선들과 허브라고 부르는 작은 상자로 구성된다. 한쪽 끝은 호스트의 어댑터에 연결되고, 다른 끝은 허브의 포트에 연결된다. 허브는 각 포트에서 수신한 모든 비트를 종속적으로 다른 모든 포트로 복사한다.</p>

<p><img src="/assets/img/blog/computerscience/ethernetsegment.png" alt="이더넷 세그먼트" /></p>

<ul>
  <li>
    <p><strong>이더넷 어댑터</strong>는 어댑터의 비휘발성 메모리에 저장된 전체적으로 <strong>고유한 48비트 주소</strong>를 가진다.</p>
  </li>
  <li>
    <p>호스트는 <strong>프레임</strong>이라고 부르는 비트들을 세그먼트의 다른 호스트에 보낼 수 있다.</p>
  </li>
  <li>
    <p>각 <strong>프레임</strong>은 프레임의 <strong>소스</strong>와 <strong>목적지</strong>, 프레임의 <strong>길이</strong>를 식별할 수 있는 고정된 <strong>헤더 비트</strong>를 가지고 있으며, 그 뒤에 데이터 비트가 이어진다.</p>
  </li>
  <li>
    <p>모든 호스트 어댑터는 이 프레임을 볼 수 있지만, 목적지 호스트만이 실제로 이것을 읽어들인다.</p>
  </li>
</ul>

<h4 id="더-큰-lan---브릿지의-등장">더 큰 LAN - 브릿지의 등장</h4>

<p>아래 사진에 나타난 것처럼 전선들과 브릿지라고 하는 작은 상자들을 사용해서 **다수의 이더넷 세그먼트가 연결되어 브릿지형 이더넷이라고 하는 더 큰 LAN을 구성할 수 있다.</p>

<p><img src="/assets/img/blog/computerscience/bridgedethernetsegments.png" alt="브릿지로 연결된 이더넷 세그먼트" /></p>

<ul>
  <li>
    <p>브릿지형 이더넷에서 일부 선은 브릿지를 브릿지로 연결하고, 다른 선들은 브릿지를 허브로 연결한다.</p>
  </li>
  <li>
    <p>각 선의 대역폭은 다를 수 있다. 우리의 예제에서 브릿지-브릿지선은 1Gb/s 대역폭을, 네 개의 허브-브릿지 선은 100Mb/s 대역폭을 가진다.</p>
  </li>
</ul>

<h4 id="브릿지와-허브의-차이점">브릿지와 허브의 차이점</h4>

<ul>
  <li>
    <p>브릿지는 허브보다 더 높은 전선의 대역폭을 가진다.</p>
  </li>
  <li>
    <p>허브는 각 포트에서 수신한 모든 비트를 종속적으로 다른 모든 포트로 복사한다.</p>
  </li>
  <li>
    <p>브릿지는 우수한 분산 알고리즘을 통해 필요한 경우 선택적으로 하나의 포트에서 다른 포트로 프레임을 복사한다.</p>
  </li>
</ul>

<h3 id="wan-wide-area-network">WAN (Wide Area Network)</h3>

<p>계층구조의 상부에서 다수의 비호환성 LAN들은 라우터라고 부르는 특별한 컴퓨터에 의해서 연결될 수 있으며, <strong>라우터는 네트워크 간 연결을 구성한다(상호연결 네트워크)</strong>. 각 라우터는 이들이 연결되는 각 네트워크에 대해 어댑터(포트)를 가지고 있다. <strong>라우터는 또한 고속의 point-to-point 전화 연결을 할 수 있으며, 이들은 WAN이라고 하는 네트워크의 사례다</strong>. 이 이름은 이들이 LAN보다 지리적으로 더 넓은 지역에서 운용되기 때문에 불리게 되었다.</p>

<h3 id="internet">internet</h3>

<p><strong>internet의 중요한 특성은 이것이 매우 다르고 비호환적인 기술을 갖는 여러 가지 LAN과 WAN들로 이루어져 있다는 점이다</strong>. internet 프로토콜은 두 가지 기본 기능을 제공해야 한다.</p>

<ul>
  <li>
    <p>명명법(Naming Scheme) : internet 프로토콜은 호스트 주소를 위한 통일된 포맷을 정의해서 이 차이점들을 줄인다.</p>
  </li>
  <li>
    <p>전달기법(Delivery Mechanism) : internet 프로토콜은 데이터 비트를 패킷(packet)이라고 부르는 비연속적인 단위로 묶는 통일된 방법을 정의해서 이 차이점을 줄인다. 패킷은 패킷 크기와 소스 및 목적지 호스트 주소를 포함하는 헤더와 소스 호스트가 보낸 데이터 비트를 포함하는 데이터로 구성된다. 이것을 Datagram이라고도 부른다.</p>
  </li>
</ul>

<p>전달기법 관련하여서 패킷화하는 과정은 아래 사진과 같다. 여기서 말하는 Datagram은 (1) → (2) 로 가는 방법이다.</p>

<p><img src="/assets/img/blog/computerscience/internetpacket.png" alt="인터넷 패킷화 과정" /></p>

<h2 id="글로벌-ip-인터넷">글로벌 IP 인터넷</h2>

<p>인터넷 클라이언트 - 서버 응용의 기본적인 하드웨어 및 소프트웨어 구조는 아래 사진과 같으며, 이 구조는 1980년대 이후로 안정적이었다.</p>

<p><img src="/assets/img/blog/computerscience/clientserverstructure.png" alt="클라이언트 서버 구조" /></p>

<p>각 인터넷 호스트는 TCP/IP 프로토콜(Transmission Control Protocol/Internet Protocol)을 구현한 소프트웨어를 실행하며, 이것은 거의 모든 현대 컴퓨터 시스템에서 지원되고 있다.</p>

<p>관련한 프로토콜 HTTP/TCP/UDP 관련하여서는 <a href="../../computersystem/http-tcp-udp" class="heading flip-title">HTTP, TCP, UDP</a>을 참고하면 된다.</p>

<h3 id="ip-주소">IP 주소</h3>

<p>IPv4 주소는 비부호형 32비트 정수다. 네트워크 프로그램은 IP주소를 아래와 같은 IP주소 구조체에 저장한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* IP address structure */</span>
<span class="k">struct</span> <span class="n">in_addr</span> <span class="p">{</span>
<span class="kt">uint32_t</span> <span class="n">s_addr</span><span class="p">;</span> <span class="cm">/* Address in network byte order (big-endian) */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>TCP/IP는 네트워크 패킷 헤더에 포함되는 IP 주소 같은 모든 정수형 데이터 아이템에 대해서 통일된 <strong>Network Byte Order(Big Endian 바이트 순서)</strong>를 정의한다.</p>

<ul>
  <li>
    <p>Big Endian : 가장 큰 자릿값(최상위 바이트)을 가장 낮은 주소에, 그 다음 바이트를 뒤쪽 주소에 차례로 저장</p>
  </li>
  <li>
    <p>Little Endian : 반대로 최하위 바이트를 가장 낮은 주소에 두고, 큰 바이트로 갈수록 주소가 커짐. x86, ARM(Android/iOS) 같은 현대 CPU 대부분이 사용함</p>
  </li>
</ul>

<h4 id="dotted-decimal">Dotted-decimal</h4>

<p>IP 주소는 대게 사람들에게 dotted-decimal 표기라고 하는 형식으로 제시되며, 이것은 각 바이트가 십진수 값을 사용하고 다른 바이트들과는 점을 사용해서 구분된다. 아래와 같은 것이 dotted-decimal이다.</p>

<pre><code class="language-linux">linux&gt; hostname -i
128.2.210.175
</code></pre>

<h3 id="인터넷-도메인-이름">인터넷 도메인 이름</h3>

<p><strong>DNS(Domain Name System)</strong> 데이터베이스는 수백만 개의 호스트 엔트리로 구성되어 있으며, 이들 각각은 도메인 이름의 집합과 IP 주소 집합 사이의 매핑을 정의한다.</p>

<p>4가지의 매핑을 아래에 나열하겠다.</p>

<ol>
  <li>가장 간단한 경우로, 도메인 이름과 IP 주소 사이의 일대일 매핑</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup whaleshark.ics.cs.cmu.edu
Address: 128.2.210.175
</code></pre>

<ol>
  <li>다수의 도메인 이름이 동일한 IP 주소에 매핑</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup cs.mit.edu
Address: 18.62.1.6

linux&gt; nslookup eecs.mit.edu
Address: 18.62.1.6
</code></pre>

<ol>
  <li>다수의 도메인 이름들은 다수의 IP 주소로 매핑</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup www.twitter.com
Address: 199.16.156.6
Address: 199.16.156.70
Address: 199.16.156.102
Address: 199.16.156.230

linux&gt; nslookup twitter.com
Address: 199.16.156.102
Address: 199.16.156.230
Address: 199.16.156.6
Address: 199.16.156.70
</code></pre>

<ol>
  <li>마지막으로, 일부 유효한 도메인 이름들은 어떤 IP 주소에도 매핑되어 있지 않다.</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup edu
*** Can’t find edu: No answer
linux&gt; nslookup ics.cs.cmu.edu
*** Can’t find ics.cs.cmu.edu: No answer
</code></pre>

<h3 id="인터넷-연결">인터넷 연결</h3>

<p><strong>인터넷 client와 server는 연결(connection)을 통해서 바이트 스트림을 주고받는 방식으로 통신한다</strong>. 이 연결은 두개의 프로세스를 연결한다는 점에서 <strong>point-to-point 연결</strong>이다. 데이터가 동시에 양방향으로 흐를 수 있다는 의미에서 이것은 <strong>완전양방향(full-duplex)</strong>이다.</p>

<ul>
  <li>
    <p>소켓(Socket)은 연결의 종단점이다.</p>
  </li>
  <li>
    <p>각 소켓은 인터넷 주소와 16비트 정수 포트로 이루어진 소켓 주소를 가지며, 이것은 address : port로 나타낸다.</p>
  </li>
  <li>
    <p>클라이언트의 소켓 주소 내의 포트는 클라이언트가 연결 요청을 할 때 커널이 자동으로 할당하며, 이것은 단기(Ephemeral) 포트라고 한다.</p>
  </li>
  <li>
    <p>서버는 서비스에 연관된 포트를 사용한다.</p>
  </li>
</ul>

<p>인터넷 연결같은 경우 두 개의 종단점의 소켓 주소에 의해 유일하게 식별된다. 이 두개의 소켓 주소는 소켓 쌍이라고 알려져 있으며, 아래와 같이 tuple로 나타낸다.</p>

<p><img src="/assets/img/blog/computerscience/internetconnection.png" alt="인터넷 연결의 구조" /></p>

<h2 id="소켓-인터페이스">소켓 인터페이스</h2>

<p>소켓 인터페이스는 네트워크 응용을 만들기 위한 Unix I/O 함수들과 함께 사용되는 함수들의 집합이다.</p>

<h3 id="소켓-주소-구조체">소켓 주소 구조체</h3>

<p><strong>리눅스 커널의 관점에서 보면, 소켓은 통신을 위한 끝점이다. Unix 프로그램의 관점에서 보면 소켓은 해당 식별자를 가지는 열린 파일이다</strong>.</p>

<ul>
  <li>Unix 프로그램에서는 network도 파일처럼 여겨진다.</li>
</ul>

<p>인터넷 소켓 주소는 아래 코드와 같이</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* IP socket address structure */</span>
<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="p">{</span>
<span class="kt">uint16_t</span> <span class="n">sin_family</span><span class="p">;</span> <span class="cm">/* Protocol family (always AF_INET) */</span>
<span class="kt">uint16_t</span> <span class="n">sin_port</span><span class="p">;</span> <span class="cm">/* Port number(16bit) in network byte order */</span>
<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span> <span class="cm">/* IP address in network byte order */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* Pad to sizeof(struct sockaddr) */</span>
<span class="p">};</span>

<span class="cm">/* Generic socket address structure (for connect, bind, and accept) */</span>
<span class="k">struct</span> <span class="n">sockaddr</span> <span class="p">{</span>
<span class="kt">uint16_t</span> <span class="n">sa_family</span><span class="p">;</span> <span class="cm">/* Protocol family */</span>
<span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span> <span class="cm">/* Address data */</span>
<span class="p">};</span>
</code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[우리가 웹을 검색하고, 이메일 메시지를 보내고, 온라인 게임을 하는 등의 모든 경우 우리는 네트워크 응용을 사용한다]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">8주차 퀴즈</title><link href="/blog/algorithm/8th-week/" rel="alternate" type="text/html" title="8주차 퀴즈" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>/blog/algorithm/8th-week</id><content type="html" xml:base="/blog/algorithm/8th-week/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#8주차-퀴즈" id="markdown-toc-8주차-퀴즈">8주차 퀴즈</a>    <ul>
      <li><a href="#1-http-get-요청과-post-요청의-가장-큰-차이점은-무엇이며-이것이-요청-헤더나-데이터-전송에-어떤-영향을-미칩니까-1점" id="markdown-toc-1-http-get-요청과-post-요청의-가장-큰-차이점은-무엇이며-이것이-요청-헤더나-데이터-전송에-어떤-영향을-미칩니까-1점">1. HTTP GET 요청과 POST 요청의 가장 큰 차이점은 무엇이며, 이것이 요청 헤더나 데이터 전송에 어떤 영향을 미칩니까? (1점)</a></li>
      <li><a href="#2-http-응답-코드-404의-의미는-무엇입니까-그리고-서버가-요청을-처리할-수-없을-때-반환하는-http-상태-코드는-무엇입니까-1점" id="markdown-toc-2-http-응답-코드-404의-의미는-무엇입니까-그리고-서버가-요청을-처리할-수-없을-때-반환하는-http-상태-코드는-무엇입니까-1점">2. HTTP 응답 코드 404의 의미는 무엇입니까? 그리고 서버가 요청을 처리할 수 없을 때 반환하는 HTTP 상태 코드는 무엇입니까? (1점)</a></li>
      <li><a href="#3-파일-디스크립터file-descriptor란-무엇인지-간단히-설명하고-unixlinux-시스템에서-표준-입출력에러의-파일-디스크립터-번호를-쓰세요-1점" id="markdown-toc-3-파일-디스크립터file-descriptor란-무엇인지-간단히-설명하고-unixlinux-시스템에서-표준-입출력에러의-파일-디스크립터-번호를-쓰세요-1점">3. 파일 디스크립터(File Descriptor)란 무엇인지 간단히 설명하고 UNIX/Linux 시스템에서 표준 입출력/에러의 파일 디스크립터 번호를 쓰세요. (1점)</a></li>
      <li><a href="#4-tcp에서의-3-way-handshake-절차를-설명하세요-1점" id="markdown-toc-4-tcp에서의-3-way-handshake-절차를-설명하세요-1점">4. TCP에서의 ‘3-way handshake’ 절차를 설명하세요. (1점)</a></li>
      <li><a href="#5-tcp와-udp에서-패킷-손실-시-대처-방법에는-어떤-차이가-있나요-1점" id="markdown-toc-5-tcp와-udp에서-패킷-손실-시-대처-방법에는-어떤-차이가-있나요-1점">5. TCP와 UDP에서 패킷 손실 시 대처 방법에는 어떤 차이가 있나요? (1점)</a>        <ul>
          <li><a href="#tcp" id="markdown-toc-tcp">TCP</a></li>
          <li><a href="#udp" id="markdown-toc-udp">UDP</a></li>
        </ul>
      </li>
      <li><a href="#6-다음-ansi-c-프로그램에서-출력되는-내용은-무엇인가요-1점" id="markdown-toc-6-다음-ansi-c-프로그램에서-출력되는-내용은-무엇인가요-1점">6. 다음 ANSI C 프로그램에서 출력되는 내용은 무엇인가요? (1점)</a></li>
    </ul>
  </li>
</ul>

<h2 id="8주차-퀴즈">8주차 퀴즈</h2>

<h3 id="1-http-get-요청과-post-요청의-가장-큰-차이점은-무엇이며-이것이-요청-헤더나-데이터-전송에-어떤-영향을-미칩니까-1점">1. HTTP GET 요청과 POST 요청의 가장 큰 차이점은 무엇이며, 이것이 요청 헤더나 데이터 전송에 어떤 영향을 미칩니까? (1점)</h3>

<p>GET 요청은 데이터를 URL의 일부(query string)로 전송하지만 POST 요청은 데이터를 요청 본문(body)에 포함합니다.
이 차이 때문에</p>

<p>1)  GET 요청의 URL 길이에는 브라우저나 서버에 따라 제한이 있습니다. 이로 인해 전송할 수 있는 데이터의 양이 제한됩니다.</p>

<p>2)  POST 요청은 ‘Content-Length’와 ‘Content-Type’ 같은 추가적인 헤더 정보를 필요로 합니다.</p>

<h3 id="2-http-응답-코드-404의-의미는-무엇입니까-그리고-서버가-요청을-처리할-수-없을-때-반환하는-http-상태-코드는-무엇입니까-1점">2. HTTP 응답 코드 404의 의미는 무엇입니까? 그리고 서버가 요청을 처리할 수 없을 때 반환하는 HTTP 상태 코드는 무엇입니까? (1점)</h3>

<p>HTTP 응답 코드 404는 “Not Found”를 의미합니다. 이 코드는 서버가 요청된 리소스를 찾을 수 없을 때 반환됩니다. 
서버가 요청을 처리할 수 없을 때 반환하는 HTTP 상태 코드는 500입니다. 이 코드는 “Internal Server Error”를 나타냅니다.</p>

<h3 id="3-파일-디스크립터file-descriptor란-무엇인지-간단히-설명하고-unixlinux-시스템에서-표준-입출력에러의-파일-디스크립터-번호를-쓰세요-1점">3. 파일 디스크립터(File Descriptor)란 무엇인지 간단히 설명하고 UNIX/Linux 시스템에서 표준 입출력/에러의 파일 디스크립터 번호를 쓰세요. (1점)</h3>

<p>파일 디스크립터는 운영 체제에서 파일이나 다른 입출력 리소스에 대한 접근을 추상화하는데 사용되는 정수입니다. 파일 디스크립터를 통해 운영 체제는 파일, 파이프, 소켓 등 다양한 입출력 리소스를 일관된 방식으로 관리할 수 있습니다. 예를 들어, 파일을 열면 운영 체제는 해당 파일을 가리키는 파일 디스크립터를 프로그램에 제공합니다. UNIX/Linux 시스템에서 표준 입력의 파일 디스크립터 번호는 0, 표준 출력은 1, 그리고 표준 에러는 2입니다.</p>

<h3 id="4-tcp에서의-3-way-handshake-절차를-설명하세요-1점">4. TCP에서의 ‘3-way handshake’ 절차를 설명하세요. (1점)</h3>

<p>TCP의 ‘3-way handshake’는 연결 설정 과정에서 사용되는 절차이다. 이 과정은 다음과 같이 세 단계로 이루어진다:</p>

<p>1)  클라이언트가 서버에 SYN(Synchronize) 패킷을 보내 연결 요청을 한다.</p>

<p>2)  서버는 SYN-ACK(Synchronize-Acknowledge) 패킷으로 응답하여 연결 요청을 받았음을 알리고, 자신도 연결 준비가 되었음을 나타낸다.</p>

<p>3)  클라이언트는 ACK(Acknowledge) 패킷을 서버에 보내 연결을 확정한다.</p>

<h3 id="5-tcp와-udp에서-패킷-손실-시-대처-방법에는-어떤-차이가-있나요-1점">5. TCP와 UDP에서 패킷 손실 시 대처 방법에는 어떤 차이가 있나요? (1점)</h3>

<h4 id="tcp">TCP</h4>

<ul>
  <li>
    <p>TCP는 패킷 손실이 발생하면 자동으로 재전송 시도</p>
  </li>
  <li>
    <p>수신자는 받은 패킷에 대해 확인 응답(ACK)을 보내고,</p>
  </li>
  <li>
    <p>송신자는 ACK를 받지 못한 패킷을 재전송</p>
  </li>
</ul>

<h4 id="udp">UDP</h4>

<ul>
  <li>
    <p>반면, UDP는 패킷 손실에 대해 자체적으로 대처하지 않음</p>
  </li>
  <li>
    <p>UDP는 확인 응답이나 재전송 기능이 없어, 패킷 손실이 발생하면 이를 어플리케이션 레벨에서 처리해야 함</p>
  </li>
</ul>

<h3 id="6-다음-ansi-c-프로그램에서-출력되는-내용은-무엇인가요-1점">6. 다음 ANSI C 프로그램에서 출력되는 내용은 무엇인가요? (1점)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> </span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> 
<span class="p">{</span> 
   <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">};</span> 
   <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
   <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> 
   <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> 
   <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> 
   <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span> 
   <span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> 
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>출력값 : 10, 10, 14</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/Algorithm.png" /><media:content medium="image" url="/assets/img/blog/postimage/Algorithm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Datagram Socket과 Stream Socket</title><link href="/blog/computersystem/datagram-stream-socket/" rel="alternate" type="text/html" title="Datagram Socket과 Stream Socket" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>/blog/computersystem/datagram-stream-socket</id><content type="html" xml:base="/blog/computersystem/datagram-stream-socket/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#datagram-socket-udp-기반" id="markdown-toc-datagram-socket-udp-기반">Datagram Socket (UDP 기반)</a>    <ul>
      <li><a href="#datagram-socket-udp의-내부-동작" id="markdown-toc-datagram-socket-udp의-내부-동작">Datagram Socket (UDP)의 내부 동작</a></li>
    </ul>
  </li>
  <li><a href="#stream-socket-tcp-기반" id="markdown-toc-stream-socket-tcp-기반">Stream Socket (TCP 기반)</a>    <ul>
      <li><a href="#stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake" id="markdown-toc-stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake">Stream Socket (TCP)의 내부 동작 + TCP 연결 설정 : 3-way handshake</a></li>
    </ul>
  </li>
  <li><a href="#비교-요약" id="markdown-toc-비교-요약">비교 요약</a></li>
</ul>

<p>네트워크 통신 방식에 따라 소켓을 분류한 두 가지 종류 Datagram Socket과 Stream Socket을 알려줄게</p>

<h2 id="datagram-socket-udp-기반">Datagram Socket (UDP 기반)</h2>

<ul>
  <li>
    <p>기반 프로토콜 : UDP (User Datagram Protocol)</p>
  </li>
  <li>
    <p>연결 방식 : 비연결형 (Connectionless)</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p><strong>비연결형</strong> : 연결 없이 바로 데이터 전송</p>
      </li>
      <li>
        <p><strong>신뢰성 없음</strong> : 순서 보장 X, 재전송 X, 확인 응답 X</p>
      </li>
      <li>
        <p><strong>오버헤드 작음</strong> : 빠르고 단순</p>
      </li>
    </ul>
  </li>
  <li>
    <p>용도 예시 :</p>

    <ul>
      <li>
        <p>스트리밍 (비디오/오디오)</p>
      </li>
      <li>
        <p>실시간 게임</p>
      </li>
      <li>
        <p>DNS 요청</p>
      </li>
    </ul>
  </li>
</ul>

<p>예제 : C에서의 예시 (Datagram Socket)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// SOCK_DGRAM이 핵심</span>
</code></pre></div></div>

<h3 id="datagram-socket-udp의-내부-동작">Datagram Socket (UDP)의 내부 동작</h3>

<ul>
  <li>
    <p>Data를 전송하면, 해당 data는 Datagram(데이터그램)으로 만들어짐</p>
  </li>
  <li>
    <p>각 Datagram은 독립적으로 처리됨(순서/재전송 신경 안 씀)</p>
  </li>
  <li>
    <p>수신 측이 없어도 전송은 진행됨</p>
  </li>
</ul>

<blockquote>
  <p>전송 성공 여부는 알 수 없음</p>
</blockquote>

<p>예제 : Data 전송 예</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 송신자</span>
<span class="n">sendto</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

<span class="c1">// 수신자</span>
<span class="n">recvfrom</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFLEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fromlen</span><span class="p">);</span>
</code></pre></div></div>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">sendto</code>나 <code class="language-plaintext highlighter-rouge">recvfrom</code>에서 연결 상태를 유지하지 않고 주소를 직접 지정함</p>
</blockquote>

<h2 id="stream-socket-tcp-기반">Stream Socket (TCP 기반)</h2>

<ul>
  <li>
    <p>기반 프로토콜 : TCP (Transmission Control Protocol)</p>
  </li>
  <li>
    <p>연결 방식 : 연결형 (Connection-oriented)</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p><strong>연결지향형</strong> : 먼저 연결을 설정한 후 데이터를 주고받음, 통신 전에 연결(3-way handshake) 필요</p>
      </li>
      <li>
        <p><strong>신뢰성</strong> : 순서 보장, 오류 검출, 재전송</p>
      </li>
      <li>
        <p><strong>흐름 제어</strong> : 수신자가 감당할 수 있을 만큼만 전송</p>
      </li>
      <li>
        <p><strong>혼잡 제어</strong> : 네트워크 상황에 따라 전송 속도 조절</p>
      </li>
      <li>
        <p>속도는 느릴 수 있지만 신뢰성 높음</p>
      </li>
    </ul>
  </li>
  <li>
    <p>용도 예시 :</p>

    <ul>
      <li>
        <p>웹 서비스 (HTTP)</p>
      </li>
      <li>
        <p>이메일 (SMTP)</p>
      </li>
      <li>
        <p>파일 전송 (FTP)</p>
      </li>
    </ul>
  </li>
</ul>

<p>예제 : C에서의 예시 (Stream Socket)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// SOCK_STREAM이 핵심</span>
</code></pre></div></div>

<h3 id="stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake">Stream Socket (TCP)의 내부 동작 + TCP 연결 설정 : 3-way handshake</h3>

<p><strong>3way handshake</strong>는 양쪽 통신자가 연결을 동기화하고 준비됐는지 확인하는 과정</p>

<p><strong>과정 요약</strong></p>

<ol>
  <li>
    <p>client → server : <code class="language-plaintext highlighter-rouge">SYN</code> 플래그 세팅된 패킷 전송 (연결 요청)</p>
  </li>
  <li>
    <p>server → client : <code class="language-plaintext highlighter-rouge">SYN + ACK</code> 패킷 전송 (요청 수락 + 서버도 연결 요청)</p>
  </li>
  <li>
    <p>client → server : <code class="language-plaintext highlighter-rouge">ACK</code> 전송 (서버의 연결 수락)</p>
  </li>
</ol>

<blockquote>
  <p>이 과정을 거친 뒤 양쪽 모두 연결이 되었고, 데이터를 주고받을 수 있어</p>
</blockquote>

<p><strong>예시 흐름</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">송신자</th>
      <th style="text-align: center">수신자</th>
      <th style="text-align: center">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">SYN, seq = x</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">SYN + ACK, seq = y, ack = x+1</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">ACK, seq = x+1, ack = y+1</td>
    </tr>
  </tbody>
</table>

<p><strong>TCP 데이터 전송</strong></p>

<ol>
  <li>
    <p>데이터는 스트림(stream)으로 보내짐. 내부적으로 작은 단위로 나뉘어 전송됨.</p>
  </li>
  <li>
    <p>각 패킷은 시퀸스 번호(sequence number)를 가짐</p>
  </li>
  <li>
    <p>수신자는 받은 순서대로 조립하고, ACK로 확인 메시지 보냄</p>
  </li>
  <li>
    <p>손실되면 재전송함</p>
  </li>
</ol>

<p><strong>TCP 연결 종료 : 4-way handshake</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">전송</th>
      <th style="text-align: center">인자</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">A → B</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">FIN</code></td>
      <td style="text-align: center">A가 종료 요청</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">B → A</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">ACK</code></td>
      <td style="text-align: center">B가 확인</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">B → A</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">FIN</code></td>
      <td style="text-align: center">B도 종료 요청</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">A → B</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">ACK</code></td>
      <td style="text-align: center">A가 확인하고 종료</td>
    </tr>
  </tbody>
</table>

<h2 id="비교-요약">비교 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">Datagram Socket (UDP)</th>
      <th style="text-align: center">Stream Socket (TCP)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">연결 여부</td>
      <td style="text-align: center">비연결 (Connectionless)</td>
      <td style="text-align: center">연결 (Connection-oriented)</td>
    </tr>
    <tr>
      <td style="text-align: center">연결 과정</td>
      <td style="text-align: center">없음</td>
      <td style="text-align: center">3-way handshake 필요</td>
    </tr>
    <tr>
      <td style="text-align: center">오류 처리</td>
      <td style="text-align: center">없음</td>
      <td style="text-align: center">ACK + 재전송</td>
    </tr>
    <tr>
      <td style="text-align: center">신뢰성</td>
      <td style="text-align: center">낮음</td>
      <td style="text-align: center">높음</td>
    </tr>
    <tr>
      <td style="text-align: center">Data 순서 보장</td>
      <td style="text-align: center">안됨</td>
      <td style="text-align: center">됨(시퀸스 번호로 순서 보장)</td>
    </tr>
    <tr>
      <td style="text-align: center">속도</td>
      <td style="text-align: center">빠름</td>
      <td style="text-align: center">상대적으로 느림</td>
    </tr>
    <tr>
      <td style="text-align: center">오버헤드</td>
      <td style="text-align: center">작음</td>
      <td style="text-align: center">큼</td>
    </tr>
    <tr>
      <td style="text-align: center">사용 예시</td>
      <td style="text-align: center">실시간 전송, DNS 등</td>
      <td style="text-align: center">웹, 이메일, 파일 전송 등</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[Datagram Socket과 Stream Socket은 네트워크 통신 방식에 따라 소켓을 분류한 두 가지 종류이며, 각각은 UDP와 TCP를 기반으로 두고 있음]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">HTTP, TCP, UDP</title><link href="/blog/computersystem/http-tcp-udp/" rel="alternate" type="text/html" title="HTTP, TCP, UDP" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>/blog/computersystem/http-tcp-udp</id><content type="html" xml:base="/blog/computersystem/http-tcp-udp/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#개념-요약" id="markdown-toc-개념-요약">개념 요약</a></li>
  <li><a href="#각-프로토콜-상세-비교" id="markdown-toc-각-프로토콜-상세-비교">각 프로토콜 상세 비교</a>    <ul>
      <li><a href="#1-http" id="markdown-toc-1-http">1. HTTP</a></li>
      <li><a href="#2-tcp" id="markdown-toc-2-tcp">2. TCP</a></li>
      <li><a href="#3-udp" id="markdown-toc-3-udp">3. UDP</a></li>
    </ul>
  </li>
  <li><a href="#계층별-차이-예시로-이해하기" id="markdown-toc-계층별-차이-예시로-이해하기">계층별 차이 예시로 이해하기</a></li>
  <li><a href="#정리-요약" id="markdown-toc-정리-요약">정리 요약</a></li>
</ul>

<h2 id="개념-요약">개념 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">프로토콜</th>
      <th style="text-align: center">설명</th>
      <th style="text-align: center">위치하는 계층 (TCP/IP 기준)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">HTTP (HyperText Transfer Protocol)</td>
      <td style="text-align: center">웹 브라우저와 서버 간의 데이터 전송 (ex. HTML, 이미지 요청 등)</td>
      <td style="text-align: center">애플리케이션 계층</td>
    </tr>
    <tr>
      <td style="text-align: center">TCP (Transmission Control Protocol)</td>
      <td style="text-align: center">신뢰성 있는 연결 지향형 데이터 전송 (패킷 손실 검사 및 재전송)</td>
      <td style="text-align: center">전송 계층</td>
    </tr>
    <tr>
      <td style="text-align: center">UDP (User Datagram Protocol)</td>
      <td style="text-align: center">빠르지만 신뢰성 없는 연결less형 데이터 전송</td>
      <td style="text-align: center">전송 계층</td>
    </tr>
  </tbody>
</table>

<p>TCP/ IP 게층 모델에 관하여서는 <a href="../../computersystem/osi-7-layer" class="heading flip-title">OSI 7 계층(OSI7 Layer)</a>의 하단에 잠깐 다루니 참고하도록 하자</p>

<h2 id="각-프로토콜-상세-비교">각 프로토콜 상세 비교</h2>

<h3 id="1-http">1. HTTP</h3>

<ul>
  <li>
    <p>계층 : application 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>client-server 구조 (browser가 server에 요청)</p>
      </li>
      <li>
        <p>요청/응답 방식(GET, POST 등)</p>
      </li>
      <li>
        <p>TCP 위에서 동작함 (즉, HTTP는 TCP를 기반으로 함)</p>
      </li>
      <li>
        <p>예 : 웹사이트 접속, API 호출</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="2-tcp">2. TCP</h3>

<ul>
  <li>
    <p>계층 : 전송 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>연결 지향 (3-way handshake로 연결 수립)</p>
      </li>
      <li>
        <p>데이터 순서 보장</p>
      </li>
      <li>
        <p>손실된 패킷 재전송</p>
      </li>
      <li>
        <p>속도는 상대적으로 느림</p>
      </li>
      <li>
        <p>예 : 웹서핑, 이메일, 파일 다운로드</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="3-udp">3. UDP</h3>

<ul>
  <li>
    <p>계층 : 전송 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>비연결형 (handshake 없이 즉시 전송)</p>
      </li>
      <li>
        <p>데이터 순서/전송 보장 없음</p>
      </li>
      <li>
        <p>빠름, 지연 최소화</p>
      </li>
      <li>
        <p>예 : 실시간 스트리밍, VoIP, 게임</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="계층별-차이-예시로-이해하기">계층별 차이 예시로 이해하기</h2>

<p>웹 브라우저로 웹 페이지 접속 시 흐름 :</p>

<ol>
  <li>
    <p>HTTP 요청 생성 → (애플리케이션 계층)</p>
  </li>
  <li>
    <p>TCP 연결 수립 후 데이터 전송 → (전송 계층)</p>
  </li>
  <li>
    <p>IP 주소 기반으로 목적지 라우팅 → (인터넷 계층)</p>
  </li>
  <li>
    <p>Ethernet/Wi-Fi를 통해 실제 전송 → (네트워크 인터페이스 계층)</p>
  </li>
</ol>

<h2 id="정리-요약">정리 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">HTTP</th>
      <th style="text-align: center">TCP</th>
      <th style="text-align: center">UDP</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">계층</td>
      <td style="text-align: center">application</td>
      <td style="text-align: center">전송</td>
      <td style="text-align: center">전송</td>
    </tr>
    <tr>
      <td style="text-align: center">연결 방식</td>
      <td style="text-align: center">연결 필요 (TCP 기반)</td>
      <td style="text-align: center">연결 지향</td>
      <td style="text-align: center">비연결형</td>
    </tr>
    <tr>
      <td style="text-align: center">신뢰성</td>
      <td style="text-align: center">TCP에 의존</td>
      <td style="text-align: center">높음 (재전송, 순서 보장)</td>
      <td style="text-align: center">낮음 (손실 허용)</td>
    </tr>
    <tr>
      <td style="text-align: center">속도</td>
      <td style="text-align: center">중간</td>
      <td style="text-align: center">느림</td>
      <td style="text-align: center">빠름</td>
    </tr>
    <tr>
      <td style="text-align: center">용도</td>
      <td style="text-align: center">웹, API</td>
      <td style="text-align: center">웹, 이메일</td>
      <td style="text-align: center">스트리밍, 게임, DNS</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[HTTP, TCP, UDP는 네트워크 통신에서 자주 등장하는 개념들이고, 이들은 OSI 7계층 모델 또는 TCP/IP 4계층 모델의 서로 다른 계층에 위치해 있어. 아래에 각 개념과 계층별 차이점을 정리해줄게]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">IP Layer</title><link href="/blog/computersystem/ip-layer/" rel="alternate" type="text/html" title="IP Layer" /><published>2025-05-05T00:00:00+00:00</published><updated>2025-05-05T00:00:00+00:00</updated><id>/blog/computersystem/ip-layer</id><content type="html" xml:base="/blog/computersystem/ip-layer/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#ip-layer란" id="markdown-toc-ip-layer란">IP Layer란?</a></li>
  <li><a href="#왜-필요한가" id="markdown-toc-왜-필요한가">왜 필요한가?</a></li>
  <li><a href="#핵심-기능-상세" id="markdown-toc-핵심-기능-상세">핵심 기능 상세</a></li>
  <li><a href="#ipv4-헤더-구조-한눈에-보기" id="markdown-toc-ipv4-헤더-구조-한눈에-보기">IPv4 헤더 구조 한눈에 보기</a></li>
  <li><a href="#흐름-예시-간단-시나리오" id="markdown-toc-흐름-예시-간단-시나리오">흐름 예시 (간단 시나리오)</a></li>
  <li><a href="#개발자-관점--유용한-cli" id="markdown-toc-개발자-관점--유용한-cli">개발자 관점 : 유용한 CLI</a></li>
  <li><a href="#자주-헷갈리는-점-정리" id="markdown-toc-자주-헷갈리는-점-정리">자주 헷갈리는 점 정리</a></li>
  <li><a href="#마무리" id="markdown-toc-마무리">마무리</a></li>
</ul>

<h2 id="ip-layer란">IP Layer란?</h2>

<p>IP (Internet Protocol) Layer는 <strong>TCP/IP 4계층 모델</strong>에서 네트워크 계층(Network Layer)에 해당하며, OSI 7계층으로 치면 <strong>3계층</strong>임
가장 핵심적인 역할은 “<strong>패킷을 한 네트워크에서 다른 네트워크로 최적의 경로를 따라 전달</strong>”하는 것—즉 <strong>논리적 주소(=IP 주소)</strong> 기반의 <strong>라우팅</strong></p>

<h2 id="왜-필요한가">왜 필요한가?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">문제</th>
      <th style="text-align: center">IP Layer가 제공하는 해결책</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">물리적으로 떨어져 있는 수많은 LAN·WAN을 하나의 ‘인터넷’으로 묶어야 함</td>
      <td style="text-align: center">전 세계적으로 유일한 주소 체계(IPv4/IPv6)와 계층적 라우팅</td>
    </tr>
    <tr>
      <td style="text-align: center">이기종 네트워크(이더넷, Wi-Fi, 5G, 광망 …)간 데이터 전달</td>
      <td style="text-align: center">서로 다른 링크 계층을 통일된 패킷 형식(IP Datagram)으로 캡슐화</td>
    </tr>
    <tr>
      <td style="text-align: center">큰 데이터그램이 링크 MTU보다 클 때</td>
      <td style="text-align: center">Fragmentation &amp; Reassembly(IPv4만 IPv6은 PMTU 디스커버리 사용)</td>
    </tr>
    <tr>
      <td style="text-align: center">전송 중 오류·혼잡·노드 고장 감지</td>
      <td style="text-align: center">ICMP로 오류·제어 메시지 전달</td>
    </tr>
  </tbody>
</table>

<h2 id="핵심-기능-상세">핵심 기능 상세</h2>

<ol>
  <li>
    <p>논리적 주소 지정 (Addressing)</p>

    <ul>
      <li>
        <p>IPv4 : 32-bit, dotted-decimal(192.0.2.4)</p>
      </li>
      <li>
        <p>IPv6 : 128-bit, hexadecimal 콜론 표기(2001:db8::1)</p>
      </li>
      <li>
        <p>네트워크/호스트 부분을 사용해 계층적(aggregation) 라우팅을 가능케 함</p>
      </li>
    </ul>
  </li>
  <li>
    <p>패킷화 (Encapsulation)</p>

    <ul>
      <li>상위 계층(TCP, UDP, ICMP 등) 세그먼트를 IP Header + Payload 형태로 감싼 뒤 하위 링크 계층(이더넷 프레임 등)에 다시 캡슐화</li>
    </ul>
  </li>
  <li>
    <p>라우팅 (Routing &amp; Forwarding)</p>

    <ul>
      <li>
        <p>Forwarding : 라우터가 목적지 주소를 보고 다음 홉(next-hop) 인터페이스로 패킷을 넘김</p>
      </li>
      <li>
        <p>Routing : 라우터들이 RIP, OSPF, BGP 같은 라우팅 프로토콜로 테이블을 동적으로 구축</p>
      </li>
    </ul>
  </li>
  <li>
    <p>분할 및 재조합 (Fragmentation/Reassembly)</p>

    <ul>
      <li>
        <p>IPv4 헤더의 Identification, Flags, Fragment Offset 필드로 조각화 추적</p>
      </li>
      <li>
        <p>IPv6은 기본적으로 조각화를 금지, 발신 호스트가 Path MTU Discovery로 크기를 조정</p>
      </li>
    </ul>
  </li>
  <li>
    <p>품질과 오류 제어</p>

    <ul>
      <li>
        <p>IPv4 Header Checksum으로 1-hop 오류 검출(IPv6에는 없음 : 링크 계층/전송 계층에 맡김)</p>
      </li>
      <li>
        <p>ICMP를 통해 “Destination Unreachable”, “Time Exceeded” 등 메시지 반환</p>
      </li>
    </ul>
  </li>
</ol>

<h2 id="ipv4-헤더-구조-한눈에-보기">IPv4 헤더 구조 한눈에 보기</h2>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
</span><span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|Ver|</span> IHL|DSCP|ECN|         Total Length                        |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>        Identification         |Flags|      Fragment Offset    |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>  TTL  | Protocol |    Header Checksum                         |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>                       Source Address                          |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>                    Destination Address                        |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>                    Options      (0 ~ 40 bytes)                |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></code></pre></div></div>

<ul>
  <li>
    <p>Ver/IHL : 버전(4)과 헤더 길이(32비트 word 수)</p>
  </li>
  <li>
    <p>Total Length : 헤더 + 데이터 전체 길이</p>
  </li>
  <li>
    <p>TTL : 홉 수 제한(루프 방지)</p>
  </li>
  <li>
    <p>Protocol : 상위 프로토콜 번호(TCP = 6, UDP = 17…)</p>
  </li>
  <li>
    <p>Options : Timestamp, Record Route 등 거의 사용 안함</p>
  </li>
</ul>

<p>IPv6는 고정 40바이트 헤더에 별도 확장 헤더 체인을 사용해 단순화/고속화함</p>

<h2 id="흐름-예시-간단-시나리오">흐름 예시 (간단 시나리오)</h2>

<ol>
  <li>
    <p>192.168.1.10:5000 → 142.250.78.14:443(TCP)</p>
  </li>
  <li>
    <p>TCP 세그먼트가 IP Datagram으로 캡슐화</p>
  </li>
  <li>
    <p>로컬 라우터가 목적지 네트워크(AS15169)를 향한 default route 선택</p>
  </li>
  <li>
    <p>중간 BGP 라우터들이 TTL을 1씩 감소시키며 패킷 포워딩</p>
  </li>
  <li>
    <p>Google 프런트엔드 서버에서 TCP ACK, HTTP/2 응답 → 역방향 경로로 전송</p>
  </li>
</ol>

<h2 id="개발자-관점--유용한-cli">개발자 관점 : 유용한 CLI</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">작업</th>
      <th style="text-align: center">IPv4</th>
      <th style="text-align: center">IPv6</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">라우팅 테이블 확인</td>
      <td style="text-align: center">ip route show</td>
      <td style="text-align: center">ip -6 route show</td>
    </tr>
    <tr>
      <td style="text-align: center">패킷 흐름 추적</td>
      <td style="text-align: center">traceroute 8.8.8.8</td>
      <td style="text-align: center">traceroute -6 2001:4860:4860::8888</td>
    </tr>
    <tr>
      <td style="text-align: center">ICMP Echo</td>
      <td style="text-align: center">ping -c 4 host</td>
      <td style="text-align: center">ping6 -c 4 host</td>
    </tr>
  </tbody>
</table>

<h2 id="자주-헷갈리는-점-정리">자주 헷갈리는 점 정리</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">오해</th>
      <th style="text-align: center">실제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">“IP = 인터넷 전체 프로토콜 스택”</td>
      <td style="text-align: center">IP는 한 계층일 뿐, 아래(링크)/위(전송)/위의 위(애플리케이션) 계층이 따로 있다</td>
    </tr>
    <tr>
      <td style="text-align: center">“IP가 연결 지향”</td>
      <td style="text-align: center">IP는 비연결형, 비신뢰성∙Best-Effort. 신뢰성은 TCP가 따로 보장</td>
    </tr>
    <tr>
      <td style="text-align: center">“IPv6는 단순히 주소 길이만 4배”</td>
      <td style="text-align: center">헤더 단순화, Neighbour Discovery, 확장 헤더, IPsec 의무 지원 등 근본적 개선 포함</td>
    </tr>
  </tbody>
</table>

<h2 id="마무리">마무리</h2>

<p>IP Layer는 <strong>인터넷을 ‘한 덩어리’로 보이게 해 주는 추상화</strong>입니다. 여기서 다룬 주소 지정, 라우팅, 조각화, ICMP 등의 기초가 잡혀 있으면 TCP, UDP, TLS 같은 상위 계층을 배울 때 훨씬 수월해짐</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[IP (Internet Protocol) Layer는 TCP/IP 4계층 모델에서 네트워크 계층(Network Layer)에 해당하며, OSI 7계층으로 치면 3계층입니다. 가장 핵심적인 역할은 “패킷을 한 네트워크에서 다른 네트워크로 최적의 경로를 따라 전달”하는 것—즉 논리적 주소(=IP 주소) 기반의 라우팅입니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">OSI 7 계층(OSI7 Layer)</title><link href="/blog/computersystem/osi-7-layer/" rel="alternate" type="text/html" title="OSI 7 계층(OSI7 Layer)" /><published>2025-05-05T00:00:00+00:00</published><updated>2025-05-05T00:00:00+00:00</updated><id>/blog/computersystem/osi-7-layer</id><content type="html" xml:base="/blog/computersystem/osi-7-layer/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#한눈에-보는-osi-7계층" id="markdown-toc-한눈에-보는-osi-7계층">한눈에 보는 OSI 7계층</a></li>
  <li><a href="#계층별-세부사항" id="markdown-toc-계층별-세부사항">계층별 세부사항</a></li>
  <li><a href="#왜-tcpip-4계층-모델을-더-많이-쓸까" id="markdown-toc-왜-tcpip-4계층-모델을-더-많이-쓸까">왜 TCP/IP 4계층 모델을 더 많이 쓸까?</a></li>
  <li><a href="#osi-7계층을-배우는-이유" id="markdown-toc-osi-7계층을-배우는-이유">OSI 7계층을 배우는 이유</a></li>
</ul>

<p><strong>OSI 7 계층</strong>은 <strong>물리 신호부터 user application</strong>까지 <strong>네트워크 기능을 일곱 단계로 나눈 개념적 설계도</strong>이다. 실무에선 TCP/IP 4계층으로 단순화해 쓰지만, 문제 분석과 개념 정리에 여전히 유용함</p>

<h2 id="한눈에-보는-osi-7계층">한눈에 보는 OSI 7계층</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">번호</th>
      <th style="text-align: center">계층 이름</th>
      <th style="text-align: center">주요 기능</th>
      <th style="text-align: center">예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">응용 계층 (Application)</td>
      <td style="text-align: center">사용자와 직접 상호작용, 네트워크 서비스 제공</td>
      <td style="text-align: center">HTTPS/HTTPS, FTP, SMTP, DNS, SSH</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">표현 계층 (Presentation)</td>
      <td style="text-align: center">데이터 형식 변환, 암호화/복호화, 압축</td>
      <td style="text-align: center">JPEG, MP3, SSL</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">세션 계층 (Session)</td>
      <td style="text-align: center">연결 설정/유지/종료, 세션 관리</td>
      <td style="text-align: center">NetBIOS, RPC, PPTP</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">전송 계층 (Transport)</td>
      <td style="text-align: center">데이터 전송 보장(신뢰성), 오류 제어</td>
      <td style="text-align: center">TCP, UDP, QUIC, SCTP</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">네트워크 계층 (Network)</td>
      <td style="text-align: center">주소 지정/경로 선택(라우팅)</td>
      <td style="text-align: center">IP, ICMP, ARP, OSPF, BGP</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">데이터링크 계층 (Data-Link)</td>
      <td style="text-align: center">프레임 생성, MAC 주소 기반 전달, 에러 감지</td>
      <td style="text-align: center">Ethernet, Wi-Fi 802.11, PPP, VLAN, 스위치</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">물리 계층 (Physical)</td>
      <td style="text-align: center">0/1 신호를 실제 매체로 전송</td>
      <td style="text-align: center">UTP 케이블, 광섬유, 전파, 허브, 리피터</td>
    </tr>
  </tbody>
</table>

<h2 id="계층별-세부사항">계층별 세부사항</h2>

<ol>
  <li>물리 계층</li>
</ol>

<p>“전길줄에 0과 1을 어떻게 흘려보낼까?”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 전압 크기, 광펄스 세기, 라디오 주파수 등 **신호**의 물리적 특성을 정의함

- 허브/리피터처럼 "증폭만 하고 아무 판단도 못 하는" 장비가 여기에 속함
</code></pre></div></div>

<ol>
  <li>데이터링크 계층</li>
</ol>

<p>“같은 네트워크(브로드캐스트 도메인) 안에서 누가 누구인지 구분하려면?”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **MAC 주소**를 붙여 프레임 단위로 전송하며, CRC로 프레임 오류를 검출함

- 스위치/브리지·VLAN·ARP 캐시 같은 개념이 등장함
</code></pre></div></div>

<ol>
  <li>네트워크 계층</li>
</ol>

<p>“지구 반대편 호스트까지 가려면 중간길(라우팅)을 어떻게 잡지?”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **IP 주소**를 붙이고, 라우터가 최적 경로를 찾아 포워딩함

- ICMP '목적지 도달 불가', OSPF/BGP 등 라우팅 프로토콜이 여기에 있음
</code></pre></div></div>

<ol>
  <li>전송 계층</li>
</ol>

<p>“프로세스 간에 패킷이 유실돼도 재전송하고, 순서도 맞춰야지”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- TCP : 3-Way Handshake, 흐름/혼잡 제어, 세그먼트 재전송

- UDP : 최소한의 헤더로 "빠르지만 책임 안 진다"

- QUIC : HTTP/3가 쓰는 신흥 강자, UDP 위에 신뢰성·TLS 포함
</code></pre></div></div>

<ol>
  <li>세션 계층</li>
</ol>

<p>“논리적인 대화방(세션)을 열고 닫는 관리를 맡자”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 체크포인트·재동기화·다중 스트림 제어 가능

- 실무에선 애매함, OSI만의 전통적인 구분이며, 실제 구현은 주로 응용/전송이 흡수
</code></pre></div></div>

<ol>
  <li>표현 계층</li>
</ol>

<p>“바이트를 사람이 읽을 수 있게/암호화된 형태로 변환하자”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 문자 집합 변환(UTF-8↔EUC-KR), 압축(GZIP), 암복호(TLS) 담당

- 응용계층과 합쳐서 다루는 경우가 많지만, 보안·멀티미디어 코덱 설명 때 유용
</code></pre></div></div>

<ol>
  <li>응용 계층</li>
</ol>

<p>“사용자 프로그램이 원하는 서비스 그 자체”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 웹브라우저-HTTP, 메일-SMTP/IMAP, 파일전송-FTP/SFTP 처럼 **실제 앱 프로토콜**이 자리함

- API 호출(REST/GraphQL)·메신저 프로토콜도 여기서 논의됨
</code></pre></div></div>

<h2 id="왜-tcpip-4계층-모델을-더-많이-쓸까">왜 TCP/IP 4계층 모델을 더 많이 쓸까?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">OSI</th>
      <th style="text-align: center">TCP/IP(실무)</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">7-5</td>
      <td style="text-align: center">응용 계층</td>
      <td style="text-align: center">HTTP·TLS·RPC 등 모두 한 덩어리</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">전송 계층</td>
      <td style="text-align: center">TCP·UDP·QUIC</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">인터넷 계층</td>
      <td style="text-align: center">IP, ICMP 등</td>
    </tr>
    <tr>
      <td style="text-align: center">2-1</td>
      <td style="text-align: center">네트워크 접근 계층</td>
      <td style="text-align: center">Ethernet·Wi-Fi·물리 매체</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p><strong>간소화</strong> : 실제 구현에서는 세션/표현 계층이 따로 분리돼 작동하지 않는 경우가 많아 4단계로 줄임</p>
  </li>
  <li>
    <p><strong>표준화 주체</strong>도 다름. OSI는 ISO(국제표준화기구) 주도, TCP/IP는 IETF(인터넷 엔지니어링 태스크포스)가 주도함</p>
  </li>
</ul>

<h2 id="osi-7계층을-배우는-이유">OSI 7계층을 배우는 이유</h2>

<ol>
  <li>
    <p>문제 진단 : “이건 3계층 문제인가 4계층 문제인가?”를 구분해야 디버깅이 쉬움</p>
  </li>
  <li>
    <p>역할 분리 : “ 새 프로토콜 설계 시 “이 기능은 어느 계층 책임인가?”를 결정하는 기준 세우기가 가능해짐</p>
  </li>
  <li>
    <p>학습 프레임 : 물리 → 응용으로 올라가며 추상화·책임 범위를 체계적으로 이해할 수 있음</p>
  </li>
</ol>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[OSI 7계층(Open Systems Interconnection 7 Layers)은 네트워크 통신 과정을 7단계로 나눈 모델이며, 이 모델은 각 계층마다 맡은 역할이 정해져 있어서, 복잡한 통신 과정을 구조화하고 표준화하는 데 도움이 됩니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">7주차 퀴즈</title><link href="/blog/algorithm/7th-week/" rel="alternate" type="text/html" title="7주차 퀴즈" /><published>2025-04-29T00:00:00+00:00</published><updated>2025-04-29T00:00:00+00:00</updated><id>/blog/algorithm/7th-week</id><content type="html" xml:base="/blog/algorithm/7th-week/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#7주차-퀴즈" id="markdown-toc-7주차-퀴즈">7주차 퀴즈</a>    <ul>
      <li><a href="#페이징과-세그멘테이션의-정의-및-각각의-장단점에-대해-서술하시오-1점" id="markdown-toc-페이징과-세그멘테이션의-정의-및-각각의-장단점에-대해-서술하시오-1점">페이징과 세그멘테이션의 정의 및 각각의 장단점에 대해 서술하시오. (1점)</a></li>
      <li><a href="#first-fit에-대한-예시를-보고-next-fit과-best-fit일-때요청에-대한-메모리-할당-순서를-기록하세요-1점" id="markdown-toc-first-fit에-대한-예시를-보고-next-fit과-best-fit일-때요청에-대한-메모리-할당-순서를-기록하세요-1점">First-fit에 대한 예시를 보고, Next-fit과 Best-fit일 때요청에 대한 메모리 할당 순서를 기록하세요. (1점)</a></li>
      <li><a href="#dma의-기본-개념을-설명하고-dma가-시스템-성능에-미치는-이점을-두-가지-이상-제시하시오-1점" id="markdown-toc-dma의-기본-개념을-설명하고-dma가-시스템-성능에-미치는-이점을-두-가지-이상-제시하시오-1점">DMA의 기본 개념을 설명하고, DMA가 시스템 성능에 미치는 이점을 두 가지 이상 제시하시오. (1점)</a></li>
      <li><a href="#다음-코드의-출력-값을-예측해-보시오-1점" id="markdown-toc-다음-코드의-출력-값을-예측해-보시오-1점">다음 코드의 출력 값을 예측해 보시오. (1점)</a></li>
      <li><a href="#1-2-4-4-3-5-5-6의-입력이-do-it-알고리즘-책-p294의-알고리즘에-주어질-때의-상태를-그리면-됩니다-주어진-입력으로-부터-p294의-1단계를-거치고-나서-부터-그리면-되고-p291의-그림을-그릴-때는-좌측의-힙트리은-그리-않아도-됩니다-배열-상태로-부터-힙은-충분히-그릴-수-있기-때문입니다-2점" id="markdown-toc-1-2-4-4-3-5-5-6의-입력이-do-it-알고리즘-책-p294의-알고리즘에-주어질-때의-상태를-그리면-됩니다-주어진-입력으로-부터-p294의-1단계를-거치고-나서-부터-그리면-되고-p291의-그림을-그릴-때는-좌측의-힙트리은-그리-않아도-됩니다-배열-상태로-부터-힙은-충분히-그릴-수-있기-때문입니다-2점">1 2 4 4 3 5 5 6의 입력이 Do it 알고리즘 책 p.294의 알고리즘에 주어질 때의 상태를 그리면 됩니다. 주어진 입력으로 부터 p.294의 1단계를 거치고 나서 부터 그리면 되고, p.291의 그림을 그릴 때는 좌측의 힙(트리)은 그리 않아도 됩니다. 배열 상태로 부터 힙은 충분히 그릴 수 있기 때문입니다. (2점)</a></li>
    </ul>
  </li>
</ul>

<h2 id="7주차-퀴즈">7주차 퀴즈</h2>

<h3 id="페이징과-세그멘테이션의-정의-및-각각의-장단점에-대해-서술하시오-1점">페이징과 세그멘테이션의 정의 및 각각의 장단점에 대해 서술하시오. (1점)</h3>

<p>세그멘테이션(Segmentation)과 페이징(Paging)은 컴퓨터 메모리 관리 방법입니다.</p>

<p>세그멘테이션 : 이는 메모리를 의미 있는 단위인 ‘세그먼트’로 나누는 방법입니다. 각 세그먼트는 시작 주소와 길이를 가지며, 다른 유형의 데이터(예: 코드, 데이터, 스택)를 위해 사용됩니다. 세그멘테이션은 메모리를 더 유연하게 관리할 수 있게 해주며, 프로그램의 논리적 구조를 반영할 수 있습니다.</p>

<p>페이징 : 페이징은 메모리를 동일한 크기의 블록, 즉 ‘페이지’로 나누는 방법입니다. 각 페이지는 가상 메모리 주소와 매핑되며, 페이지 테이블을 통해 물리적 메모리 주소로 변환됩니다. 페이징은 메모리 관리를 단순화하고, 메모리의 낭비를 줄이며, 프로그램 간의 메모리 충돌을 방지합니다.</p>

<p>장단점 :</p>

<ul>
  <li>
    <p>세그멘테이션</p>

    <ul>
      <li>
        <p>장점 :</p>

        <ul>
          <li>
            <p>메모리를 논리적 단위로 나누어 프로그램의 구조를 반영함.</p>
          </li>
          <li>
            <p>세그먼트별 보호와 공유가 용이함.</p>
          </li>
        </ul>
      </li>
      <li>
        <p>단점 :</p>

        <ul>
          <li>
            <p>외부 단편화 발생 가능성이 있음.</p>
          </li>
          <li>
            <p>메모리 관리가 복잡해질 수 있음.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>페이징</p>

    <ul>
      <li>
        <p>장점 :</p>

        <ul>
          <li>
            <p>외부 단편화 문제를 해결함.</p>
          </li>
          <li>
            <p>메모리 관리가 상대적으로 단순함.</p>
          </li>
        </ul>
      </li>
      <li>
        <p>단점 :</p>

        <ul>
          <li>
            <p>내부 단편화 발생 가능성이 있음.</p>
          </li>
          <li>
            <p>페이지 테이블 관리에 추가적인 메모리가 필요함.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="first-fit에-대한-예시를-보고-next-fit과-best-fit일-때요청에-대한-메모리-할당-순서를-기록하세요-1점">First-fit에 대한 예시를 보고, Next-fit과 Best-fit일 때요청에 대한 메모리 할당 순서를 기록하세요. (1점)</h3>

<p>메모리에는 다음과 같은 블록들이 있으며, 각 블록의 크기는 괄호 안에 표시되어 있습니다.</p>

<p>메모리 블록: A(10), B(50), C(25), D(30), E(40)</p>

<p>다음 순서로 메모리 요청이 들어옵니다.</p>

<p>요청 순서: 1(30), 2(25), 3(25), 4(10)</p>

<p>예) First-fit 
1 - B 
2 - C 
3 - D 
4 - A</p>

<p>Next-Fit 
1 - B 
2 - C 
3 - D 
4 - E</p>

<p>Best-Fit 
1 - D 
2 - C 
3 - E 
4 - A</p>

<h3 id="dma의-기본-개념을-설명하고-dma가-시스템-성능에-미치는-이점을-두-가지-이상-제시하시오-1점">DMA의 기본 개념을 설명하고, DMA가 시스템 성능에 미치는 이점을 두 가지 이상 제시하시오. (1점)</h3>

<p>DMA는 Direct Memory Access의 약자로, CPU의 중재 없이 주변장치가 메모리에 직접 접근하여 데이터를 읽고 쓸 수 있게 해주는 시스템의 한 기능이다. DMA를 사용함으로써, 데이터 전송 과정에서 CPU가 필요하지 않으므로, CPU는 다른 작업을 수행하는 데 더 많은 시간을 할애할 수 있다. 이는 시스템 성능의 향상으로 이어지는데, 특히 I/O 작업이 많은 시스템에서 그 이점이 두드러진다.</p>

<p>첫째, CPU의 부하가 감소하여 전체 시스템의 효율성이 증가한다.</p>

<p>둘째, 데이터 전송 속도가 향상되므로, 전반적인 시스템 응답 시간이 단축된다.</p>

<h3 id="다음-코드의-출력-값을-예측해-보시오-1점">다음 코드의 출력 값을 예측해 보시오. (1점)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> </span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> 
<span class="p">{</span> 
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span> 
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
    <span class="n">p</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> 
     
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>답 : 
8
9</p>

<h3 id="1-2-4-4-3-5-5-6의-입력이-do-it-알고리즘-책-p294의-알고리즘에-주어질-때의-상태를-그리면-됩니다-주어진-입력으로-부터-p294의-1단계를-거치고-나서-부터-그리면-되고-p291의-그림을-그릴-때는-좌측의-힙트리은-그리-않아도-됩니다-배열-상태로-부터-힙은-충분히-그릴-수-있기-때문입니다-2점">1 2 4 4 3 5 5 6의 입력이 Do it 알고리즘 책 p.294의 알고리즘에 주어질 때의 상태를 그리면 됩니다. 주어진 입력으로 부터 p.294의 1단계를 거치고 나서 부터 그리면 되고, p.291의 그림을 그릴 때는 좌측의 힙(트리)은 그리 않아도 됩니다. 배열 상태로 부터 힙은 충분히 그릴 수 있기 때문입니다. (2점)</h3>

<p>처음 :6 4 5 2 3 4 5 1 
‘0’ : 5 4 5 2 3 4 1 6 
‘1’ : 5 4 4 2 3 1 5 6 
‘2’ : 4 3 4 2 1 5 5 6 
‘3’ : 4 3 1 2 4 5 5 6 
‘4’ : 3 2 1 4 4 5 5 6 
‘5’ : 2 1 3 4 4 5 5 6 
‘6’ : 1 2 3 4 4 5 5 6 
final : 1 2 3 4 4 5 5 6</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/Algorithm.png" /><media:content medium="image" url="/assets/img/blog/postimage/Algorithm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Demand-zero memory</title><link href="/blog/computersystem/demand-zero-memory/" rel="alternate" type="text/html" title="Demand-zero memory" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>/blog/computersystem/demand-zero-memory</id><content type="html" xml:base="/blog/computersystem/demand-zero-memory/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#동작-흐름" id="markdown-toc-동작-흐름">동작 흐름</a></li>
  <li><a href="#왜-쓰일까" id="markdown-toc-왜-쓰일까">왜 쓰일까?</a></li>
  <li><a href="#언제-볼-수-있을까" id="markdown-toc-언제-볼-수-있을까">언제 볼 수 있을까?</a></li>
  <li><a href="#요약" id="markdown-toc-요약">요약</a>    <ul>
      <li><a href="#나만의-요약" id="markdown-toc-나만의-요약">나만의 요약</a></li>
    </ul>
  </li>
</ul>

<p><strong>Demand-zero memory(또는 zero-filled-on-demand page)</strong>는 운영체제가 <strong>“필요해질 때(demand)”</strong> 처음 접근되는 순간에만 물리 페이지를 연결하고, 그 페이지의 모든 바이트를 0으로 채워서(zero-fill) 사용자 프로세스에 넘겨주는 메모리 할당 기법</p>

<h2 id="동작-흐름">동작 흐름</h2>

<ol>
  <li>가상 주소 공간만 잡아 두기</li>
</ol>

<ul>
  <li>
    <p>프로그램이 malloc, VirtualAlloc(…, MEM_RESERVE), 스택 확대, BSS(전역/정적 0-초기화 변수) 등으로 “새 메모리를” 요구하면,</p>
  </li>
  <li>
    <p>커널은 대응되는 물리 페이지 없이 가상 주소 범위를 예약해 두고, PTE(Page-Table Entry)에 “아직 물리 페이지 없음, demand-zero”라는 플래그를 세워 둠</p>
  </li>
</ul>

<ol>
  <li>첫 접근 → 페이지 폴트(page fault)</li>
</ol>

<ul>
  <li>CPU가 그 주소를 읽거나 쓰려고 하면 PTE에 실제 프레임이 없으므로 페이지 폴트가 발생</li>
</ul>

<ol>
  <li>커널이 물리 페이지 할당 &amp; 0으로 초기화</li>
</ol>

<ul>
  <li>
    <p>커널의 Zero Page List에서 이미 0으로 클리어돼 있는 여유 페이지를 하나 꺼내오거나,</p>
  </li>
  <li>
    <p>여유 페이지가 없다면 새 페이지를 확보한 뒤 memset(page, 0, PAGE_SIZE)로 0-필(fill) 한다</p>
  </li>
</ul>

<ol>
  <li>PTE 갱신 후 재시도</li>
</ol>

<ul>
  <li>PTE를 “valid + 해당 물리 프레임”으로 고쳐 놓고, fault 된 명령을 재실행하면 이제 정상적으로 0값이 보임</li>
</ul>

<h2 id="왜-쓰일까">왜 쓰일까?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">장점</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">메모리 절약</td>
      <td style="text-align: center">큰 배열/구조체를 “0으로 초기화”해 예약만 해 놓고, 실제로 접근한 부분만 물리 메모리를 소비함</td>
    </tr>
    <tr>
      <td style="text-align: center">보안 &amp; 안정성</td>
      <td style="text-align: center">항상 0으로 채워 주므로, 이전 프로세스의 잔류 데이터가 노출되지 않음</td>
    </tr>
    <tr>
      <td style="text-align: center">속도(평균)</td>
      <td style="text-align: center">초기화 루프를 사용자 코드에서 돌릴 필요가 없고, 커널은 미리 0-클리어 해 둔 zero-page 풀을 재사용해 페이지 폴트 처리 시간을 최소화함</td>
    </tr>
  </tbody>
</table>

<h2 id="언제-볼-수-있을까">언제 볼 수 있을까?</h2>

<ul>
  <li>
    <p>Windows - MEM_COMMIT 없이 VirtualAlloc으로 예약만 한 뒤 접근할 때, 또는 일반 HeapAlloc/new 내부적으로</p>
  </li>
  <li>
    <p>Linux/Unix - 익명 매핑 mmap(…, MAP_ANONYMOUS)·스택·BSS·brk/sbrk 등</p>
  </li>
  <li>
    <p>하이퍼바이저/가상머신 - 게스트가 처음 쓰는 시점까지 진짜 호스트 RAM을 배정하지 않는 ballooning 기법과 결합되기도 함</p>
  </li>
</ul>

<h2 id="요약">요약</h2>

<p>Demand-zero memory = “필요할 때 0으로 초기화된 물리 페이지를 뒤늦게 붙이는 가상 메모리 기술”</p>

<p>→ 프로그램 입장에서는 ‘이미 0으로 초기화돼 있는 새 메모리’를 즉시 얻은 것처럼 보이지만, 실제 RAM은 첫 사용 시점까지 쓰이지 않아 메모리를 아끼고 보안을 높여 줌</p>

<h3 id="나만의-요약">나만의 요약</h3>

<ol>
  <li>
    <p>물리 메모리 같은 경우 첫 사용 전까지는 메모리 할당이 되지 않음</p>
  </li>
  <li>
    <p>하지만 가상 메모리에서는 공간이 확보된 상태</p>
  </li>
  <li>
    <p>실제 사용시에는 page fault 되면서 물리 메모리 할당이 이루어짐, PTE의 Not-present → Present로 갱신</p>
  </li>
</ol>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[Demand-zero memory(또는 zero-filled-on-demand page)는 운영체제가 “필요해질 때(demand)” 처음 접근되는 순간에만 물리 페이지를 연결하고, 그 페이지의 모든 바이트를 0으로 채워서(zero-fill) 사용자 프로세스에 넘겨주는 메모리 할당 기법이다]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Direct Memory Access</title><link href="/blog/computersystem/dma/" rel="alternate" type="text/html" title="Direct Memory Access" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>/blog/computersystem/dma</id><content type="html" xml:base="/blog/computersystem/dma/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#dmadirect-memory-access란" id="markdown-toc-dmadirect-memory-access란">DMA(Direct Memory Access)란?</a></li>
  <li><a href="#왜-dma가-필요한가" id="markdown-toc-왜-dma가-필요한가">왜 DMA가 필요한가?</a></li>
  <li><a href="#기본-구성-요소" id="markdown-toc-기본-구성-요소">기본 구성 요소</a>    <ul>
      <li><a href="#dma-레지스터-src-dst-len" id="markdown-toc-dma-레지스터-src-dst-len">DMA 레지스터 SRC, DST, LEN</a></li>
    </ul>
  </li>
  <li><a href="#동작-흐름-x86-pc-예시" id="markdown-toc-동작-흐름-x86-pc-예시">동작 흐름 (x86 PC 예시)</a>    <ul>
      <li><a href="#동작-흐름-더-자세히" id="markdown-toc-동작-흐름-더-자세히">동작 흐름 더 자세히</a>        <ul>
          <li><a href="#1-단계---cpu까-준비만-하고-손을-뗀다" id="markdown-toc-1-단계---cpu까-준비만-하고-손을-뗀다">1 단계 - CPU까 준비만 하고 손을 뗀다</a></li>
          <li><a href="#2-단계---버스-소유권-교환" id="markdown-toc-2-단계---버스-소유권-교환">2 단계 - 버스 소유권 교환</a></li>
          <li><a href="#3-단계---실제-데이터-이동" id="markdown-toc-3-단계---실제-데이터-이동">3 단계 - 실제 데이터 이동</a></li>
          <li><a href="#4-단계---전송-완료-알림" id="markdown-toc-4-단계---전송-완료-알림">4 단계 - 전송 완료 알림</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#전송-모드" id="markdown-toc-전송-모드">전송 모드</a></li>
  <li><a href="#현대-시스템에서의-dma-변화" id="markdown-toc-현대-시스템에서의-dma-변화">현대 시스템에서의 DMA 변화</a></li>
  <li><a href="#장점과-단점-요약" id="markdown-toc-장점과-단점-요약">장점과 단점 요약</a></li>
  <li><a href="#실무-예시" id="markdown-toc-실무-예시">실무 예시</a></li>
  <li><a href="#운영체제-관점" id="markdown-toc-운영체제-관점">운영체제 관점</a></li>
</ul>

<h2 id="dmadirect-memory-access란">DMA(Direct Memory Access)란?</h2>

<p>DMA는 CPU를 거치지 않고 I/O 장치가 주 메모리(RAM)에 직접 읽기·쓰기 할 수 있도록 시스템 버스를 “잠깐” 빌려서 데이터 블록을 전송하는 하드웨어 메커니즘</p>

<h2 id="왜-dma가-필요한가">왜 DMA가 필요한가?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">문제점(전통적 PIO)</th>
      <th style="text-align: center">DMA가 주는 이점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">CPU가 I/O 레지스터를 통해 바이트 단위로 데이터를 옮기면 레이턴시·오버헤드가 큼</td>
      <td style="text-align: center">한 번에 수십~수천 바이트 블록을 메모리로 직행 ⇒ CPU cycles 절약</td>
    </tr>
    <tr>
      <td style="text-align: center">빠른 장치(SSD, 10 GbE NIC 등)는 CPU 속도보다 I/O 대역폭이 큼 → CPU가 “목”이 됨</td>
      <td style="text-align: center">DMA 엔진이 버스 마스터로 동작해 메모리 버스를 직접 차단·사용</td>
    </tr>
    <tr>
      <td style="text-align: center">멀티코어 시대에 CPU는 계산에 집중하고 싶음</td>
      <td style="text-align: center">CPU는 전송 시작/종료만 관리 → I/O wait 시간 줄고, 캐시 miss도 감소</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>덕분에 대역폭·지연시간 모두 절감, 특히 디스크 I/O, 네트워크 카드, 오디오 스트리밍처럼 폭이 넓고 반복적인 전송에 필수적이다</li>
</ul>

<h2 id="기본-구성-요소">기본 구성 요소</h2>

<ol>
  <li>
    <p>DMA 컨트롤러(DMAC)</p>

    <ul>
      <li>
        <p>전용 칩(고전 ISA-DMA) 또는 주변장치 내부 DMA 엔진(PCIe, NVMe 컨트롤러)</p>
      </li>
      <li>
        <p>소스/목적지 물리 주소, 전송 길이, 모드, 제어 플래그 등을 저장하는 레지스터(메모리 맵 레지스터) 보유</p>
      </li>
      <li>
        <p>여러 채널이 있으면 동시에 여러 장치 지원</p>
      </li>
    </ul>
  </li>
  <li>
    <p>시스템 버스</p>

    <ul>
      <li>
        <p>CPU ↔ 메모리 ↔ DMA 컨트롤러가 공유</p>
      </li>
      <li>
        <p>CPU와 DMAC가 동시에 쓰지 않도록 <strong>버스 중재(bus arbitration)</strong> 를 수행</p>
      </li>
    </ul>
  </li>
  <li>
    <p>메모리 버스</p>

    <ul>
      <li>DMAC가 버스 마스터(master) 권한을 요청(Bus Request, BR) → 메모리와 직접 주고받음</li>
    </ul>
  </li>
  <li>
    <p>주변장치(Device)</p>

    <ul>
      <li>디스크, NIC, GPU, 오디오 코드 … 데이터가 실제로 존재/필요한 곳</li>
    </ul>
  </li>
  <li>
    <p>CPU &amp; OS</p>

    <ul>
      <li>전송 파라미터를 DMAC 레지스터에 써 주고, 완료 인터럽트(DMA done)를 처리</li>
    </ul>
  </li>
  <li>
    <p>I/O 장치(버스 마스터 가능 장치)</p>

    <ul>
      <li>PCIe NIC, NVMe SSD, GPU 등은 자체 DMA 엔진을 내장해 버스 마스터 가 되기도 한다</li>
    </ul>
  </li>
</ol>

<h3 id="dma-레지스터-src-dst-len">DMA 레지스터 SRC, DST, LEN</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">레지스터</th>
      <th style="text-align: center">역할</th>
      <th style="text-align: center">일반적 크기</th>
      <th style="text-align: center">세부 사항</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">SRC (Source Address)</td>
      <td style="text-align: center">읽어 올 원본 주소. 장치 → RAM 전송이면 장치 쪽 FIFO 주소, RAM → 장치 전송이면 RAM의 시작 주소</td>
      <td style="text-align: center">32 bit(SoC) 또는 64 bit(서버)</td>
      <td style="text-align: center">* 버스트·비버스트 여부, 버스트 길이에 따라 자동 증가(inc) 여부 선택 플래그 존재<br />* Scatter-Gather 모드에선 “다음 표(list) 항목” 주소로 해석되기도 함</td>
    </tr>
    <tr>
      <td style="text-align: center">DST (Destination Address)</td>
      <td style="text-align: center">쓰기 대상 주소</td>
      <td style="text-align: center">32/64 bit</td>
      <td style="text-align: center">* 자동 증가/고정 선택 가능 (예: 오디오 DAC 같은 스트리밍 장치는 고정 주소, 메모리 버퍼는 증가)</td>
    </tr>
    <tr>
      <td style="text-align: center">LEN (Length / Count)</td>
      <td style="text-align: center">총 바이트(혹은 워드) 수</td>
      <td style="text-align: center">16 bit(65 kB) ~ 32 bit(4 GB) 이상</td>
      <td style="text-align: center">* 전송이 끝날 때마다 LEN–; 0 → 인터럽트 발생<br />* 어떤 컨트롤러는 LEN 대신 COUNT×DATA_WIDTH 형태 사용</td>
    </tr>
  </tbody>
</table>

<p><strong>요약</strong> : SRC·DST는 “어디서 → 어디로”를, LEN은 “얼마나”를 알려주는 좌표 + 거리 정보라고 생각하면 된다</p>

<h2 id="동작-흐름-x86-pc-예시">동작 흐름 (x86 PC 예시)</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">신호선 &amp; 동작</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">① CPU 설정</td>
      <td style="text-align: center">DMAC 레지스터에 &lt;소스, 목적지, 길이, 모드&gt; 기록 후 Bus Request(BR) 활성화</td>
    </tr>
    <tr>
      <td style="text-align: center">② 버스 획득</td>
      <td style="text-align: center">CPU가 <em>Bus Grant(BG)</em>로 응답 → CPU 파이프라인이 버스를 놓고 다른 연산(레지스터 계산 등) 수행</td>
    </tr>
    <tr>
      <td style="text-align: center">③ 데이터 전송</td>
      <td style="text-align: center">DMAC가 메모리 ↔ 장치 간 버스 싸이클 생성</td>
    </tr>
    <tr>
      <td style="text-align: center">④ 완료 인터럽트</td>
      <td style="text-align: center">전송 길이가 0이 되면 DMAC가 CPU에 DMA 완료 인터럽트. CPU는 이후 버스 재획득</td>
    </tr>
  </tbody>
</table>

<p><strong>중요</strong> : DMAC가 버스를 잡은 동안 메모리 전체 버스 주도권을 갖기 때문에 CPU는 RAM을 전혀 접근하지 못한다. 개별 “주소 권한”이 아닌 “버스 소유권”의 문제다. 이 때문에 짝수 클럭마다 한 워드만 빼앗고 바로 돌려주는 Cycle Stealing 모드가 등장했다</p>

<h3 id="동작-흐름-더-자세히">동작 흐름 더 자세히</h3>

<p><img src="/assets/img/blog/computerscience/dma.png" alt="DMA" /></p>

<h4 id="1-단계---cpu까-준비만-하고-손을-뗀다">1 단계 - CPU까 준비만 하고 손을 뗀다</h4>

<ol>
  <li>
    <p>전송 파라미터 설정</p>

    <ul>
      <li>
        <p>SRC, DST, LEN, MODE을 레지스터에 값을 써 넣습니다</p>
      </li>
      <li>
        <p>마지막으로 Enable 플래그를 1로 두면 DMAC가 “이제 내가 처리할게!”하고 대기</p>
      </li>
    </ul>
  </li>
  <li>
    <p>버스 요청(BR 신호)</p>

    <ul>
      <li>DMAC는 버스 중재기(arbiter)에게 “버스 좀 빌려주세요” 라고 손을 듦</li>
    </ul>
  </li>
</ol>

<h4 id="2-단계---버스-소유권-교환">2 단계 - 버스 소유권 교환</h4>

<ol>
  <li>
    <p>CPU → DMAC ‘Bus Grant(BG)’</p>

    <ul>
      <li>
        <p>CPU가 진행 중인 버스 싸이클을 마치면 주소·데이터 라인을 tristate해 두고 계산 같은 비-버스 작업에 집중함</p>

        <ul>
          <li>
            <p>tristate란, 여러개의 마스터(CPU, DMAC, GPU…)가 하나의 전선을 공유하고, 한 쪽이 0V, 다른쪽이 동시에 Vcc를 내보내면 단락(short) 위험을 방지하고자 버스를 넘겨받은 쪽만 드라이버를 켜고 나머지는 Hi-Z로 물러나야 함</p>
          </li>
          <li>
            <p>버스가 필요 없는 작업이란, 파이프라인이 레지스터와 내부 캐시 만으로 실행 가능한 명령들</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>DMAC가 버스 장악</p>

    <ul>
      <li>
        <p>이 순간부터 RAM과 I/O 장치 사이를 오가는 모든 신호는 DMAC가 생성</p>
      </li>
      <li>
        <p>CPU는 RAM을 못 만지기 때문에 캐시 miss가 나도 대기해야 함</p>
      </li>
    </ul>
  </li>
</ol>

<h4 id="3-단계---실제-데이터-이동">3 단계 - 실제 데이터 이동</h4>

<ol>
  <li>
    <p>전송 모드에 따른 사이클</p>

    <ul>
      <li>
        <p>Burst/Block : LEN만큼 연속으로 → 최고속, 대신 CPU 길게 정지</p>
      </li>
      <li>
        <p>Cycle-Stealing : 한 사이클씩 “훔치고” 바로 돌려줌 → 실시간 오디어/비디오</p>
      </li>
      <li>
        <p>Scatter-Gather : 메모리 리스트 따라 다중 블록 자동 전송 → NVMe·NIC</p>
      </li>
    </ul>
  </li>
  <li>
    <p>주소·카운터 자동 증가</p>

    <ul>
      <li>DMAC 내부 카운터가 0이 될 때까지 SRC++, DST++, LEN–</li>
    </ul>
  </li>
</ol>

<h4 id="4-단계---전송-완료-알림">4 단계 - 전송 완료 알림</h4>

<ol>
  <li>
    <p>DMA 완료 인터럽트</p>

    <ul>
      <li>
        <p>LEN==0 → DMAC가 IRQ를 날리고 버스 요청을 내림</p>
      </li>
      <li>
        <p>CPU는 인터럽트 핸들러에서 데이터 후처리(예: 패킷 파싱, 디스크 블록 체크섬) 수행</p>
      </li>
    </ul>
  </li>
  <li>
    <p>버스 복귀</p>

    <ul>
      <li>Arbiter가 다시 CPU에 ‘Bus Grant’ → 평상시 메모리 접근 재개</li>
    </ul>
  </li>
</ol>

<h2 id="전송-모드">전송 모드</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">모드</th>
      <th style="text-align: center">특징</th>
      <th style="text-align: center">사용 예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Cycle-Stealing</td>
      <td style="text-align: center">버스 싸이클 1 개만 “훔친” 뒤 즉시 CPU에 반환 → CPU 지연 최소</td>
      <td style="text-align: center">실시간 오디오, 비디오 스트림</td>
    </tr>
    <tr>
      <td style="text-align: center">Block/Burst</td>
      <td style="text-align: center">전체 블록(혹은 버스트) 한 번에 전송 → 가장 빠르지만 CPU 길게 정지</td>
      <td style="text-align: center">SATA, SDIO, 대부분의 PCIe 장치</td>
    </tr>
    <tr>
      <td style="text-align: center">Demand/Scatter-Gather</td>
      <td style="text-align: center">장치가 필요할 때마다, 혹은 메모리 리스트 기반 다중 블록 이동</td>
      <td style="text-align: center">고성능 NIC, NVMe SSD, GPU VRAM 업로드</td>
    </tr>
  </tbody>
</table>

<h2 id="현대-시스템에서의-dma-변화">현대 시스템에서의 DMA 변화</h2>

<ol>
  <li>
    <p>PCIe Bus mastering - 주변장치가 메인 메모리를 완전히 “빌려” 직접 읽고/쓴다</p>
  </li>
  <li>
    <p>IOMMU(DMA-Remapping) - 가상화·보안 목적. 장치가 접근 가능한 주소를 OS가 테이블로 전환 → 버퍼 오염·DMA 공격 방어</p>
  </li>
  <li>
    <p>Cache coherency 문제 - CPU 캐시에 남은 더러운(line dirty) 데이터 vs DMA가 본 메모리 불일치. 해결 : dma_sync_*() - (Linux)·Cache flush, non-cacheable region, snoopint 버스.</p>
  </li>
  <li>
    <p>Zero-copy - 네트워크 스택이나 GPU ↔ CPU 사이에서 “복사 없는” 파이프라인 구축 (DPDK, RDMA, CUDA cudaMemcpyAsync 등)</p>

    <ul>
      <li>운영체제 버퍼를 추가로 “복사(copy)”하지 않고, 장치 ↔ 응용이 같은 메모리 페이지를 공유하도록 하는 기법. CPU가 불필요한 memcpy()를 안 하므로 지연과 캐시오염↓</li>
    </ul>
  </li>
  <li>
    <p>RDMA(Remode DMA) - NIC가 원격 호스트의 메모리에까지 DMA 쓰기/읽기를 수행. 커널 네트워크 스택을 우회하여 μs 단위 지연시간을 제공한다. 고속 HPC, 데이터베이스 복제에서 필수</p>
  </li>
</ol>

<h2 id="장점과-단점-요약">장점과 단점 요약</h2>

<p><strong>장점</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- CPU 사용률 감소, 전력 효율 ↑

- 대역폭 활용 극대화(PCIe Gen4 x4 ≈ 8 GB/s 급)

- 실시간 스트리밍 지원(오디오 스터터링 방지 등)
</code></pre></div></div>

<p><strong>단점</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 하드웨어·드라이버 복잡도 증가

- 버스 우선순위 조정 실패 시 CPU 지연 가능

- 캐시 일관성, 보안("DMA 공격") 이슈 처리 필요

    - IOMMU로 보완
</code></pre></div></div>

<h2 id="실무-예시">실무 예시</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">장치</th>
      <th style="text-align: center">DMA 활용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">SSD/NVMe</td>
      <td style="text-align: center">플래시 컨트롤러가 OS 버퍼를 읽어 와 NAND로 쓰기, 반대 방향 읽기</td>
    </tr>
    <tr>
      <td style="text-align: center">10 GbE NIC</td>
      <td style="text-align: center">패킷을 커널 버퍼나 XSP ring으로 직접 놓고, 완료 시 인터럽트</td>
    </tr>
    <tr>
      <td style="text-align: center">GPU</td>
      <td style="text-align: center">대용량 텍스처/버퍼를 PCIe로 복사하거나, VRAM↔CPU RAM pinned transfer</td>
    </tr>
    <tr>
      <td style="text-align: center">Audio Codec</td>
      <td style="text-align: center">PCM 버퍼를 주기적으로 DMA → DAC, 실시간 재생</td>
    </tr>
    <tr>
      <td style="text-align: center">USB 컨트롤러</td>
      <td style="text-align: center">호스트 메모리의 전송 링(Transfer Ring)을 DMA 로 순회</td>
    </tr>
  </tbody>
</table>

<h2 id="운영체제-관점">운영체제 관점</h2>

<ul>
  <li>
    <p>Linux : dma_map_single(), dma_alloc_coherent(), struct dma_async_tx_descriptor, DMAengine 프레임워크</p>
  </li>
  <li>
    <p>Windows : WdfDmaTransaction*, KeFlushIoBuffers(), Scatter/Gather 목록 지원</p>
  </li>
  <li>
    <p>RTOS(FreeRTOS, Zephyr) : MCU마다 별도의 DMAMUX &amp; HAP API 제공</p>
  </li>
</ul>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[여태까지 컴퓨터는 직접 메모리에 대해 접근하지 않고 가상 메모리를 사용하는 것으로 배웠는데, 만약 직접 메모리 접근이 있다면?]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">System Call</title><link href="/blog/computersystem/system-call/" rel="alternate" type="text/html" title="System Call" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>/blog/computersystem/system-call</id><content type="html" xml:base="/blog/computersystem/system-call/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#호출-흐름리눅스-x86-64-예" id="markdown-toc-호출-흐름리눅스-x86-64-예">호출 흐름(리눅스 x86-64 예)</a></li>
  <li><a href="#대표-범주" id="markdown-toc-대표-범주">대표 범주</a></li>
  <li><a href="#언제-볼-수-있을까" id="markdown-toc-언제-볼-수-있을까">언제 볼 수 있을까?</a></li>
  <li><a href="#요약" id="markdown-toc-요약">요약</a>    <ul>
      <li><a href="#나만의-요약" id="markdown-toc-나만의-요약">나만의 요약</a></li>
    </ul>
  </li>
</ul>

<p>응용 프로그램(유저 레벨 코드)이 직접 하드웨어를 만지면 안 되므로, 운영체제(OS)가 대신 해준다. 프로세스가 커널에게 무언가를 “요청”하는 공식 통로가 바로 <strong>System Call</strong>이다.</p>

<ul>
  <li>
    <p>“파일을 열어 줘(open)”, “데이터를 읽어 줘(read)”, “새 프로세스를 만들어 줘(fork)” … 같은 요구 사항을 전달한다</p>
  </li>
  <li>
    <p>커널은 트랩(trap)을 통해 특권 모드(커널 모드)로 올라가 작업을 수행한 뒤, 결과(보통 레지스터 값 또는 errno)를 돌려주고 사용자 모드로 복귀한다</p>
  </li>
</ul>

<h2 id="호출-흐름리눅스-x86-64-예">호출 흐름(리눅스 x86-64 예)</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: left">사용자 공간</th>
      <th style="text-align: left">커널 공간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: left">라이브러리 wrapper 함수 (read(int fd, void *buf, size_t n))</td>
      <td style="text-align: left">-</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: left">시스템 콜 번호와 인수들을 레지스터에 적재하고 syscall(또는 int 0x80) 실행</td>
      <td style="text-align: left">트랩 발생→권한 레벨 전환, 커널 스택 진입</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: left">시스템 콜 디스패처가 번호를 해석해 해당 핸들러(sys_read) 호출</td>
      <td style="text-align: left">핸들러가 실제 I/O 수행, 파일 테이블 등 갱신</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: left">반환값을 레지스터에 넣고 sysret</td>
      <td style="text-align: left">-</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: left">라이브러리 wrapper가 음수면 errno 설정 후 반환</td>
      <td style="text-align: left">-</td>
    </tr>
  </tbody>
</table>

<p>여기서 <strong>컨텍스트 스위치(레지스터·프로그램 카운터·스택 교체)</strong>는 수십 ~ 수백 나노초가 소요되므로, 시스템 콜은 함수 호출보다 느리다</p>

<h2 id="대표-범주">대표 범주</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">범주</th>
      <th style="text-align: left">대표 시스템 콜</th>
      <th style="text-align: left">설명·용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">프로세스 제어</td>
      <td style="text-align: left">fork, execve, waitpid, exit</td>
      <td style="text-align: left">프로세스 생성·변경·종료</td>
    </tr>
    <tr>
      <td style="text-align: center">파일 I/O</td>
      <td style="text-align: left">open/close, read/write, lseek, stat</td>
      <td style="text-align: left">모든 디스크·파이프·소켓 I/O 통일 인터페이스(“Everything is a file”)</td>
    </tr>
    <tr>
      <td style="text-align: center">장치 제어</td>
      <td style="text-align: left">ioctl, mmap, munmap</td>
      <td style="text-align: left">특수 장치 제어, 파일 매핑 등</td>
    </tr>
    <tr>
      <td style="text-align: center">메모리 관리</td>
      <td style="text-align: left">brk, mmap</td>
      <td style="text-align: left">힙 확장(malloc 내부)</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: left">라이브러리 wrapper가 음수면 errno 설정 후 반환</td>
      <td style="text-align: left">-</td>
    </tr>
  </tbody>
</table>

<h2 id="언제-볼-수-있을까">언제 볼 수 있을까?</h2>

<ul>
  <li>
    <p>Windows - MEM_COMMIT 없이 VirtualAlloc으로 예약만 한 뒤 접근할 때, 또는 일반 HeapAlloc/new 내부적으로</p>
  </li>
  <li>
    <p>Linux/Unix - 익명 매핑 mmap(…, MAP_ANONYMOUS)·스택·BSS·brk/sbrk 등</p>
  </li>
  <li>
    <p>하이퍼바이저/가상머신 - 게스트가 처음 쓰는 시점까지 진짜 호스트 RAM을 배정하지 않는 ballooning 기법과 결합되기도 함</p>
  </li>
</ul>

<h2 id="요약">요약</h2>

<p>Demand-zero memory = “필요할 때 0으로 초기화된 물리 페이지를 뒤늦게 붙이는 가상 메모리 기술”</p>

<p>→ 프로그램 입장에서는 ‘이미 0으로 초기화돼 있는 새 메모리’를 즉시 얻은 것처럼 보이지만, 실제 RAM은 첫 사용 시점까지 쓰이지 않아 메모리를 아끼고 보안을 높여 줌</p>

<h3 id="나만의-요약">나만의 요약</h3>

<ol>
  <li>
    <p>물리 메모리 같은 경우 첫 사용 전까지는 메모리 할당이 되지 않음</p>
  </li>
  <li>
    <p>하지만 가상 메모리에서는 공간이 확보된 상태</p>
  </li>
  <li>
    <p>실제 사용시에는 page fault 되면서 물리 메모리 할당이 이루어짐, PTE의 Not-present → Present로 갱신</p>
  </li>
</ol>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[응용프로그램(User level code)이 Hardware를 조작하고 싶을때, 무엇을 할까?]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>