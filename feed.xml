<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-05-12T15:00:08+00:00</updated><id>/feed.xml</id><title type="html">PurifiedPotion’s Blog</title><subtitle>A blog for computer science
</subtitle><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><entry><title type="html">동기화 기법 3대장 : Lock/Semaphore/Condition Variable</title><link href="/blog/computersystem/lock-semaphore-condition/" rel="alternate" type="text/html" title="동기화 기법 3대장 : Lock/Semaphore/Condition Variable" /><published>2025-05-12T00:00:00+00:00</published><updated>2025-05-12T00:00:00+00:00</updated><id>/blog/computersystem/lock-semaphore-condition</id><content type="html" xml:base="/blog/computersystem/lock-semaphore-condition/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#동기화synchronization란" id="markdown-toc-동기화synchronization란">동기화(Synchronization)란?</a></li>
  <li><a href="#왜-동기화가-필요할까" id="markdown-toc-왜-동기화가-필요할까">왜 동기화가 필요할까?</a>    <ul>
      <li><a href="#동기화가-없으면-생기는-문제" id="markdown-toc-동기화가-없으면-생기는-문제">동기화가 없으면 생기는 문제</a></li>
    </ul>
  </li>
  <li><a href="#동기화의-목적" id="markdown-toc-동기화의-목적">동기화의 목적</a></li>
  <li><a href="#동기화하는-방법들-기술" id="markdown-toc-동기화하는-방법들-기술">동기화하는 방법들 (기술)</a>    <ul>
      <li><a href="#lock뮤텍스-포함" id="markdown-toc-lock뮤텍스-포함">Lock(뮤텍스 포함)</a></li>
      <li><a href="#semaphore" id="markdown-toc-semaphore">Semaphore</a></li>
      <li><a href="#condition-variable-조건-변수" id="markdown-toc-condition-variable-조건-변수">Condition Variable (조건 변수)</a></li>
    </ul>
  </li>
</ul>

<h2 id="동기화synchronization란">동기화(Synchronization)란?</h2>

<p>동기화란, 여러 개의 스레드나 프로세스가 “공유 자원”을 사용할 때, 충돌이나 오류 없이 올바르게 작동하도록 순서를 맞춰주는 기술이다.</p>

<h2 id="왜-동기화가-필요할까">왜 동기화가 필요할까?</h2>

<p>여러 스레드/프로세스가 동시에 :</p>

<ul>
  <li>
    <p>같은 메모리,</p>
  </li>
  <li>
    <p>같은 파일,</p>
  </li>
  <li>
    <p>같은 네트워크 리소스를</p>
  </li>
  <li>
    <p>아무 조정 없이 건드리면,</p>
  </li>
</ul>

<p><strong>문제</strong>가 터진다!</p>

<blockquote>
  <p>값이 꼬인다(데이터 레이스)
프로그램이 이상하게 동작한다(논리 오류)
심지어 프로그램이 죽을 수도 있다(crash)</p>
</blockquote>

<h3 id="동기화가-없으면-생기는-문제">동기화가 없으면 생기는 문제</h3>

<p><strong>1. 데이터 레이스(Data Race)</strong></p>

<blockquote>
  <p>두 스레드가 동시에 같은 데이터를 읽고 수정해서 예상 못 한 값이 생기는 문제.</p>
</blockquote>

<p>예시 :</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// counter를 1000번 증가시키는 코드</span>
<span class="n">counter</span><span class="o">++</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>A 스레드가 <code class="language-plaintext highlighter-rouge">counter</code>를 읽고,</p>
  </li>
  <li>
    <p>B 스레드가 거의 동시에 <code class="language-plaintext highlighter-rouge">counter</code>를 읽으면,</p>
  </li>
  <li>
    <p>둘 다 <code class="language-plaintext highlighter-rouge">counter = 5</code>를 봤고;</p>
  </li>
  <li>
    <p>둘 다 <code class="language-plaintext highlighter-rouge">counter = 6</code>을 저장해버린다.</p>
  </li>
  <li>
    <p>→ 사실은 두 번 증가해야 하는데, 한 번만 증가한 꼴이 됨!</p>
  </li>
</ul>

<p>(동시에 수정하면 제대로 합쳐지지 않아)</p>

<p><strong>2. 교착상태(Deadlock)</strong></p>

<blockquote>
  <p>서로 Lock을 잡고 영원히 기다리는 상황.</p>
</blockquote>

<p>예시 :</p>

<ul>
  <li>
    <p>A는 프린터 락을 잡고 스캐너 락을 기다림.</p>
  </li>
  <li>
    <p>B는 스캐너 락을 잡고 프린터 락을 기다림.</p>
  </li>
  <li>
    <p>둘 다 서로 기다리다 아무것도 못하고 멈춤.</p>
  </li>
</ul>

<p><strong>3. 기아(Starvation)</strong></p>

<blockquote>
  <p>어떤 스레드가 계속 자원을 못 받아서 굶는 문제.</p>
</blockquote>

<ul>
  <li>
    <p>높은 우선순위 스레드가 계속 차지하면</p>
  </li>
  <li>
    <p>낮은 우선순위 스레드는 기회 자체를 못 얻는다.</p>
  </li>
</ul>

<h2 id="동기화의-목적">동기화의 목적</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">목표</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">일관성 유지</td>
      <td style="text-align: center">데이터가 꼬이지 않게 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">공정성 보장</td>
      <td style="text-align: center">모든 스레드가 자원을 쓸 기회를 갖는다.</td>
    </tr>
    <tr>
      <td style="text-align: center">교착상태 방지</td>
      <td style="text-align: center">스레드들이 서로 영원히 기다리지 않게 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">효율적인 협력</td>
      <td style="text-align: center">여러 스레드가 협력해서 작업할 수 있게 한다.</td>
    </tr>
  </tbody>
</table>

<h2 id="동기화하는-방법들-기술">동기화하는 방법들 (기술)</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">기술</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Lock/Mutex</td>
      <td style="text-align: center">임계 구역 보호 (하나만 들어가게)</td>
    </tr>
    <tr>
      <td style="text-align: center">Semaphore</td>
      <td style="text-align: center">자원의 개수 관리 (여러 개도 가능)</td>
    </tr>
    <tr>
      <td style="text-align: center">Condition Variable</td>
      <td style="text-align: center">어떤 조건이 충족될 때까지 대기/깨우기</td>
    </tr>
    <tr>
      <td style="text-align: center">Monitor</td>
      <td style="text-align: center">Lock + Condition을 합친 고급 동기화 추상화</td>
    </tr>
    <tr>
      <td style="text-align: center">Barrier</td>
      <td style="text-align: center">여러 스레드가 한 지점에서 다 모일 때까지 기다리기</td>
    </tr>
  </tbody>
</table>

<p>이 글에서는 Lock, Semaphore, Condition Variable에 대해서 다룰거야</p>

<h3 id="lock뮤텍스-포함">Lock(뮤텍스 포함)</h3>

<p><strong>개념</strong></p>

<ul>
  <li>
    <p>Critical Section(공유 자원을 접근하는 코드 블록)을 한 번에 하나만 실행하도록 막는 기법.</p>
  </li>
  <li>
    <p>보통 뮤텍스(Mutex)를 통해 구현.</p>
  </li>
</ul>

<p><strong>특징</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">기본 기능</td>
      <td style="text-align: center">진입 시 lock, 작업 후 unlock</td>
    </tr>
    <tr>
      <td style="text-align: center">기본 상태</td>
      <td style="text-align: center">잠금(Locked) / 잠금 해제(Unlocked)</td>
    </tr>
    <tr>
      <td style="text-align: center">소유권</td>
      <td style="text-align: center">있음(lock한 스레드만 unlock할 수 있음)</td>
    </tr>
    <tr>
      <td style="text-align: center">주 용도</td>
      <td style="text-align: center">공유 데이터 보호, 임계 구역 보호</td>
    </tr>
  </tbody>
</table>

<p><strong>간단 예제</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="c1">// critical section (공유 데이터 접근)</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="semaphore">Semaphore</h3>

<p><strong>개념</strong></p>

<ul>
  <li>“자원의 개수”를 세는 정수 변수를 관리해서, 자원 접근을 조율하는 동기화 도구.</li>
</ul>

<p><strong>특징</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">기본 기능</td>
      <td style="text-align: center">wait(P) : 자원 요청, signal(V) : 자원 반환</td>
    </tr>
    <tr>
      <td style="text-align: center">기본 상태</td>
      <td style="text-align: center">0 이상 정수</td>
    </tr>
    <tr>
      <td style="text-align: center">소유권</td>
      <td style="text-align: center">없음 (누구나 wait, signal 호출 가능)</td>
    </tr>
    <tr>
      <td style="text-align: center">주 용도</td>
      <td style="text-align: center">여러 개의 리소스 접근 제한 (ex. 프린터 5대)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>Binary Semaphore : Lock처럼 0/1만 관리 (뮤텍스 비슷)</p>
  </li>
  <li>
    <p>Counting Semaphore : 2개 이상 리소스 관리</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sem_t</span> <span class="n">sem</span><span class="p">;</span>
<span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="p">);</span>   <span class="c1">// 자원 요청</span>
<span class="c1">// critical section</span>
<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="p">);</span>   <span class="c1">// 자원 반환</span>
</code></pre></div></div>

<h3 id="condition-variable-조건-변수">Condition Variable (조건 변수)</h3>

<p><strong>개념</strong></p>

<ul>
  <li>
    <p>스레드가 어떤 “특정 조건이 될 때까지 기다리게 하는” 도구</p>
  </li>
  <li>
    <p>Lock과 함께 써야 함! (단독 사용 불가)</p>
  </li>
</ul>

<p><strong>특징</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">기본 기능</td>
      <td style="text-align: center">wait(조건), signal(조건 성취 시 알림)</td>
    </tr>
    <tr>
      <td style="text-align: center">기본 상태</td>
      <td style="text-align: center">조건을 기다리는 대기열</td>
    </tr>
    <tr>
      <td style="text-align: center">소유권</td>
      <td style="text-align: center">Lock과 함께 사용 (Lock 보유해야 wait 가능)</td>
    </tr>
    <tr>
      <td style="text-align: center">주 용도</td>
      <td style="text-align: center">어떤 상태 변화에 따라 스레드 깨우기</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">wait()</code> : 조건이 만족될 때까지 슬립 (잠깐 Lock도 반납)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">signal()</code> : 대기 중인 스레드 하나 깨우기</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">broadcast()</code> : 대기 중인 스레드 모두 깨우기</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">cond</span><span class="p">;</span>

<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="err">조건이</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 조건 만족했으면 수행</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>
<p>(※ wait()할 때 lock을 잠시 반납하고, 조건 충족되면 다시 lock을 잡은 채 깨어나)</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[Lock, Semaphore, Condition Variable 전부 동기화(Synchronization) 기법으로, 여러 스레드/프로세스가 공유 자원을 엉키지 않게 사용하게 만드는 기술이다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">CS:APP 11장 네트워크 프로그래밍 &amp;amp; Proxy 서버 C언어로 구현</title><link href="/blog/computersystem/network-programming/" rel="alternate" type="text/html" title="CS:APP 11장 네트워크 프로그래밍 &amp;amp; Proxy 서버 C언어로 구현" /><published>2025-05-08T00:00:00+00:00</published><updated>2025-05-08T00:00:00+00:00</updated><id>/blog/computersystem/network-programming</id><content type="html" xml:base="/blog/computersystem/network-programming/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#클라이언트---서버-프로그래밍-모델" id="markdown-toc-클라이언트---서버-프로그래밍-모델">클라이언트 - 서버 프로그래밍 모델</a></li>
  <li><a href="#네트워크" id="markdown-toc-네트워크">네트워크</a>    <ul>
      <li><a href="#nic-network-interface-card" id="markdown-toc-nic-network-interface-card">NIC (Network Interface Card)</a></li>
      <li><a href="#이더넷-ethernet" id="markdown-toc-이더넷-ethernet">이더넷 (Ethernet)</a>        <ul>
          <li><a href="#더-큰-lan---브릿지의-등장" id="markdown-toc-더-큰-lan---브릿지의-등장">더 큰 LAN - 브릿지의 등장</a></li>
          <li><a href="#브릿지와-허브의-차이점" id="markdown-toc-브릿지와-허브의-차이점">브릿지와 허브의 차이점</a></li>
        </ul>
      </li>
      <li><a href="#wan-wide-area-network" id="markdown-toc-wan-wide-area-network">WAN (Wide Area Network)</a></li>
      <li><a href="#internet" id="markdown-toc-internet">internet</a></li>
    </ul>
  </li>
  <li><a href="#글로벌-ip-인터넷" id="markdown-toc-글로벌-ip-인터넷">글로벌 IP 인터넷</a>    <ul>
      <li><a href="#ip-주소" id="markdown-toc-ip-주소">IP 주소</a>        <ul>
          <li><a href="#dotted-decimal" id="markdown-toc-dotted-decimal">Dotted-decimal</a></li>
        </ul>
      </li>
      <li><a href="#인터넷-도메인-이름" id="markdown-toc-인터넷-도메인-이름">인터넷 도메인 이름</a></li>
      <li><a href="#인터넷-연결" id="markdown-toc-인터넷-연결">인터넷 연결</a></li>
    </ul>
  </li>
  <li><a href="#소켓-인터페이스" id="markdown-toc-소켓-인터페이스">소켓 인터페이스</a>    <ul>
      <li><a href="#소켓-주소-구조체" id="markdown-toc-소켓-주소-구조체">소켓 주소 구조체</a></li>
      <li><a href="#socket-함수" id="markdown-toc-socket-함수">socket 함수</a></li>
      <li><a href="#connect-함수" id="markdown-toc-connect-함수">connect 함수</a></li>
      <li><a href="#bind-함수" id="markdown-toc-bind-함수">bind 함수</a></li>
      <li><a href="#listen-함수" id="markdown-toc-listen-함수">listen 함수</a></li>
      <li><a href="#accept-함수" id="markdown-toc-accept-함수">accept 함수</a>        <ul>
          <li><a href="#듣기-식별자와-연결-식별자" id="markdown-toc-듣기-식별자와-연결-식별자">듣기 식별자와 연결 식별자</a></li>
        </ul>
      </li>
      <li><a href="#호스트와-서비스-변환getaddrinfo--getnameinfo" id="markdown-toc-호스트와-서비스-변환getaddrinfo--getnameinfo">호스트와 서비스 변환(getaddrinfo &amp; getnameinfo)</a>        <ul>
          <li><a href="#getaddrinfo-함수" id="markdown-toc-getaddrinfo-함수">getaddrinfo 함수</a></li>
          <li><a href="#getnameinfo-함수" id="markdown-toc-getnameinfo-함수">getnameinfo 함수</a></li>
        </ul>
      </li>
      <li><a href="#open_clientfd함수" id="markdown-toc-open_clientfd함수">open_clientfd함수</a></li>
      <li><a href="#open_listenfd함수" id="markdown-toc-open_listenfd함수">open_listenfd함수</a></li>
    </ul>
  </li>
  <li><a href="#echo-client와-server" id="markdown-toc-echo-client와-server">Echo client와 server</a></li>
  <li><a href="#웹-기초" id="markdown-toc-웹-기초">웹 기초</a>    <ul>
      <li><a href="#웹-컨텐츠" id="markdown-toc-웹-컨텐츠">웹 컨텐츠</a></li>
      <li><a href="#동적-컨텐츠의-처리" id="markdown-toc-동적-컨텐츠의-처리">동적 컨텐츠의 처리</a></li>
    </ul>
  </li>
  <li><a href="#소형-웹-서버tiny-web-server" id="markdown-toc-소형-웹-서버tiny-web-server">소형 웹 서버(Tiny web server)</a></li>
  <li><a href="#소형-웹-서버tiny-web-server--프록시-서버" id="markdown-toc-소형-웹-서버tiny-web-server--프록시-서버">소형 웹 서버(Tiny web server) + 프록시 서버</a>    <ul>
      <li><a href="#웹-프록시란" id="markdown-toc-웹-프록시란">웹 프록시란?</a></li>
    </ul>
  </li>
  <li><a href="#프록시-서버" id="markdown-toc-프록시-서버">프록시 서버</a></li>
  <li><a href="#프록시-서버-쓰레딩과-캐싱-기능-추가" id="markdown-toc-프록시-서버-쓰레딩과-캐싱-기능-추가">프록시 서버 쓰레딩과 캐싱 기능 추가</a></li>
</ul>

<p>흥미로운 것은 모든 네트워크 응용들은 동일한 기본적인 프로그래밍 모델에 기초하고 있으며, 이들은 비슷한 전체 논리 구조를 가지며, 동일한 프로그래밍 인터페이스를 사용한다는 점이다. 개념들을 설명하고 난 후 개념들을 모두 연결해서 아주 작지만 실제로 동작하는 웹 서버를 개발할 것이다.</p>

<h2 id="클라이언트---서버-프로그래밍-모델">클라이언트 - 서버 프로그래밍 모델</h2>

<p>** 모든 네트워크 응용 프로그램은 클라이언트-서버 모델에 기초하고 있다.** 아래와 같은 사진과 같이 한 개의 서버 프로세스와 한 개 이상의 클라이언트 프로세스로 구성된다.</p>

<p><img src="/assets/img/blog/computerscience/clientservertransaction.png" alt="클라이언트 서버 모델" /></p>

<ol>
  <li>
    <p>클라이언트가 한 개의 요청(request)을 서버에 보내는 것으로 트랜잭션을 개시한다. 예를 들어, 웹 브라우저가 파일을 필요로 할때, 웹 서버로 요청을 보낸다.</p>
  </li>
  <li>
    <p>서버는 요청을 받고, 해석하고, 자신의 자원들을 적절한 방법으로 조작한다. 예를 들어, 웹 서버가 브라우저로부터 요청을 받을 때, 디스크 파일을 읽는다.</p>
  </li>
  <li>
    <p>서버는 응답(response)을 클라이언트로 보내고, 그 후에 다음 요청을 기다린다. 예를 들어, 웹 서버는 이 파일을 다시 클라이언트로 돌려보낸다.</p>
  </li>
  <li>
    <p>클라이언트는 응답을 받고 이걸을 처리한다. 예를 들어, 웹 브라우저가 서버로부터 페이지를 한 개 받은 후, 이것을 스크린에 디스플레이한다.</p>
  </li>
</ol>

<h2 id="네트워크">네트워크</h2>

<p>물리적으로 네트워크는 기하학적 위치로 구성된 <strong>계층구조 시스템</strong>이다 하위수준은 <strong>LAN(Local Area Network)</strong>으로 빌딩이나 캠퍼스에 설치된다. 가장 대중적인 LAN기술은 현재까지는 이더넷(Ehternet)이며, 시간에 따라서 엄청 발전되어 왔다. 이더넷(Ethernet)에 관련한 설명은 아래에 있다.</p>

<h3 id="nic-network-interface-card">NIC (Network Interface Card)</h3>

<p>호스트에게 네트워크는 단지 또 다른 I/O 디바이스이다. 아래 사진과 같이 네트워크에서 수신한 데이터는 I/O와 메모리 버스를 거쳐서 어댑터에서 메모리로, 대개 DMA 전송으로 복사된다. 비슷하게 데이터는 또한 메모리에서 네트워크로 복사될 수 있다.</p>

<p><img src="/assets/img/blog/computerscience/hosthardwareorganization.png" alt="호스트의 네트워크 구성" /></p>

<h3 id="이더넷-ethernet">이더넷 (Ethernet)</h3>

<p>이더넷 세그먼트는 아래 사진과 같이 몇 개의 전선들과 허브라고 부르는 작은 상자로 구성된다. 한쪽 끝은 호스트의 어댑터에 연결되고, 다른 끝은 허브의 포트에 연결된다. 허브는 각 포트에서 수신한 모든 비트를 종속적으로 다른 모든 포트로 복사한다.</p>

<p><img src="/assets/img/blog/computerscience/ethernetsegment.png" alt="이더넷 세그먼트" /></p>

<ul>
  <li>
    <p><strong>이더넷 어댑터</strong>는 어댑터의 비휘발성 메모리에 저장된 전체적으로 <strong>고유한 48비트 주소</strong>를 가진다.</p>
  </li>
  <li>
    <p>호스트는 <strong>프레임</strong>이라고 부르는 비트들을 세그먼트의 다른 호스트에 보낼 수 있다.</p>
  </li>
  <li>
    <p>각 <strong>프레임</strong>은 프레임의 <strong>소스</strong>와 <strong>목적지</strong>, 프레임의 <strong>길이</strong>를 식별할 수 있는 고정된 <strong>헤더 비트</strong>를 가지고 있으며, 그 뒤에 데이터 비트가 이어진다.</p>
  </li>
  <li>
    <p>모든 호스트 어댑터는 이 프레임을 볼 수 있지만, 목적지 호스트만이 실제로 이것을 읽어들인다.</p>
  </li>
</ul>

<h4 id="더-큰-lan---브릿지의-등장">더 큰 LAN - 브릿지의 등장</h4>

<p>아래 사진에 나타난 것처럼 전선들과 브릿지라고 하는 작은 상자들을 사용해서 **다수의 이더넷 세그먼트가 연결되어 브릿지형 이더넷이라고 하는 더 큰 LAN을 구성할 수 있다.</p>

<p><img src="/assets/img/blog/computerscience/bridgedethernetsegments.png" alt="브릿지로 연결된 이더넷 세그먼트" /></p>

<ul>
  <li>
    <p>브릿지형 이더넷에서 일부 선은 브릿지를 브릿지로 연결하고, 다른 선들은 브릿지를 허브로 연결한다.</p>
  </li>
  <li>
    <p>각 선의 대역폭은 다를 수 있다. 우리의 예제에서 브릿지-브릿지선은 1Gb/s 대역폭을, 네 개의 허브-브릿지 선은 100Mb/s 대역폭을 가진다.</p>
  </li>
</ul>

<h4 id="브릿지와-허브의-차이점">브릿지와 허브의 차이점</h4>

<ul>
  <li>
    <p>브릿지는 허브보다 더 높은 전선의 대역폭을 가진다.</p>
  </li>
  <li>
    <p>허브는 각 포트에서 수신한 모든 비트를 종속적으로 다른 모든 포트로 복사한다.</p>
  </li>
  <li>
    <p>브릿지는 우수한 분산 알고리즘을 통해 필요한 경우 선택적으로 하나의 포트에서 다른 포트로 프레임을 복사한다.</p>
  </li>
</ul>

<h3 id="wan-wide-area-network">WAN (Wide Area Network)</h3>

<p>계층구조의 상부에서 다수의 비호환성 LAN들은 라우터라고 부르는 특별한 컴퓨터에 의해서 연결될 수 있으며, <strong>라우터는 네트워크 간 연결을 구성한다(상호연결 네트워크)</strong>. 각 라우터는 이들이 연결되는 각 네트워크에 대해 어댑터(포트)를 가지고 있다. <strong>라우터는 또한 고속의 point-to-point 전화 연결을 할 수 있으며, 이들은 WAN이라고 하는 네트워크의 사례다</strong>. 이 이름은 이들이 LAN보다 지리적으로 더 넓은 지역에서 운용되기 때문에 불리게 되었다.</p>

<h3 id="internet">internet</h3>

<p><strong>internet의 중요한 특성은 이것이 매우 다르고 비호환적인 기술을 갖는 여러 가지 LAN과 WAN들로 이루어져 있다는 점이다</strong>. internet 프로토콜은 두 가지 기본 기능을 제공해야 한다.</p>

<ul>
  <li>
    <p>명명법(Naming Scheme) : internet 프로토콜은 호스트 주소를 위한 통일된 포맷을 정의해서 이 차이점들을 줄인다.</p>
  </li>
  <li>
    <p>전달기법(Delivery Mechanism) : internet 프로토콜은 데이터 비트를 패킷(packet)이라고 부르는 비연속적인 단위로 묶는 통일된 방법을 정의해서 이 차이점을 줄인다. 패킷은 패킷 크기와 소스 및 목적지 호스트 주소를 포함하는 헤더와 소스 호스트가 보낸 데이터 비트를 포함하는 데이터로 구성된다. 이것을 Datagram이라고도 부른다.</p>
  </li>
</ul>

<p>전달기법 관련하여서 패킷화하는 과정은 아래 사진과 같다. 여기서 말하는 Datagram은 (1) → (2) 로 가는 방법이다.</p>

<p><img src="/assets/img/blog/computerscience/internetpacket.png" alt="인터넷 패킷화 과정" /></p>

<h2 id="글로벌-ip-인터넷">글로벌 IP 인터넷</h2>

<p>인터넷 클라이언트 - 서버 응용의 기본적인 하드웨어 및 소프트웨어 구조는 아래 사진과 같으며, 이 구조는 1980년대 이후로 안정적이었다.</p>

<p><img src="/assets/img/blog/computerscience/clientserverstructure.png" alt="클라이언트 서버 구조" /></p>

<p>각 인터넷 호스트는 TCP/IP 프로토콜(Transmission Control Protocol/Internet Protocol)을 구현한 소프트웨어를 실행하며, 이것은 거의 모든 현대 컴퓨터 시스템에서 지원되고 있다.</p>

<p>관련한 프로토콜 HTTP/TCP/UDP 관련하여서는 <a href="../../computersystem/http-tcp-udp" class="heading flip-title">HTTP, TCP, UDP</a>을 참고하면 된다.</p>

<h3 id="ip-주소">IP 주소</h3>

<p>IPv4 주소는 비부호형 32비트 정수다. 네트워크 프로그램은 IP주소를 아래와 같은 IP주소 구조체에 저장한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* IP address structure */</span>
<span class="k">struct</span> <span class="n">in_addr</span> <span class="p">{</span>
<span class="kt">uint32_t</span> <span class="n">s_addr</span><span class="p">;</span> <span class="cm">/* Address in network byte order (big-endian) */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>TCP/IP는 네트워크 패킷 헤더에 포함되는 IP 주소 같은 모든 정수형 데이터 아이템에 대해서 통일된 <strong>Network Byte Order(Big Endian 바이트 순서)</strong>를 정의한다.</p>

<ul>
  <li>
    <p>Big Endian : 가장 큰 자릿값(최상위 바이트)을 가장 낮은 주소에, 그 다음 바이트를 뒤쪽 주소에 차례로 저장</p>
  </li>
  <li>
    <p>Little Endian : 반대로 최하위 바이트를 가장 낮은 주소에 두고, 큰 바이트로 갈수록 주소가 커짐. x86, ARM(Android/iOS) 같은 현대 CPU 대부분이 사용함</p>
  </li>
</ul>

<h4 id="dotted-decimal">Dotted-decimal</h4>

<p>IP 주소는 대게 사람들에게 dotted-decimal 표기라고 하는 형식으로 제시되며, 이것은 각 바이트가 십진수 값을 사용하고 다른 바이트들과는 점을 사용해서 구분된다. 아래와 같은 것이 dotted-decimal이다.</p>

<pre><code class="language-linux">linux&gt; hostname -i
128.2.210.175
</code></pre>

<h3 id="인터넷-도메인-이름">인터넷 도메인 이름</h3>

<p><strong>DNS(Domain Name System)</strong> 데이터베이스는 수백만 개의 호스트 엔트리로 구성되어 있으며, 이들 각각은 도메인 이름의 집합과 IP 주소 집합 사이의 매핑을 정의한다.</p>

<p>4가지의 매핑을 아래에 나열하겠다.</p>

<ol>
  <li>가장 간단한 경우로, 도메인 이름과 IP 주소 사이의 일대일 매핑</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup whaleshark.ics.cs.cmu.edu
Address: 128.2.210.175
</code></pre>

<ol>
  <li>다수의 도메인 이름이 동일한 IP 주소에 매핑</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup cs.mit.edu
Address: 18.62.1.6

linux&gt; nslookup eecs.mit.edu
Address: 18.62.1.6
</code></pre>

<ol>
  <li>다수의 도메인 이름들은 다수의 IP 주소로 매핑</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup www.twitter.com
Address: 199.16.156.6
Address: 199.16.156.70
Address: 199.16.156.102
Address: 199.16.156.230

linux&gt; nslookup twitter.com
Address: 199.16.156.102
Address: 199.16.156.230
Address: 199.16.156.6
Address: 199.16.156.70
</code></pre>

<ol>
  <li>마지막으로, 일부 유효한 도메인 이름들은 어떤 IP 주소에도 매핑되어 있지 않다.</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup edu
*** Can’t find edu: No answer
linux&gt; nslookup ics.cs.cmu.edu
*** Can’t find ics.cs.cmu.edu: No answer
</code></pre>

<h3 id="인터넷-연결">인터넷 연결</h3>

<p><strong>인터넷 client와 server는 연결(connection)을 통해서 바이트 스트림을 주고받는 방식으로 통신한다</strong>. 이 연결은 두개의 프로세스를 연결한다는 점에서 <strong>point-to-point 연결</strong>이다. 데이터가 동시에 양방향으로 흐를 수 있다는 의미에서 이것은 <strong>완전양방향(full-duplex)</strong>이다.</p>

<ul>
  <li>
    <p>소켓(Socket)은 연결의 종단점이다.</p>
  </li>
  <li>
    <p>각 소켓은 인터넷 주소와 16비트 정수 포트로 이루어진 소켓 주소를 가지며, 이것은 address : port로 나타낸다.</p>
  </li>
  <li>
    <p>클라이언트의 소켓 주소 내의 포트는 클라이언트가 연결 요청을 할 때 커널이 자동으로 할당하며, 이것은 단기(Ephemeral) 포트라고 한다.</p>
  </li>
  <li>
    <p>서버는 서비스에 연관된 포트를 사용한다.</p>
  </li>
</ul>

<p>인터넷 연결같은 경우 두 개의 종단점의 소켓 주소에 의해 유일하게 식별된다. 이 두개의 소켓 주소는 소켓 쌍이라고 알려져 있으며, 아래와 같이 tuple로 나타낸다.</p>

<p><img src="/assets/img/blog/computerscience/internetconnection.png" alt="인터넷 연결의 구조" /></p>

<h2 id="소켓-인터페이스">소켓 인터페이스</h2>

<p>소켓 인터페이스는 네트워크 응용을 만들기 위한 Unix I/O 함수들과 함께 사용되는 함수들의 집합이다. 이것은 모든 Unix 변종, 윈동, 매킨토시 시스템을 포함하는 대부분의 현대 시스템에서 구현되었다. 아래와 같은 그림은 전형적인 client-server transaction의 문맥에서 소켓 인터페이스의 개요를 보여준다.</p>

<p><img src="/assets/img/blog/computerscience/socketinterfaceoverview.png" alt="소켓 인터페이스 기반 네트워크 응용 프로그램의 개요" /></p>

<h3 id="소켓-주소-구조체">소켓 주소 구조체</h3>

<p><strong>리눅스 커널의 관점에서 보면, 소켓은 통신을 위한 끝점이다. Unix 프로그램의 관점에서 보면 소켓은 해당 식별자를 가지는 열린 파일이다</strong>.</p>

<ul>
  <li>Unix 프로그램에서는 network도 파일처럼 여겨진다.</li>
</ul>

<p>인터넷 소켓 주소는 아래 코드와 같이 프로토콜에 특화된 구조체로, 모든 포인터를 포괄적인 구조체로 캐스팅하도록 정의하는 것이었다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* IP socket address structure */</span>
<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="p">{</span>
<span class="kt">uint16_t</span> <span class="n">sin_family</span><span class="p">;</span> <span class="cm">/* Protocol family (always AF_INET) */</span>
<span class="kt">uint16_t</span> <span class="n">sin_port</span><span class="p">;</span> <span class="cm">/* Port number(16bit) in network byte order */</span>
<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span> <span class="cm">/* IP address in network byte order */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* Pad to sizeof(struct sockaddr) */</span>
<span class="p">};</span>

<span class="cm">/* Generic socket address structure (for connect, bind, and accept) */</span>
<span class="k">struct</span> <span class="n">sockaddr</span> <span class="p">{</span>
<span class="kt">uint16_t</span> <span class="n">sa_family</span><span class="p">;</span> <span class="cm">/* Protocol family */</span>
<span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span> <span class="cm">/* Address data */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>위에 두가지 구조체가 등장하는데, 첫번째 구조체는 IPv4전용 주소 구조체이며, 두번째 구조체는 TCP, IPv6, IPv4, UDP 등 범용적으로 사용할 수 있는 구조체이다.</p>

<p>첫번째 구조체에서 두번째 구조체로 캐스팅할 필요가 있을 떄, 아래와 같은 타입을 사용한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">SA</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="socket-함수">socket 함수</h3>

<p><strong>Client</strong>와 <strong>server</strong>는 소켓 식별자를 생성하기 위해 socket 함수를 사용한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>

<span class="cm">/* Returns: nonnegative descriptor if OK, −1 on error */</span>
</code></pre></div></div>

<p>음이 아닌 정수를 반환하며, 이 정수는 식별자다. 이 식별자로 커널 내부의 소켓 자료구조를 찾아갈 수 있어서 프로그래머에게는 핸들(handle) 역할을 함</p>

<h3 id="connect-함수">connect 함수</h3>

<p><strong>Client</strong>는 connect함수를 호출해서 server와의 연결을 수립한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">clientfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
<span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
<span class="o">~~~</span><span class="n">c</span>

<span class="n">connect</span> <span class="err">함수는</span> <span class="err">소켓</span> <span class="err">주소</span> <span class="n">addr</span><span class="err">의</span> <span class="err">서버와</span> <span class="err">인터넷</span> <span class="err">연결을</span> <span class="err">시도하며</span><span class="p">,</span> <span class="n">addrlen</span><span class="err">은</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sockaddr_in</span><span class="p">)</span><span class="err">이</span> <span class="err">된다</span><span class="p">.</span> <span class="n">connect</span><span class="err">함수는</span> <span class="err">연결이</span> <span class="err">성공할</span> <span class="err">때까지</span> <span class="err">블록되어</span> <span class="err">있거나</span> <span class="err">에러가</span> <span class="err">발생한다</span><span class="p">.</span> <span class="err">만일</span> <span class="err">성공이라면</span><span class="p">,</span> <span class="n">clientfd</span> <span class="err">식별자는</span> <span class="err">이제</span> <span class="err">읽거나</span> <span class="err">쓸</span> <span class="err">준비가</span> <span class="err">되었으며</span><span class="p">,</span> <span class="err">이</span> <span class="err">연결은</span> <span class="err">다음과</span> <span class="err">같은</span> <span class="err">소켓</span> <span class="err">쌍으로</span> <span class="err">규정된다</span><span class="p">.</span>

<span class="o">~~~</span><span class="n">c</span>
<span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">,</span> <span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="o">:</span><span class="n">addr</span><span class="p">.</span><span class="n">sin_port</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="bind-함수">bind 함수</h3>

<p>남아 있는 소켓 함수 bind, listen, accept는 server가 client와 연결을 수립하기 위해 사용한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
<span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
</code></pre></div></div>

<p>bind 함수는 kernel에게 addr에 있는 server의 소켓 주소를 소켓 식별자 sockfd와 연결하라고 물어본다.</p>

<h3 id="listen-함수">listen 함수</h3>

<p>client는 연결 요청을 개시하는 능동적 개체이다. server는 client로부터의 연결 요청을 기다리는 수동적 개체이다. 그래서 socket함수가 함수가 만든 식별자는 한 연결의 클라이언트 쪽 끝에서 존재하는 능동 소켓에 대응된다. 서버는 listen함수를 호출해서 이 식별자를 client 대신에 server가 사용하게 될 것이라고 알려준다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span> 
</code></pre></div></div>

<p>listen 함수는 sockfd를 능동 소켓에서 듣기 소켓으로 변환하며, 듣기 소켓은 client로부터의 연결 요청을 승락할 수 있다.</p>

<h3 id="accept-함수">accept 함수</h3>

<p>서버는 accept함수를 호출해서 client로부터의 연결 요청을 기다린다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>

<span class="cm">/* Returns: nonnegative connected descriptor if OK, −1 on error */</span>
</code></pre></div></div>

<p>accept함수는 client로부터의 연결 요청이 듣기 식별자 listenfd에 도달하기를 기다리고, 그 후에 addr 내의 client의 소켓 주소를 채우고, Unix I/O 함수들을 사용해서 client와 통신하기 위해 사용될 수 있는 연결 식별자를 리턴한다.</p>

<h4 id="듣기-식별자와-연결-식별자">듣기 식별자와 연결 식별자</h4>

<p>듣기 식별자와 연결 식별자 사이의 구분은 많은 학생들을 혼란스럽게 한다. 듣기 식별자는 client 연결 요청에 대해 끝점으로서의 역할을 한다. 이것은 대개 한 번 생성되며, 서버가 살아있는 동안 계속 존재한다. 연결 식별자는 client와 server 사이에 성립된 연결의 끝점이다. 이것은 server가 연결 요청을 수락할 때마다 생성되며, server가 client에 서비스하는 동안에만 존재한다.</p>

<p>accept함수의 flow를 그림을 통해서 설명해 보겠다. 듣기 식별자와 연결 식별자 구분에 도움이 될 것이다.</p>

<p><img src="/assets/img/blog/computerscience/listeningandconnecteddescriptor.png" alt="듣기와 연결 식별자의 역할" /></p>

<ol>
  <li>
    <p>server는 accept를 호출하고, 이것은 연결 요청이 읽기 식별자에 도달하기를 기다리며, 명확하게 하기 위해서 이것을 식별자 3이라고 가정한다. 식별자 0 ~ 2는 표준 파일들을 위해 배정되어 있다는 점을 기억하라.</p>
  </li>
  <li>
    <p>client는 connect함수를 호출하고, 이것은 listenfd로 연결 요청을 보낸다.</p>
  </li>
  <li>
    <p>accept함수는 새로운 연결 식별자 connfd(이것은 식별자 4라고 가정한다)를 오픈하고, clientfd와 connfd 사이의 연결을 수립하고 응용에 connfd를 리턴한다. client는 또한 connect에서 return하고, 이 지점에서 client와 server는 clientfd와 connfd를 각각 읽고 쓰는 방법으로 data를 주고받을 수 있다.</p>
  </li>
</ol>

<h3 id="호스트와-서비스-변환getaddrinfo--getnameinfo">호스트와 서비스 변환(getaddrinfo &amp; getnameinfo)</h3>

<p>리눅스는 getaddrinfo와 getnameinfo라고 하는 강력한 함수들을 제공하는데, 소켓 interface와 함께 이용될 때 매우 유용하다. 또한 우리가 특정 IP 프로토콜의 버전에 의존하지 않는 네트워크 프로그램을 작성하게 해준다.</p>

<h4 id="getaddrinfo-함수">getaddrinfo 함수</h4>

<p>getaddrinfo함수는 host이름, host주소, service이름, port번호의 스트링 표시를 소켓 주소 구조체로 변환한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">getaddrinfo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">service</span><span class="p">,</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">hints</span><span class="p">,</span>
<span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">**</span><span class="n">result</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, nonzero error code on error */</span>

<span class="kt">void</span> <span class="nf">freeaddrinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">result</span><span class="p">);</span>
<span class="n">Returns</span><span class="o">:</span> <span class="n">nothing</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">gai_strerror</span><span class="p">(</span><span class="kt">int</span> <span class="n">errcode</span><span class="p">);</span>

<span class="cm">/* Returns: error message */</span>
</code></pre></div></div>

<p>host와 service(소켓 주소의 두 개의 구성요소)가 주어지면, getaddrinfo는 각각이 host와 service에 대응되는 소켓 주소 구조체를 가리키는 addrinfo 구조체의 연결리스트를 가리키는 <strong>result(pointer)를 return</strong>한다. result로 부터의 연결 리스트는 아래 사진과 같다.</p>

<p><img src="/assets/img/blog/computerscience/getaddrinfolinkedlist.png" alt="getaddrinfo result의 자료구조" /></p>

<p>연결리스트로 반환하는 이유에 대해서는, 하나의 IP로 접속이 실패할 수 있기 때문에, 그것에 대한 backup용으로 여러개의 IP를 포함시키기 위함이다.</p>

<p>addrinfo에는 다음 같은 구조로 되어 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">addrinfo</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">ai_flags</span><span class="p">;</span> <span class="cm">/* Hints argument flags */</span>
<span class="kt">int</span> <span class="n">ai_family</span><span class="p">;</span> <span class="cm">/* First arg to socket function */</span>
<span class="kt">int</span> <span class="n">ai_socktype</span><span class="p">;</span> <span class="cm">/* Second arg to socket function */</span>
<span class="kt">int</span> <span class="n">ai_protocol</span><span class="p">;</span> <span class="cm">/* Third arg to socket function */</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">ai_canonname</span><span class="p">;</span> <span class="cm">/* Canonical hostname */</span>
<span class="kt">size_t</span> <span class="n">ai_addrlen</span><span class="p">;</span> <span class="cm">/* Size of ai_addr struct */</span>
<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">ai_addr</span><span class="p">;</span> <span class="cm">/* Ptr to socket address structure */</span>
<span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">ai_next</span><span class="p">;</span> <span class="cm">/* Ptr to next item in linked list */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>기본적으로, host에 연관된 각각의 고유의 주소에 대해, getaddrinfo함수는 최대 세개의 addrinfo 구조체를 return할 수 있으며, 각각은 서로 다른 ai_socktype 필드를 갖는다 : 한 개는 연결을 위해, 하나는 datagram, 마지막 하나는 원시 소켓을 위해.</p>

<h4 id="getnameinfo-함수">getnameinfo 함수</h4>

<p>getnameinfo함수는 getaddrinfo의 역이다. 이것은 소켓 주소 구조체를 대응되는 host와 service이름 스트링으로 변환한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">getnameinfo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">salen</span><span class="p">,</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">hostlen</span><span class="p">,</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">service</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">servlen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, nonzero error code on error */</span>
</code></pre></div></div>

<h3 id="open_clientfd함수">open_clientfd함수</h3>

<p>client는 open_clientfd를 호출해서 server와 연결을 설정한다. 여기 안에 socket interface함수들이 많이 포함되어 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">open_clientfd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">clientfd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">listp</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

    <span class="cm">/* Get a list of potential server addresses */</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">addrinfo</span><span class="p">));</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span> <span class="cm">/* Open a connection */</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="n">AI_NUMERICSERV</span><span class="p">;</span> <span class="cm">/* ... using a numeric port arg. */</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">|=</span> <span class="n">AI_ADDRCONFIG</span><span class="p">;</span> <span class="cm">/* Recommended for connections */</span>
    <span class="n">Getaddrinfo</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listp</span><span class="p">);</span>

    <span class="cm">/* Walk the list for one that we can successfully connect to */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">listp</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Create a socket descriptor */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">clientfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span> <span class="cm">/* Socket failed, try the next */</span>

        <span class="cm">/* Connect to the server */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span> <span class="cm">/* Success */</span>
        <span class="n">Close</span><span class="p">(</span><span class="n">clientfd</span><span class="p">);</span> <span class="cm">/* Connect failed, try another */</span>
    <span class="p">}</span>

    <span class="cm">/* Clean up */</span>
    <span class="n">Freeaddrinfo</span><span class="p">(</span><span class="n">listp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="cm">/* All connects failed */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="cm">/* The last connect succeeded */</span>
        <span class="k">return</span> <span class="n">clientfd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>함수를 실행하면 최종적으로 clientfd를 반환한다.</p>

<h3 id="open_listenfd함수">open_listenfd함수</h3>

<p>server는 open_listenfd함수를 호출해서 연결요청을 받을 준비가 된 듣기 식별자를 생성한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">open_listenfd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">listp</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">optval</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* Get a list of potential server addresses */</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">addrinfo</span><span class="p">));</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span> <span class="cm">/* Accept connections */</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="n">AI_PASSIVE</span> <span class="o">|</span> <span class="n">AI_ADDRCONFIG</span><span class="p">;</span> <span class="cm">/* ... on any IP address */</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">|=</span> <span class="n">AI_NUMERICSERV</span><span class="p">;</span> <span class="cm">/* ... using port number */</span>
    <span class="n">Getaddrinfo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listp</span><span class="p">);</span>

    <span class="cm">/* Walk the list for one that we can bind to */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">listp</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Create a socket descriptor */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">listenfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span> <span class="cm">/* Socket failed, try the next */</span>

        <span class="cm">/* Eliminates "Address already in use" error from bind */</span>
        <span class="n">Setsockopt</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span>
                <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">optval</span> <span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

        <span class="cm">/* Bind the descriptor to the address */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span> <span class="cm">/* Success */</span>
        <span class="n">Close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span> <span class="cm">/* Bind failed, try the next */</span>
    <span class="p">}</span>

    <span class="cm">/* Clean up */</span>
    <span class="n">Freeaddrinfo</span><span class="p">(</span><span class="n">listp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="cm">/* No address worked */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* Make it a listening socket ready to accept connection requests */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">listenfd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>함수를 실행하면 최종적으로 listenfd를 반환한다.</p>

<h2 id="echo-client와-server">Echo client와 server</h2>

<p>이것은 교제에 나오는 한 예제인데, client가 server에 data를 보내면 server가 다시 client에 똑같은 data를 보내는 방식의 소통이다. 나는 이걸 구현할 때, 우선 책에 나와있는 예제를 따라서 쳐 보았다.</p>

<ul>
  <li>echoclient.c
~~~c
#include “csapp.h” // robust I/O 함수들과 네트워크 래퍼 함수들이 정의된 헤더</li>
</ul>

<p>int main(int argc, char **argv)
{
    int clientfd; // 클라이언트 소켓 식별자
    char *host, *port, *buf[MAXLINE]; // 서버 호스트명, 포트 번호, 버퍼
    rio_t rio; // robust I/O 구조체</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 명령줄 인자가 3개가 아니면 사용법 출력 후 종료
if (argc != 3)
{
    fprintf(stderr, "usage: %s &lt;host&gt; &lt;port&gt;\n", argv[0]); // 사용법 출력
    exit(0);
}

// 호스트명과 포트 번호를 명령줄 인자에서 가져옴
host = argv[1]; // 호스트명
port = argv[2]; // 포트 번호

// 서버에 연결하기 위한 클라이언트 소켓 열기
clientfd = Open_clientfd(host, port); // 호스트와 포트 번호로 클라이언트 소켓 열기

// 클라이언트 소켓을 기반으로 robust I/O 구조체 초기화
Rio_readinitb(&amp;rio, clientfd); // 클라이언트 소켓을 기반으로 rio 구조체 초기화

// 사용자로부터 한 줄씩 입력받아 서버에 전송하는 반복문
while (Fgets(buf, MAXLINE, stdin) != NULL) // 표준 입력으로부터 한 줄 읽기
{
    // 읽은 데이터를 서버에 전송
    Rio_writen(clientfd, buf, strlen(buf)); // 클라이언트 소켓을 통해 서버에 데이터 전송

    // 서버로부터 응답을 읽어와서 출력
    Rio_readlineb(&amp;rio, buf, MAXLINE); // 서버로부터 한 줄 읽기
    
    // 읽은 데이터를 표준 출력으로 출력
    Fputs(buf, stdout);
}

Close(clientfd); // 클라이언트 소켓 닫기
exit(0); // 프로그램 종료 } ~~~
</code></pre></div></div>

<ul>
  <li>echoserveri.c
~~~c
#include “csapp.h”          // robust I/O 함수와 네트워크 함수 래퍼가 포함된 헤더 파일</li>
</ul>

<p>void echo(int connfd);</p>

<p>int main(int argc, char **argv)
{
    int listenfd, connfd;   // 서버의 listen용 듣기 식별자와 클라이언트 연결용 연결 식별자
    socklen_t clientlen;    // 클라이언트 주소 구조체의 크기
    struct sockaddr_storage clientaddr; // 클라이언트 주소 or domain name 저장할 구조체
    char client_hostname[MAXLINE], client_port[MAXLINE]; // 클라이언트 호스트명과 포트 번호를 저장할 버퍼</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 명령줄 인자가 2개가 아니면 사용법 출력 후 종료
if (argc != 2)
{
    fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]); // 사용법 출력
    exit(0);
}

// 포트 번호를 인자로 받아 서버 리슨 소켓 열기
listenfd = Open_listenfd(argv[1]); // argv[1] 포트 번호로 리슨 소켓 열기

while (1)   // 반복형 서버: 클라이언트가 연결 올 때마다 반복
{
    clientlen = sizeof(struct sockaddr_storage); // 클라이언트 주소 구조체 크기 초기화
    // 클라이언트 연결 요청을 수락하고 연결된 소켓 식별자(connfd) 반환
    connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);

    // 클라이언트 주소를 문자열로 변환하여 client_hostname과 client_port에 저장
    Getnameinfo((SA *)&amp;clientaddr, clientlen, client_hostname, MAXLINE,
                client_port, MAXLINE, 0);
    // 클라이언트의 호스트명과 포트 번호를 출력
    printf("Connected to (%s, %s)\n", client_hostname, client_port);
    // 클라이언트와 연결된 connfd를 인자로 하여 echo 함수 호출
    echo(connfd);
    // 클라이언트와의 연결 종료
    Close(connfd);
}
exit(0); // 프로그램 종료 } ~~~
</code></pre></div></div>

<p>한 번에 한 개씩의 client를 반복해서 실행하는 이런 종류의 서버를 반복서버(iterative server)라고 부른다.</p>

<ul>
  <li>echo.c
~~~c
#include “csapp.h”          // robust I/O 함수와 관련 구조체를 포함한 헤더 파일 포함</li>
</ul>

<p>// 클라이언트와 연결된 소켓 파일 디스크립터(connfd)를 인자로 받음
void echo(int connfd)
{
    size_t n;               // 읽은 바이트 수를 저장할 변수
    char buf[MAXLINE];      // 데이터를 읽어올 버퍼 (한 줄 최대 MAXLINE 크기)
    rio_t rio;              // robust I/O 버퍼 구조체</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// connfd(클라이언트와 연결된 소켓)를 기반으로 rio 구조체 초기화
Rio_readinitb(&amp;rio, connfd);

// 클라이언트로부터 한 줄씩 데이터를 계속 읽어들이는 반복문
while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0)
{
    // 읽은 바이트 수를 서버 로그로 출력
    printf("server received %zu bytes\n", n);

    // 읽은 데이터를 그대로 다시 클라이언트에게 돌려보냄 (Echo!)
    Rio_writen(connfd, buf, n);
} } ~~~
</code></pre></div></div>

<h2 id="웹-기초">웹 기초</h2>

<p>Web client와 server는 HTTP(Hypertext Transfer Protocol)라고 하는 텍스트 기반 응용수준 프로토콜을 사용해서 상호 연동한다.</p>

<p>무엇이 FTP 같은 전통적인 파일 전송 서비스를 web service와 구별하게 해주는가?</p>

<ul>
  <li>
    <p>주요 차이점은 web contents는 HTML(Hpertext Markup Language)이라는 언어로 작성될 수 있다는 것이다.</p>
  </li>
  <li>
    <p>HTML 프로그램(페이지)은 명령들(태그)을 포함하고 있어서 브라우제에게 여러 가지 텍스트와 그래픽 객체를 페이지에 어떻게 표시할지를 알려준다.</p>
  </li>
</ul>

<h3 id="웹-컨텐츠">웹 컨텐츠</h3>

<p>Web client와 server에게, contents는 연관된 MIME(Multipurpose Internet Mail Extensions) 타입을 갖는 바이트 배열이다. 아래는 많이 쓰이는 MIME 타입들이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">MIME type</th>
      <th style="text-align: center">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">text/html</td>
      <td style="text-align: center">HTML page</td>
    </tr>
    <tr>
      <td style="text-align: center">text/plain</td>
      <td style="text-align: center">Unformatted text</td>
    </tr>
    <tr>
      <td style="text-align: center">application/postscript</td>
      <td style="text-align: center">Postscript document</td>
    </tr>
    <tr>
      <td style="text-align: center">image/gif</td>
      <td style="text-align: center">Binary image encoded in GIF format</td>
    </tr>
    <tr>
      <td style="text-align: center">image/png</td>
      <td style="text-align: center">Binary image encoded in PNG format</td>
    </tr>
    <tr>
      <td style="text-align: center">image/jpeg</td>
      <td style="text-align: center">Binary image encoded in JPEG format</td>
    </tr>
  </tbody>
</table>

<p>Web server는 두 가지 서로 다른 방법으로 client에게 contents를 제공한다.</p>

<ul>
  <li>
    <p>디스크 파일을 가져와서 그 내용을 client에게 보낸다. 디스크 파일은 정적 컨텐츠라고 하며, 파일을 client에게 돌려주는 작업은 정적 컨텐츠 처리한다고 말한다.</p>
  </li>
  <li>
    <p>실행파일을 돌리고, 그 출력을 client에게 보낸다. 실행파일이 런타임에 만든 출력을 동적 컨텐츠라고 하며, 프로그램을 실행하고 그 결과를 client에게 보내주는 과정을 동적 컨텐츠 처리한다고 말한다.</p>
  </li>
</ul>

<p>Web server가 return하는 모든 내용들은 server가 관리하는 file에 연관된다. 이 파일 각각은 URL(Universal Resource Locator)라고 하느 고유의 이름을 가진다. 예를 들어, 다음과 같은 URL은</p>

<pre><code class="language-url">https://www.google.com:80/index.html
</code></pre>

<p>포트 80에서 듣고있는 웹 서버가 관리하는 인터넷 호스트 www.google.com의 /index.html이라는 HTML 파일을 지정한다.</p>

<p>여기서 접두어는</p>

<pre><code class="language-url">https://www.google.com:80
</code></pre>

<p>이고, 접두어를 통해 어떤 종류의 서버에 접속해야 하는지 결정하고, 어디에 서버가 있는지, 서버가 무슨 포트를 듣고 있는지를 결정한다.</p>

<p>접미어는</p>

<pre><code class="language-url">/index.html
</code></pre>

<p>이며, 자신의 파일 시스템 상의 파일을 검색하고, 이 요청이 정적 또는 동적 컨텐츠에 대한 것인지 결정한다.</p>

<p>실행파일을 위한 URL은 파일 이름 뒤에 프로그램의 인자를 포함할 수 있다. ‘?’ 문자는 파일 이름과 인자를 구분하며, 각 인자는 ‘&amp;’로 구분된다. 예를 들어, 다음의 URL은</p>

<pre><code class="language-url">hppts://bluefish.ics.cs.cmu.edu:8000/cgi-bin/adder?15000&amp;213
</code></pre>

<p>/cgi-bin/adder라는 실행파일을 식별하고, 이 파일은 두 개의 인자(15000과 213)와 함께 호출된다.</p>

<h3 id="동적-컨텐츠의-처리">동적 컨텐츠의 처리</h3>

<p>여기는 다시 한번 공부해보자.</p>

<h2 id="소형-웹-서버tiny-web-server">소형 웹 서버(Tiny web server)</h2>

<p>작은 웹 서버를 C와 html로 구현해보자</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* $begin tinymain */</span>
<span class="cm">/*
 * tiny.c - A simple, iterative HTTP/1.0 Web server that uses the
 *     GET method to serve static and dynamic content.
 *
 * Updated 11/2019 droh
 *   - Fixed sprintf() aliasing issue in serve_static(), and clienterror().
 */</span>
<span class="cp">#include</span> <span class="cpf">"csapp.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">read_requesthdrs</span><span class="p">(</span><span class="n">rio_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cgiargs</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">serve_static</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">filesize</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">get_filetype</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filetype</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">serve_dynamic</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cgiargs</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clienterror</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cause</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errnum</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">shortmsg</span><span class="p">,</span>
                 <span class="kt">char</span> <span class="o">*</span><span class="n">longmsg</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">hostname</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">port</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="n">socklen_t</span> <span class="n">clientlen</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">clientaddr</span><span class="p">;</span>

  <span class="cm">/* Check command line args */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Open_listenfd</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">clientlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">);</span>
    <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span>
                    <span class="o">&amp;</span><span class="n">clientlen</span><span class="p">);</span> <span class="c1">// line:netp:tiny:accept</span>
    <span class="n">Getnameinfo</span><span class="p">((</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="n">clientlen</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Accepted connection from (%s, %s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
    <span class="n">doit</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// line:netp:tiny:doit</span>
    <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span> <span class="c1">// line:netp:tiny:close</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span> <span class="c1">// fd : 클라이언트 소켓 파일 디스크립터(웹브라우저 연결)</span>
  <span class="c1">// 이 함수를 통해 요청을 읽고 응답을 보내는 한 사이클이 이루어짐.</span>

  <span class="c1">// 변수 선언</span>
  <span class="kt">int</span> <span class="n">is_static</span><span class="p">;</span>    <span class="c1">// 정적인 파일 요청인지 여부</span>
  <span class="k">struct</span> <span class="n">stat</span> <span class="n">sbuf</span><span class="p">;</span> <span class="c1">// stat()으로 얻는 파일 정보 구조체</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">method</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">uri</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">version</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="c1">// buf : 전체 요청 줄 저장</span>
  <span class="c1">//  method : GET, POST 같은 요청 방식</span>
  <span class="c1">//  uri : 요청된 자원경로 ex) index.html</span>
  <span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">cgiargs</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="c1">// filename : 실제 서버 상의 파일경로</span>
  <span class="c1">// cgiargs : CGI 프로그램에 넘길 인자</span>
  <span class="n">rio_t</span> <span class="n">rio</span><span class="p">;</span>

  <span class="c1">// 클라이언트 요청 한줄읽기</span>
  <span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
  <span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Request line: %s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="c1">// HTTP 요청의 첫줄은 이런 형태 : GET /index.html HTTP/1.1.</span>
  <span class="c1">// 이 줄을 buf에 저장한다.</span>

  <span class="c1">// 요청 파싱  파싱 : 어떤 문자열 데이터를 구조적으로 쪼개서 의미를 이해하는 과정</span>
  <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"%s %s %s"</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

  <span class="c1">// GET이외의 메서드는 거절한다</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">"GET"</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">clienterror</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="s">"501"</span><span class="p">,</span> <span class="s">"Not inplemented"</span><span class="p">,</span> <span class="s">"Tiny does not implement this method"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span> <span class="c1">// 대소문자 구분 없이 "GET"인지 확인, POST,PUT 등이 오면 501 에러 반환</span>

  <span class="c1">// 요청 헤더 읽기</span>
  <span class="n">read_requesthdrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio</span><span class="p">);</span> <span class="c1">// 나머지 요청 헤더들을 읽고 무시함</span>

  <span class="c1">// URI 파싱(정적VS동적)</span>
  <span class="n">is_static</span> <span class="o">=</span> <span class="n">parse_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">cgiargs</span><span class="p">);</span>
  <span class="c1">// ex) index,html -&gt; 정적 | cgi-bin/adder?arg1=1&amp;arg2=2 -&gt; 동적</span>
  <span class="c1">//  filename : 실제 서버 경로로 바뀜 | cgiargs : CGI 인자 저장</span>

  <span class="c1">// 파일 존재 확인</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbuf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">clienterror</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">"404"</span><span class="p">,</span> <span class="s">"Not found"</span><span class="p">,</span> <span class="s">"Tiny couldn't find this file"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span> <span class="c1">// 파일이 없으면 404 Not Found</span>
  <span class="p">}</span>
  <span class="c1">// 정적 파일 제공</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_static</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">sbuf</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">S_IRUSR</span> <span class="o">&amp;</span> <span class="n">sbuf</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">clienterror</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">"403"</span><span class="p">,</span> <span class="s">"Forbidden"</span><span class="p">,</span> <span class="s">"Tiny couldn't read the file"</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// 정적 파일이 일반 파일인지, 읽을 수 있는지 확인</span>
    <span class="p">}</span>
    <span class="n">serve_static</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">.</span><span class="n">st_size</span><span class="p">);</span>
    <span class="c1">// serve_static()으로 파일 전송</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span> <span class="c1">// CGI 프로그램 실행</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">sbuf</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">S_IXUSR</span> <span class="o">&amp;</span> <span class="n">sbuf</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">clienterror</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">"403"</span><span class="p">,</span> <span class="s">"Forbidden"</span><span class="p">,</span> <span class="s">"Tiny couldn't run the CGI program"</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// 실행 가능한 CGI 프로그램인지 확인</span>
    <span class="p">}</span>
    <span class="n">serve_dynamic</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">cgiargs</span><span class="p">);</span>
    <span class="c1">// serve_dynamic()으로 CGI 실행 후 결과 전송</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 함수 헤더 ,이 함수는 에러 응답을 만드는 데 필요한 모든 정보를 받아서 사용한다.</span>
<span class="kt">void</span> <span class="nf">clienterror</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cause</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errnum</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">shortmsg</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">longmsg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// fd:클라이언트와 연결된 소켓, cause:에러 원인 ex파일이름 , errnum : 상태코드 ex)404</span>
  <span class="c1">// shortmsg:짧은 설명 ex)Not Found , longmsg : 긴 설명 ex) Tiny couldn't find this file</span>
  <span class="c1">//  이 함수는 에러 응답을 만드는 데 필요한 모든 정보를 받아서 사용한다.</span>

  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">body</span><span class="p">[</span><span class="n">MAXBUF</span><span class="p">];</span>
  <span class="c1">// buf : HTTP 헤더를 담는 용도 | body : HTML 본문(에러 메세지 페이지)</span>

  <span class="c1">// HTML 본문(body) 작성</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s">"&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;"</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s">"%s&lt;body bgcolor=</span><span class="se">\"</span><span class="s">ffffff</span><span class="se">\"</span><span class="s">&gt;</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s">"%s%s: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">errnum</span><span class="p">,</span> <span class="n">shortmsg</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s">"%s&lt;p&gt;%s: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">longmsg</span><span class="p">,</span> <span class="n">cause</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s">"%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>
  <span class="c1">// HTML 페이지를 한 줄씩 누적해서 작성</span>

  <span class="c1">// HTTP헤더와 본문을 출력</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"HTTP/1.0 %s %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errnum</span><span class="p">,</span> <span class="n">shortmsg</span><span class="p">);</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
  <span class="c1">// HTTP/1.0 404 Not Found 같은 상태 줄 출력</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Content-type: text/html</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
  <span class="c1">// Content-type은 text/html(브라우저가 HTML로 렌더링 하도록)</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Content-length: %d</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">body</span><span class="p">));</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
  <span class="c1">// Content-length는 본문 길이</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">body</span><span class="p">));</span>
  <span class="c1">// 마지막에 실제 HTML 본물 출력</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">read_requesthdrs</span><span class="p">(</span><span class="n">rio_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//	•	rp: robust I/O 구조체 포인터 (Rio_readlineb 사용을 위한 스트림)</span>
  <span class="c1">//  •	역할: HTTP 요청 헤더를 한 줄씩 읽다가 빈 줄 "\r\n"이 나오면 멈춰.</span>
  <span class="c1">//  •	이유: HTTP 요청 헤더는 빈 줄로 끝난다는 규칙이 있기 때문.</span>

  <span class="c1">// 버퍼 선언</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

  <span class="c1">// 첫번째 줄 읽기</span>
  <span class="n">Rio_readlineb</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span>

  <span class="c1">// 빈 줄까지 반복해서 읽기</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span><span class="p">))</span>
  <span class="p">{</span>                                  <span class="c1">// 지금 읽은 줄이 빈 줄인지 확인</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Header: %s"</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>
    <span class="n">Rio_readlineb</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span> <span class="c1">// 빈줄(\r\n)이 나오기 전까지 계속 읽고 출력</span>
    <span class="c1">//printf("%s", buf);               // 헤더의 끝 줄은 빈 줄로 표시되므로 이 조건으로 반복 종료</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cgiargs</span><span class="p">)</span>
<span class="p">{</span> <span class="c1">// 요청된 URI가 정적인지(dynamic인지) 판단하고,해당하는 파일 이름과 CGI 인자를 추출</span>
  <span class="c1">//	•	uri: 클라이언트가 요청한 경로 (예: /index.html, /cgi-bin/adder?x=1&amp;y=2)</span>
  <span class="c1">//  •	filename: 실제 서버 파일 경로로 변환되어 담길 곳</span>
  <span class="c1">//  •	cgiargs: CGI 인자 문자열이 담길 곳</span>
  <span class="c1">//  •	리턴값:</span>
  <span class="c1">//    •	1이면 정적(static) 콘텐츠</span>
  <span class="c1">//    •	0이면 동적(dynamic) 콘텐츠</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strstr</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="s">"cgi-bin"</span><span class="p">))</span>
  <span class="p">{</span> <span class="c1">// 정적 콘텐츠라면</span>
    <span class="c1">//  •	strstr(uri, "cgi-bin")ㄹ이 NULL이면, "cgi-bin"이 없다는 뜻 → 정적 콘텐츠</span>
    <span class="c1">//  •	예: /index.html, /images/logo.png 등</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">cgiargs</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>             <span class="c1">// CGI 인자는 없음</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"."</span><span class="p">);</span>           <span class="c1">// 현재 디렉터리 기준 시작</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>           <span class="c1">// 파일 경로 완성</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uri</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span> <span class="c1">// URI가 폴더로 끝나면</span>
      <span class="n">strcat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"home.html"</span><span class="p">);</span> <span class="c1">// 기본 파일로 home.html 사용</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>                        <span class="c1">// 정적 콘텐츠임을 반환</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">index</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="sc">'?'</span><span class="p">);</span> <span class="c1">// '?' 위치 찾기 (cgi 인자 구분자)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="p">{</span>                           <span class="c1">// 인자가 있는 경우</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">cgiargs</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// ? 뒤 내용 복사</span>
      <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>              <span class="c1">// ? 기준으로 문자열 자르기</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">cgiargs</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span> <span class="c1">// 인자 없음</span>
    <span class="p">}</span>

    <span class="n">strcpy</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"."</span><span class="p">);</span> <span class="c1">// 경로 시작</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span> <span class="c1">// 파일 경로 완성</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>              <span class="c1">// 동적 콘텐츠임을 반환</span>
  <span class="p">}</span>
  <span class="cm">/*어떤 친구가 웹서버에 와서 무언가를 요청했어.
    •	요청 주소에 "cgi-bin"이 없으면 "파일 보여달라"는 거고,
    •	있으면 "계산 좀 해줘"라는 뜻이야.

  그래서 서버는 이렇게 판단해:
    •	"정적이면, 파일 경로만 만들어주고"
    •	"동적이면, 실행파일이랑 인자도 준비해!"*/</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">serve_static</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">filesize</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 정적인 파일(HTML, 이미지 등)을 클라이언트에게 보내는 핵심 함수</span>
  <span class="cm">/*•	fd: 클라이언트와 연결된 소켓
    •	filename: 클라이언트가 요청한 파일 이름
    •	filesize: 파일 크기 (이미 stat으로 구했음)  */</span>

  <span class="c1">// 변수 선언</span>
  <span class="kt">int</span> <span class="n">srcfd</span><span class="p">;</span>                                  <span class="c1">// 파일 디스크립터</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="n">filetype</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXBUF</span><span class="p">];</span> <span class="c1">// srcp:메모리에 매핑된 파일 주소</span>
  <span class="c1">// filetype : MIME 타입 저장할 버퍼 , buf : 응답 헤더 저장용</span>

  <span class="n">get_filetype</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">filetype</span><span class="p">);</span> <span class="c1">// MIME 타입 결정</span>
  <span class="c1">// •	filetype에 따라 브라우저가 어떻게 해석할지 결정됨 (text/html, image/jpeg 등)</span>

  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"HTTP/1.0 200 OK</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"Server: Tiny Web Server</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"Connection: close</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"Content-length: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">filesize</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"Content-type: %s</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">filetype</span><span class="p">);</span>
  <span class="c1">//	마지막 줄에 빈 줄 \r\n\r\n은 본문 시작을 알리는 신호</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span> <span class="c1">// 클라이언트로 헤더 전송</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Response headers:</span><span class="se">\n</span><span class="s">%s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

  <span class="n">srcfd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                        <span class="c1">// 파일 열기</span>
  <span class="n">srcp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">filesize</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">srcp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Close</span><span class="p">(</span><span class="n">srcfd</span><span class="p">);</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error: malloc failed for file %s (size: %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">filesize</span><span class="p">);</span>

      <span class="c1">// 클라이언트에 HTTP 500 오류 응답 전송</span>
      <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"HTTP/1.0 500 Internal Server Error</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"Content-type: text/html</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"&lt;html&gt;&lt;body&gt;&lt;p&gt;Server error: memory allocation failed.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0); // 파일을 메모리에 매핑</span>

  <span class="n">Rio_readn</span><span class="p">(</span><span class="n">srcfd</span><span class="p">,</span><span class="n">srcp</span><span class="p">,</span><span class="n">filesize</span><span class="p">);</span>
  <span class="c1">// Mmap : 파일을 메모리에 통째로 올림(성능 좋고 코드 간결함)</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">srcfd</span><span class="p">);</span> <span class="c1">// 파일 디스크립터는 닫아도 메모리엔 살아있음</span>

  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">srcp</span><span class="p">,</span> <span class="n">filesize</span><span class="p">);</span> <span class="c1">// 파일 내용을 클라이언트로 전송</span>
  <span class="n">free</span><span class="p">(</span><span class="n">srcp</span><span class="p">);</span>
  <span class="c1">//Munmap(srcp, filesize);         // 메모리 해제, 매핑 해제</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">get_filetype</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filetype</span><span class="p">)</span>
<span class="c1">//  •	확장자를 보고 MIME 타입 결정</span>
<span class="c1">//  •	브라우저가 어떻게 렌더링할지를 결정하는 중요한 역할</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".html"</span><span class="p">))</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"text/html"</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".gif"</span><span class="p">))</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"image/gif"</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".mpg"</span><span class="p">))</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"video/mp4"</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".png"</span><span class="p">))</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"image/png"</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".jpg"</span><span class="p">))</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"image/jpeg"</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"text/plain"</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">serve_dynamic</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cgiargs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//  •	fd: 클라이언트와 연결된 소켓</span>
  <span class="c1">//  •	filename: 실행할 CGI 프로그램 경로 (예: ./cgi-bin/adder)</span>
  <span class="c1">//  •	cgiargs: CGI 프로그램에 넘겨줄 인자 (예: x=1&amp;y=2)</span>

  <span class="c1">// 버퍼와 exec 인자 준비</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="o">*</span><span class="n">emptylist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
  <span class="c1">// buf : HTTP 헤더를 담을 임시 버퍼 | emptylist:execve()함수에서 사용할 프로그램 인자 리스트(여기선없대)</span>

  <span class="c1">// HTTP 응답 헤더 전송</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"HTTP/1.0 200 OK</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
  <span class="c1">// CGI 프로그램을 실행하기 전에 최소한의 응답 헤더를 먼저 전송</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Server: Tiny Web Server</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
  <span class="c1">// 이후에 실제 프로그램의 출력 stdout이 이어짐</span>

  <span class="c1">// 자식 프로세스 생성 후 CGI 실행</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>  <span class="c1">// 자식 프로세스 | fork()로 새 프로세스를 생성</span>
    <span class="n">setenv</span><span class="p">(</span><span class="s">"QUERY_STRING"</span><span class="p">,</span> <span class="n">cgiargs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>   <span class="c1">// 환경 변수 설정 (인자 전달) | adder.c에서 사용하는 getenv("QUERY_STRING")가능하게 설정</span>
    <span class="n">Dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">STDOUT_FILENO</span><span class="p">);</span>              <span class="c1">// Dup2()를 통해 stdout을 클라이언트 소켓으로 리다이렉션</span>
    <span class="n">Execve</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">emptylist</span><span class="p">,</span> <span class="n">environ</span><span class="p">);</span> <span class="c1">// Execve()로 CGI 실행 (출력은 fd로 감) , 실행되면 그 아래 코드는 실행 안됨</span>
  <span class="p">}</span>
  <span class="n">Wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="c1">//부모 프로세스는 자식이 끝날 때 까지 기다림(좀비 프로세스 방지)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;&lt;title&gt;</span>test<span class="nt">&lt;/title&gt;&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span> 
<span class="nt">&lt;img</span> <span class="na">align=</span><span class="s">"middle"</span> <span class="na">src=</span><span class="s">"godzilla.gif"</span><span class="nt">&gt;</span>
<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;br&gt;</span>
Dave O'Hallaron
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>

</code></pre></div></div>

<p>이렇게 구현하라고 책에 나와 있었고 여기에 동영상 파일을 넣으라는 과제가 있어서 진행했다. 바뀐 부분은 아래와 같다.</p>

<p>tiny.c 파일에 아래와 같은 코드를 추가하고</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"video/mp4"</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".png"</span><span class="p">))</span>
</code></pre></div></div>

<p>html 파일에는 아래와 같은 코드와 videoplayback.mp4파일을 디렉토리에 저장했다.</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;video</span> <span class="na">width=</span><span class="s">"320"</span> <span class="na">height=</span><span class="s">"240"</span> <span class="na">controls</span><span class="nt">&gt;</span>
  <span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">"videoplayback.mp4"</span> <span class="na">type=</span><span class="s">"video/mp4"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<h2 id="소형-웹-서버tiny-web-server--프록시-서버">소형 웹 서버(Tiny web server) + 프록시 서버</h2>

<p>Tiny 서버 구현 후 프록시 서버도 구현하라는 과제가 주어졌어서, 프록시에 대한 개념을 먼저 알아보았다.</p>

<h3 id="웹-프록시란">웹 프록시란?</h3>

<p>웹 브라우저와 웹 서버 사이에 중간자 역할을 하는 프로그램이다. 브라우저는 직접 서버에 요청하지 않고, 프록시 서버에 요청을 보낸다. 프록시는 그 요청을 웹 서버로 전달하고, 받은 응답을 다시 브라우저에게 돌려주며 마무리.</p>

<h2 id="프록시-서버">프록시 서버</h2>

<p>프록시 서버에서 사용할 코드는 아래와 같이 나왔다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"csapp.h"</span><span class="cp">
</span>
<span class="cp">#define MAX_CACHE_SIZE 1049000
#define MAX_OBJECT_SIZE 102400
</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">user_agent_hdr</span> <span class="o">=</span>
    <span class="s">"User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 "</span>
    <span class="s">"Firefox/10.0.3</span><span class="se">\r\n</span><span class="s">"</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">connfd</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">build_http_header</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">http_header</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
    <span class="n">socklen_t</span> <span class="n">clientlen</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">clientaddr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">port</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">host</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Open_listenfd</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clientlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">);</span>
        <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clientlen</span><span class="p">);</span>
        <span class="n">Getnameinfo</span><span class="p">((</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="n">clientlen</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Accepted connection from (%s, %s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
        <span class="n">doit</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
        <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">connfd</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">method</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">uri</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">version</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">hostname</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">port</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">http_header</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
    <span class="n">rio_t</span> <span class="n">rio_client</span><span class="p">,</span> <span class="n">rio_server</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">serverfd</span><span class="p">;</span>

    <span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_client</span><span class="p">,</span> <span class="n">connfd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"%s %s %s"</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

    <span class="c1">// URI 앞 '/' 제거 ("/http://..." → "http://...")</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span>
        <span class="n">memmove</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">uri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">uri</span><span class="p">));</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Received URI: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">"GET"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Proxy does not implement the method %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">method</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">parse_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"URI parsing failed: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">build_http_header</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
    <span class="n">serverfd</span> <span class="o">=</span> <span class="n">Open_clientfd</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">serverfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Connection to server %s:%s failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_server</span><span class="p">,</span> <span class="n">serverfd</span><span class="p">);</span>
    <span class="n">Rio_writen</span><span class="p">(</span><span class="n">serverfd</span><span class="p">,</span> <span class="n">http_header</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">http_header</span><span class="p">));</span>

    <span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_server</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Rio_writen</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Close</span><span class="p">(</span><span class="n">serverfd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">hostbegin</span><span class="p">,</span> <span class="o">*</span><span class="n">pathbegin</span><span class="p">,</span> <span class="o">*</span><span class="n">portpos</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="s">"http://"</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="n">hostbegin</span> <span class="o">=</span> <span class="n">uri</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>
  <span class="n">pathbegin</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">hostbegin</span><span class="p">,</span> <span class="sc">'/'</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pathbegin</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pathbegin</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"/"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 이제 host:port만 분리할 수 있게 별도로 복사해놓자</span>
  <span class="kt">char</span> <span class="n">hostcopy</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pathbegin</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">pathbegin</span> <span class="o">-</span> <span class="n">hostbegin</span><span class="p">;</span>
      <span class="n">strncpy</span><span class="p">(</span><span class="n">hostcopy</span><span class="p">,</span> <span class="n">hostbegin</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
      <span class="n">hostcopy</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">hostcopy</span><span class="p">,</span> <span class="n">hostbegin</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">portpos</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">hostcopy</span><span class="p">,</span> <span class="sc">':'</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">portpos</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">portpos</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">hostcopy</span><span class="p">);</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">portpos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">hostcopy</span><span class="p">);</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="s">"80"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">build_http_header</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">http_header</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"GET %s HTTP/1.0</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Host: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="n">user_agent_hdr</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"Connection: close</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"Proxy-Connection: close</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이거는 시행착오를 겪으며 나온 코드이다. 이거를 구현하기 위해서 AWS EC2 instance 2개를 만들었고, 하나는 tiny server 그리고 하나는 proxy server로 만들었다. 내 컴퓨터로는 client로 사용을 했다. 아래 사진으로 proxy server와 main server가 연결된것을 확인할 수 있다.</p>

<p><img src="/assets/img/blog/computerscience/proxytinyconnected.png" alt="프록시 서버와 메인 서버 연결" /></p>

<p>다만 아쉬웠던 점이 하나 있었다. 이렇게 구현을 하면 아래 사진과 같이 메인서버의 주소를 URI로써 넣어줘야 했다.</p>

<p><img src="/assets/img/blog/computerscience/mainserveruri.png" alt="메인 서버 URI" /></p>

<p>이렇게 되면, 프록시로써의 기능이 없는거 아닌가? 라는 생각을 했고 그걸 바꾸고 싶었다. 그래서 doit함수에서 아래부분을,</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">parse_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"URI parsing failed: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>아래와 같이 바꾸었다. 이미 AWS EC2 instance를 만들었기 때문에, IP 주소에 대한 정보는 있는 상태였다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 고정된 최종 서버 정보</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="s">"15.164.219.65"</span><span class="p">);</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="s">"8080"</span><span class="p">);</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>  <span class="c1">// 예: "/home.html", "/godzilla.jpg"</span>
</code></pre></div></div>

<p>이렇게 진행을 해서 아래 사진과 같이 프록시로써의 기능을 충분히 하는것을 확인하였다.</p>

<p><img src="/assets/img/blog/computerscience/afterdoitrevision.png" alt="doit함수 수정 후" /></p>

<h2 id="프록시-서버-쓰레딩과-캐싱-기능-추가">프록시 서버 쓰레딩과 캐싱 기능 추가</h2>

<p>팀원들과 같이 쓰레딩과 캐싱 기능도 추가하였는데, 완성 코드는 아래와 같다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"csapp.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="c1">  /* ULONG_MAX 정의를 위해 추가 */</span><span class="cp">
</span>
<span class="cp">#define MAX_CACHE_SIZE 1049000
#define MAX_OBJECT_SIZE 102400
</span>
<span class="cm">/* 캐시 구조체 및 관련 데이터 정의 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">;</span>          <span class="cm">/* 캐시된 URL */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">content</span><span class="p">;</span>      <span class="cm">/* 캐시된 웹 객체 내용 */</span>
    <span class="kt">size_t</span> <span class="n">content_size</span><span class="p">;</span> <span class="cm">/* 객체 크기 */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="p">;</span> <span class="cm">/* LRU를 위한 타임스탬프 */</span>
    <span class="kt">int</span> <span class="n">is_valid</span><span class="p">;</span>       <span class="cm">/* 유효한 캐시 항목인지 여부 */</span>
    <span class="kt">int</span> <span class="n">readers</span><span class="p">;</span>        <span class="cm">/* 현재 읽고 있는 스레드 수 */</span>
    <span class="n">pthread_rwlock_t</span> <span class="n">rwlock</span><span class="p">;</span> <span class="cm">/* 읽기/쓰기 락 */</span>
<span class="p">}</span> <span class="n">cache_entry_t</span><span class="p">;</span>

<span class="cm">/* 캐시 구조체 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">cache_entry_t</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span> <span class="cm">/* 캐시 항목 배열 */</span>
    <span class="kt">int</span> <span class="n">num_entries</span><span class="p">;</span>       <span class="cm">/* 총 항목 수 */</span>
    <span class="kt">int</span> <span class="n">max_entries</span><span class="p">;</span>       <span class="cm">/* 최대 허용 항목 수 */</span>
    <span class="kt">size_t</span> <span class="n">current_size</span><span class="p">;</span>   <span class="cm">/* 현재 캐시 크기 (바이트) */</span>
    <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span> <span class="cm">/* 캐시 전체 락 */</span>
<span class="p">}</span> <span class="n">cache_t</span><span class="p">;</span>

<span class="cm">/* 전역 캐시 변수 */</span>
<span class="n">cache_t</span> <span class="n">cache</span><span class="p">;</span>

<span class="cm">/* 스레드 함수 인자를 위한 구조체 정의 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
<span class="p">}</span> <span class="n">thread_args</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">user_agent_hdr</span> <span class="o">=</span>
    <span class="s">"User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 "</span>
    <span class="s">"Firefox/10.0.3</span><span class="se">\r\n</span><span class="s">"</span><span class="p">;</span>

<span class="cm">/* 함수 프로토타입 */</span>
<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">connfd</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">build_http_header</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">http_header</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vargp</span><span class="p">);</span>

<span class="cm">/* 캐시 관련 함수 프로토타입 */</span>
<span class="kt">void</span> <span class="nf">cache_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">max_entries</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">cache_free</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">cache_entry_t</span> <span class="o">*</span><span class="nf">cache_find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">cache_add</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">content</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">content_size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">cache_evict_lru</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">required_size</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_timestamp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
    <span class="n">socklen_t</span> <span class="n">clientlen</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">clientaddr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">port</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">host</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
    <span class="n">thread_args</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// SIGPIPE 신호 무시 설정 (연결이 끊어진 소켓에 쓰기 시도할 때 발생)</span>
    <span class="n">Signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
    
    <span class="c1">// 캐시 초기화 (MAX_CACHE_SIZE / MAX_OBJECT_SIZE 객체의 10배)</span>
    <span class="n">cache_init</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Cache initialized with max size %d bytes</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">MAX_CACHE_SIZE</span><span class="p">);</span>

    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Open_listenfd</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clientlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">);</span>
        <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clientlen</span><span class="p">);</span>
        <span class="n">Getnameinfo</span><span class="p">((</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="n">clientlen</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Accepted connection from (%s, %s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
        
        <span class="c1">// 스레드 인자 구조체 할당</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">thread_args</span> <span class="o">*</span><span class="p">)</span><span class="n">Malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">thread_args</span><span class="p">));</span>
        <span class="n">args</span><span class="o">-&gt;</span><span class="n">connfd</span> <span class="o">=</span> <span class="n">connfd</span><span class="p">;</span>
        
        <span class="c1">// 새 스레드 생성하여 클라이언트 요청 처리</span>
        <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
        <span class="c1">// 메인 스레드는 바로 다음 연결을 기다림 (connfd를 닫지 않음)</span>
    <span class="p">}</span>
    
    <span class="c1">// 여기에 도달하지 않지만 안전을 위해 추가</span>
    <span class="n">cache_free</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">connfd</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">method</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">uri</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">version</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">hostname</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">port</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="n">rio_t</span> <span class="n">rio_client</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">serverfd</span><span class="p">;</span>

  <span class="c1">// 클라이언트 요청 라인 읽기</span>
  <span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_client</span><span class="p">,</span> <span class="n">connfd</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Request line: %s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

  <span class="c1">// 요청 라인 파싱</span>
  <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"%s %s %s"</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

  <span class="c1">// GET 요청만 처리</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">"GET"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Proxy does not implement the method %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">method</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// URI 파싱하여 hostname, path, port 추출</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">parse_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"URI parsing failed: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// 전체 URL을 캐시 키로 사용</span>
  <span class="kt">char</span> <span class="n">url_key</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">url_key</span><span class="p">,</span> <span class="s">"http://%s:%s%s"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
  
  <span class="c1">// 캐시에서 URL 검색</span>
  <span class="n">cache_entry_t</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">cache_find</span><span class="p">(</span><span class="n">url_key</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 캐시 히트: 캐시된 내용을 클라이언트에게 전송</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Cache hit for %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">url_key</span><span class="p">);</span>
      <span class="n">Rio_writen</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">content_size</span><span class="p">);</span>
      <span class="n">cache_read_complete</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// 캐시 미스: 서버에 요청</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Cache miss for %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">url_key</span><span class="p">);</span>
  
  <span class="c1">// 서버 연결</span>
  <span class="n">serverfd</span> <span class="o">=</span> <span class="n">Open_clientfd</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">serverfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Connection to server %s:%s failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// 서버에 보낼 HTTP 요청 헤더 작성</span>
  <span class="kt">char</span> <span class="n">request_hdrs</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">host_hdr</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">other_hdrs</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="s">"GET %s HTTP/1.0</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
  
  <span class="c1">// 클라이언트 헤더 읽기 및 필요한 헤더 수정 또는 추가</span>
  <span class="kt">int</span> <span class="n">is_host_hdr_seen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">other_hdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
  
  <span class="k">while</span> <span class="p">(</span><span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 헤더의 끝 확인 (빈 줄)</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
      
      <span class="c1">// Host 헤더 확인</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Host:"</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">is_host_hdr_seen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">strcpy</span><span class="p">(</span><span class="n">host_hdr</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// Connection 또는 Proxy-Connection 헤더는 건너뜀</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Connection:"</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span> <span class="o">||</span> 
               <span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Proxy-Connection:"</span><span class="p">,</span> <span class="mi">17</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// User-Agent 헤더는 건너뜀 (나중에 추가됨)</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"User-Agent:"</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// 그 외 헤더는 그대로 전달</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="n">strcat</span><span class="p">(</span><span class="n">other_hdrs</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// HTTP 요청 헤더 완성</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_host_hdr_seen</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">sprintf</span><span class="p">(</span><span class="n">host_hdr</span><span class="p">,</span> <span class="s">"Host: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="c1">// 최종 HTTP 요청 헤더 조합</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="n">host_hdr</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="n">user_agent_hdr</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="s">"Connection: close</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="s">"Proxy-Connection: close</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="n">other_hdrs</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>  <span class="c1">// 헤더의 끝</span>
  
  <span class="n">printf</span><span class="p">(</span><span class="s">"Forwarding request to server %s:%s</span><span class="se">\n</span><span class="s">%s"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">request_hdrs</span><span class="p">);</span>
  
  <span class="c1">// 서버에 요청 전송</span>
  <span class="n">rio_t</span> <span class="n">rio_server</span><span class="p">;</span>
  <span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_server</span><span class="p">,</span> <span class="n">serverfd</span><span class="p">);</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">serverfd</span><span class="p">,</span> <span class="n">request_hdrs</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">));</span>
  
  <span class="c1">// 서버로부터 응답을 받아 클라이언트에게 전달하고 캐싱</span>
  <span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">cache_buf</span><span class="p">[</span><span class="n">MAX_OBJECT_SIZE</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">cacheable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 객체가 캐시 가능한지 여부</span>
  
  <span class="c1">// 응답을 버퍼 단위로 읽어 전달</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">Rio_readnb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_server</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 클라이언트에게 전송</span>
      <span class="n">Rio_writen</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
      
      <span class="c1">// 캐시 가능한 크기이면 응답을 캐시 버퍼에 저장</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cacheable</span> <span class="o">&amp;&amp;</span> <span class="n">total_size</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">MAX_OBJECT_SIZE</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">memcpy</span><span class="p">(</span><span class="n">cache_buf</span> <span class="o">+</span> <span class="n">total_size</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
          <span class="n">total_size</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">total_size</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">MAX_OBJECT_SIZE</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">cacheable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 최대 객체 크기를 초과하여 캐시 불가능</span>
      <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// 모든 응답을 받았으면 캐시에 저장</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cacheable</span> <span class="o">&amp;&amp;</span> <span class="n">total_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cache_add</span><span class="p">(</span><span class="n">url_key</span><span class="p">,</span> <span class="n">cache_buf</span><span class="p">,</span> <span class="n">total_size</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Cached %zu bytes for %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total_size</span><span class="p">,</span> <span class="n">url_key</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="n">Close</span><span class="p">(</span><span class="n">serverfd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">hostbegin</span><span class="p">,</span> <span class="o">*</span><span class="n">hostend</span><span class="p">,</span> <span class="o">*</span><span class="n">pathbegin</span><span class="p">;</span>
    
    <span class="c1">// URI에 http:// 접두사가 없는 경우 (driver.sh는 완전한 URL을 요구함)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="s">"http://"</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 이미 경로만 있는 경우 (예: /home.html)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// localhost로 간주하고 기본 경로 사용</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="s">"localhost"</span><span class="p">);</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="s">"80"</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error: Invalid URI format (no http://): %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// http:// 이후의 호스트 시작 위치</span>
    <span class="n">hostbegin</span> <span class="o">=</span> <span class="n">uri</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>
    
    <span class="c1">// 경로 부분 찾기 (첫 번째 '/')</span>
    <span class="n">pathbegin</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">hostbegin</span><span class="p">,</span> <span class="sc">'/'</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">pathbegin</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 호스트 부분의 마지막 위치</span>
        <span class="n">hostend</span> <span class="o">=</span> <span class="n">pathbegin</span><span class="p">;</span>
        <span class="c1">// 경로 복사</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pathbegin</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 경로가 없으면 루트 경로로 설정</span>
        <span class="n">hostend</span> <span class="o">=</span> <span class="n">hostbegin</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">hostbegin</span><span class="p">);</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"/"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 임시 호스트 문자열 생성 및 복사</span>
    <span class="kt">char</span> <span class="n">hostcopy</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">hostcopy</span><span class="p">,</span> <span class="n">hostbegin</span><span class="p">,</span> <span class="n">hostend</span> <span class="o">-</span> <span class="n">hostbegin</span><span class="p">);</span>
    <span class="n">hostcopy</span><span class="p">[</span><span class="n">hostend</span> <span class="o">-</span> <span class="n">hostbegin</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

    <span class="c1">// 호스트에서 포트 번호 분리</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">portPos</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">hostcopy</span><span class="p">,</span> <span class="sc">':'</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">portPos</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">portPos</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">hostcopy</span><span class="p">);</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">portPos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">hostcopy</span><span class="p">);</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="s">"80"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Parsed URI - Host: '%s', Path: '%s', Port: '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">build_http_header</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">http_header</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"GET %s HTTP/1.0</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Host: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="n">user_agent_hdr</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"Connection: close</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"Proxy-Connection: close</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 스레드 함수 구현 */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vargp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">thread_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">thread_args</span> <span class="o">*</span><span class="p">)</span><span class="n">vargp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">connfd</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">connfd</span><span class="p">;</span>
    
    <span class="c1">// 스레드를 detach 상태로 만들어 자원을 자동으로 반환하도록 함</span>
    <span class="n">Pthread_detach</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">());</span>
    
    <span class="c1">// 메모리 누수 방지를 위해 할당된 인자 구조체 해제</span>
    <span class="n">Free</span><span class="p">(</span><span class="n">vargp</span><span class="p">);</span>
    
    <span class="c1">// 클라이언트 요청 처리</span>
    <span class="n">doit</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
    
    <span class="c1">// 연결 종료</span>
    <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 캐시 초기화 함수 */</span>
<span class="kt">void</span> <span class="nf">cache_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">max_entries</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">cache_entry_t</span> <span class="o">*</span><span class="p">)</span><span class="n">Calloc</span><span class="p">(</span><span class="n">max_entries</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cache_entry_t</span><span class="p">));</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">num_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span> <span class="o">=</span> <span class="n">max_entries</span><span class="p">;</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">current_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">url</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">content</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">content_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">readers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">pthread_rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rwlock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 캐시 해제 함수 */</span>
<span class="kt">void</span> <span class="nf">cache_free</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_valid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Free</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">url</span><span class="p">);</span>
            <span class="n">Free</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">content</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">pthread_rwlock_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Free</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 현재 시간 반환 */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_timestamp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000000</span> <span class="o">+</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 캐시에서 URL에 해당하는 항목 찾기 */</span>
<span class="n">cache_entry_t</span> <span class="o">*</span><span class="nf">cache_find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_valid</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">url</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 읽기 락 획득</span>
            <span class="n">pthread_rwlock_rdlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
            <span class="c1">// 타임스탬프 갱신</span>
            <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">get_timestamp</span><span class="p">();</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 캐시 항목 읽기 완료 */</span>
<span class="kt">void</span> <span class="nf">cache_read_complete</span><span class="p">(</span><span class="n">cache_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rwlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* LRU 정책에 따라 캐시에서 항목 제거 */</span>
<span class="kt">void</span> <span class="nf">cache_evict_lru</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">required_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_timestamp</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lru_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 가장 오래 사용되지 않은 항목 찾기</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_valid</span> <span class="o">&amp;&amp;</span> <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">&lt;</span> <span class="n">min_timestamp</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">min_timestamp</span> <span class="o">=</span> <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">timestamp</span><span class="p">;</span>
            <span class="n">lru_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">lru_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 쓰기 락 획득</span>
        <span class="n">pthread_rwlock_wrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
        
        <span class="c1">// 해당 항목의 메모리 해제</span>
        <span class="n">Free</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">url</span><span class="p">);</span>
        <span class="n">Free</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">content</span><span class="p">);</span>
        
        <span class="c1">// 캐시 항목 무효화</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">url</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">content</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">is_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="c1">// 캐시 크기 갱신</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">current_size</span> <span class="o">-=</span> <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">content_size</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">num_entries</span><span class="o">--</span><span class="p">;</span>
        
        <span class="c1">// 쓰기 락 해제</span>
        <span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 캐시에 새로운 항목 추가 */</span>
<span class="kt">void</span> <span class="nf">cache_add</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">content</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">content_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">content_size</span> <span class="o">&gt;</span> <span class="n">MAX_OBJECT_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span> <span class="c1">// 최대 객체 크기 초과하면 캐시하지 않음</span>
    <span class="p">}</span>

    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="c1">// 필요한 경우 공간 확보</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">current_size</span> <span class="o">+</span> <span class="n">content_size</span> <span class="o">&gt;</span> <span class="n">MAX_CACHE_SIZE</span> <span class="o">||</span> <span class="n">cache</span><span class="p">.</span><span class="n">num_entries</span> <span class="o">&gt;=</span> <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cache_evict_lru</span><span class="p">(</span><span class="n">content_size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 빈 슬롯 찾기</span>
    <span class="kt">int</span> <span class="n">empty_slot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_valid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">empty_slot</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">empty_slot</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span> <span class="c1">// 빈 슬롯이 없음</span>
    <span class="p">}</span>

    <span class="c1">// 쓰기 락 획득</span>
    <span class="n">pthread_rwlock_wrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
    
    <span class="c1">// 새 항목 초기화</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">url</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">content</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">content_size</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">content</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">content_size</span><span class="p">);</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">content_size</span> <span class="o">=</span> <span class="n">content_size</span><span class="p">;</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">get_timestamp</span><span class="p">();</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">is_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="c1">// 캐시 상태 갱신</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">current_size</span> <span class="o">+=</span> <span class="n">content_size</span><span class="p">;</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">num_entries</span><span class="o">++</span><span class="p">;</span>
    
    <span class="c1">// 쓰기 락 해제</span>
    <span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[우리가 웹을 검색하고, 이메일 메시지를 보내고, 온라인 게임을 하는 등의 모든 경우 우리는 네트워크 응용을 사용한다]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">8주차 퀴즈</title><link href="/blog/algorithm/8th-week/" rel="alternate" type="text/html" title="8주차 퀴즈" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>/blog/algorithm/8th-week</id><content type="html" xml:base="/blog/algorithm/8th-week/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#8주차-퀴즈" id="markdown-toc-8주차-퀴즈">8주차 퀴즈</a>    <ul>
      <li><a href="#1-http-get-요청과-post-요청의-가장-큰-차이점은-무엇이며-이것이-요청-헤더나-데이터-전송에-어떤-영향을-미칩니까-1점" id="markdown-toc-1-http-get-요청과-post-요청의-가장-큰-차이점은-무엇이며-이것이-요청-헤더나-데이터-전송에-어떤-영향을-미칩니까-1점">1. HTTP GET 요청과 POST 요청의 가장 큰 차이점은 무엇이며, 이것이 요청 헤더나 데이터 전송에 어떤 영향을 미칩니까? (1점)</a></li>
      <li><a href="#2-http-응답-코드-404의-의미는-무엇입니까-그리고-서버가-요청을-처리할-수-없을-때-반환하는-http-상태-코드는-무엇입니까-1점" id="markdown-toc-2-http-응답-코드-404의-의미는-무엇입니까-그리고-서버가-요청을-처리할-수-없을-때-반환하는-http-상태-코드는-무엇입니까-1점">2. HTTP 응답 코드 404의 의미는 무엇입니까? 그리고 서버가 요청을 처리할 수 없을 때 반환하는 HTTP 상태 코드는 무엇입니까? (1점)</a></li>
      <li><a href="#3-파일-디스크립터file-descriptor란-무엇인지-간단히-설명하고-unixlinux-시스템에서-표준-입출력에러의-파일-디스크립터-번호를-쓰세요-1점" id="markdown-toc-3-파일-디스크립터file-descriptor란-무엇인지-간단히-설명하고-unixlinux-시스템에서-표준-입출력에러의-파일-디스크립터-번호를-쓰세요-1점">3. 파일 디스크립터(File Descriptor)란 무엇인지 간단히 설명하고 UNIX/Linux 시스템에서 표준 입출력/에러의 파일 디스크립터 번호를 쓰세요. (1점)</a></li>
      <li><a href="#4-tcp에서의-3-way-handshake-절차를-설명하세요-1점" id="markdown-toc-4-tcp에서의-3-way-handshake-절차를-설명하세요-1점">4. TCP에서의 ‘3-way handshake’ 절차를 설명하세요. (1점)</a></li>
      <li><a href="#5-tcp와-udp에서-패킷-손실-시-대처-방법에는-어떤-차이가-있나요-1점" id="markdown-toc-5-tcp와-udp에서-패킷-손실-시-대처-방법에는-어떤-차이가-있나요-1점">5. TCP와 UDP에서 패킷 손실 시 대처 방법에는 어떤 차이가 있나요? (1점)</a>        <ul>
          <li><a href="#tcp" id="markdown-toc-tcp">TCP</a></li>
          <li><a href="#udp" id="markdown-toc-udp">UDP</a></li>
        </ul>
      </li>
      <li><a href="#6-다음-ansi-c-프로그램에서-출력되는-내용은-무엇인가요-1점" id="markdown-toc-6-다음-ansi-c-프로그램에서-출력되는-내용은-무엇인가요-1점">6. 다음 ANSI C 프로그램에서 출력되는 내용은 무엇인가요? (1점)</a></li>
    </ul>
  </li>
</ul>

<h2 id="8주차-퀴즈">8주차 퀴즈</h2>

<h3 id="1-http-get-요청과-post-요청의-가장-큰-차이점은-무엇이며-이것이-요청-헤더나-데이터-전송에-어떤-영향을-미칩니까-1점">1. HTTP GET 요청과 POST 요청의 가장 큰 차이점은 무엇이며, 이것이 요청 헤더나 데이터 전송에 어떤 영향을 미칩니까? (1점)</h3>

<p>GET 요청은 데이터를 URL의 일부(query string)로 전송하지만 POST 요청은 데이터를 요청 본문(body)에 포함합니다.
이 차이 때문에</p>

<p>1)  GET 요청의 URL 길이에는 브라우저나 서버에 따라 제한이 있습니다. 이로 인해 전송할 수 있는 데이터의 양이 제한됩니다.</p>

<p>2)  POST 요청은 ‘Content-Length’와 ‘Content-Type’ 같은 추가적인 헤더 정보를 필요로 합니다.</p>

<h3 id="2-http-응답-코드-404의-의미는-무엇입니까-그리고-서버가-요청을-처리할-수-없을-때-반환하는-http-상태-코드는-무엇입니까-1점">2. HTTP 응답 코드 404의 의미는 무엇입니까? 그리고 서버가 요청을 처리할 수 없을 때 반환하는 HTTP 상태 코드는 무엇입니까? (1점)</h3>

<p>HTTP 응답 코드 404는 “Not Found”를 의미합니다. 이 코드는 서버가 요청된 리소스를 찾을 수 없을 때 반환됩니다. 
서버가 요청을 처리할 수 없을 때 반환하는 HTTP 상태 코드는 500입니다. 이 코드는 “Internal Server Error”를 나타냅니다.</p>

<h3 id="3-파일-디스크립터file-descriptor란-무엇인지-간단히-설명하고-unixlinux-시스템에서-표준-입출력에러의-파일-디스크립터-번호를-쓰세요-1점">3. 파일 디스크립터(File Descriptor)란 무엇인지 간단히 설명하고 UNIX/Linux 시스템에서 표준 입출력/에러의 파일 디스크립터 번호를 쓰세요. (1점)</h3>

<p>파일 디스크립터는 운영 체제에서 파일이나 다른 입출력 리소스에 대한 접근을 추상화하는데 사용되는 정수입니다. 파일 디스크립터를 통해 운영 체제는 파일, 파이프, 소켓 등 다양한 입출력 리소스를 일관된 방식으로 관리할 수 있습니다. 예를 들어, 파일을 열면 운영 체제는 해당 파일을 가리키는 파일 디스크립터를 프로그램에 제공합니다. UNIX/Linux 시스템에서 표준 입력의 파일 디스크립터 번호는 0, 표준 출력은 1, 그리고 표준 에러는 2입니다.</p>

<h3 id="4-tcp에서의-3-way-handshake-절차를-설명하세요-1점">4. TCP에서의 ‘3-way handshake’ 절차를 설명하세요. (1점)</h3>

<p>TCP의 ‘3-way handshake’는 연결 설정 과정에서 사용되는 절차이다. 이 과정은 다음과 같이 세 단계로 이루어진다:</p>

<p>1)  클라이언트가 서버에 SYN(Synchronize) 패킷을 보내 연결 요청을 한다.</p>

<p>2)  서버는 SYN-ACK(Synchronize-Acknowledge) 패킷으로 응답하여 연결 요청을 받았음을 알리고, 자신도 연결 준비가 되었음을 나타낸다.</p>

<p>3)  클라이언트는 ACK(Acknowledge) 패킷을 서버에 보내 연결을 확정한다.</p>

<h3 id="5-tcp와-udp에서-패킷-손실-시-대처-방법에는-어떤-차이가-있나요-1점">5. TCP와 UDP에서 패킷 손실 시 대처 방법에는 어떤 차이가 있나요? (1점)</h3>

<h4 id="tcp">TCP</h4>

<ul>
  <li>
    <p>TCP는 패킷 손실이 발생하면 자동으로 재전송 시도</p>
  </li>
  <li>
    <p>수신자는 받은 패킷에 대해 확인 응답(ACK)을 보내고,</p>
  </li>
  <li>
    <p>송신자는 ACK를 받지 못한 패킷을 재전송</p>
  </li>
</ul>

<h4 id="udp">UDP</h4>

<ul>
  <li>
    <p>반면, UDP는 패킷 손실에 대해 자체적으로 대처하지 않음</p>
  </li>
  <li>
    <p>UDP는 확인 응답이나 재전송 기능이 없어, 패킷 손실이 발생하면 이를 어플리케이션 레벨에서 처리해야 함</p>
  </li>
</ul>

<h3 id="6-다음-ansi-c-프로그램에서-출력되는-내용은-무엇인가요-1점">6. 다음 ANSI C 프로그램에서 출력되는 내용은 무엇인가요? (1점)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> </span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> 
<span class="p">{</span> 
   <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">};</span> 
   <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
   <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> 
   <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> 
   <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> 
   <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span> 
   <span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> 
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>출력값 : 10, 10, 14</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/Algorithm.png" /><media:content medium="image" url="/assets/img/blog/postimage/Algorithm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Datagram Socket과 Stream Socket</title><link href="/blog/computersystem/datagram-stream-socket/" rel="alternate" type="text/html" title="Datagram Socket과 Stream Socket" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>/blog/computersystem/datagram-stream-socket</id><content type="html" xml:base="/blog/computersystem/datagram-stream-socket/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#datagram-socket-udp-기반" id="markdown-toc-datagram-socket-udp-기반">Datagram Socket (UDP 기반)</a>    <ul>
      <li><a href="#datagram-socket-udp의-내부-동작" id="markdown-toc-datagram-socket-udp의-내부-동작">Datagram Socket (UDP)의 내부 동작</a></li>
    </ul>
  </li>
  <li><a href="#stream-socket-tcp-기반" id="markdown-toc-stream-socket-tcp-기반">Stream Socket (TCP 기반)</a>    <ul>
      <li><a href="#stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake" id="markdown-toc-stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake">Stream Socket (TCP)의 내부 동작 + TCP 연결 설정 : 3-way handshake</a></li>
    </ul>
  </li>
  <li><a href="#비교-요약" id="markdown-toc-비교-요약">비교 요약</a></li>
</ul>

<p>네트워크 통신 방식에 따라 소켓을 분류한 두 가지 종류 Datagram Socket과 Stream Socket을 알려줄게</p>

<h2 id="datagram-socket-udp-기반">Datagram Socket (UDP 기반)</h2>

<ul>
  <li>
    <p>기반 프로토콜 : UDP (User Datagram Protocol)</p>
  </li>
  <li>
    <p>연결 방식 : 비연결형 (Connectionless)</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p><strong>비연결형</strong> : 연결 없이 바로 데이터 전송</p>
      </li>
      <li>
        <p><strong>신뢰성 없음</strong> : 순서 보장 X, 재전송 X, 확인 응답 X</p>
      </li>
      <li>
        <p><strong>오버헤드 작음</strong> : 빠르고 단순</p>
      </li>
    </ul>
  </li>
  <li>
    <p>용도 예시 :</p>

    <ul>
      <li>
        <p>스트리밍 (비디오/오디오)</p>
      </li>
      <li>
        <p>실시간 게임</p>
      </li>
      <li>
        <p>DNS 요청</p>
      </li>
    </ul>
  </li>
</ul>

<p>예제 : C에서의 예시 (Datagram Socket)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// SOCK_DGRAM이 핵심</span>
</code></pre></div></div>

<h3 id="datagram-socket-udp의-내부-동작">Datagram Socket (UDP)의 내부 동작</h3>

<ul>
  <li>
    <p>Data를 전송하면, 해당 data는 Datagram(데이터그램)으로 만들어짐</p>
  </li>
  <li>
    <p>각 Datagram은 독립적으로 처리됨(순서/재전송 신경 안 씀)</p>
  </li>
  <li>
    <p>수신 측이 없어도 전송은 진행됨</p>
  </li>
</ul>

<blockquote>
  <p>전송 성공 여부는 알 수 없음</p>
</blockquote>

<p>예제 : Data 전송 예</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 송신자</span>
<span class="n">sendto</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

<span class="c1">// 수신자</span>
<span class="n">recvfrom</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFLEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fromlen</span><span class="p">);</span>
</code></pre></div></div>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">sendto</code>나 <code class="language-plaintext highlighter-rouge">recvfrom</code>에서 연결 상태를 유지하지 않고 주소를 직접 지정함</p>
</blockquote>

<h2 id="stream-socket-tcp-기반">Stream Socket (TCP 기반)</h2>

<ul>
  <li>
    <p>기반 프로토콜 : TCP (Transmission Control Protocol)</p>
  </li>
  <li>
    <p>연결 방식 : 연결형 (Connection-oriented)</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p><strong>연결지향형</strong> : 먼저 연결을 설정한 후 데이터를 주고받음, 통신 전에 연결(3-way handshake) 필요</p>
      </li>
      <li>
        <p><strong>신뢰성</strong> : 순서 보장, 오류 검출, 재전송</p>
      </li>
      <li>
        <p><strong>흐름 제어</strong> : 수신자가 감당할 수 있을 만큼만 전송</p>
      </li>
      <li>
        <p><strong>혼잡 제어</strong> : 네트워크 상황에 따라 전송 속도 조절</p>
      </li>
      <li>
        <p>속도는 느릴 수 있지만 신뢰성 높음</p>
      </li>
    </ul>
  </li>
  <li>
    <p>용도 예시 :</p>

    <ul>
      <li>
        <p>웹 서비스 (HTTP)</p>
      </li>
      <li>
        <p>이메일 (SMTP)</p>
      </li>
      <li>
        <p>파일 전송 (FTP)</p>
      </li>
    </ul>
  </li>
</ul>

<p>예제 : C에서의 예시 (Stream Socket)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// SOCK_STREAM이 핵심</span>
</code></pre></div></div>

<h3 id="stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake">Stream Socket (TCP)의 내부 동작 + TCP 연결 설정 : 3-way handshake</h3>

<p><strong>3way handshake</strong>는 양쪽 통신자가 연결을 동기화하고 준비됐는지 확인하는 과정</p>

<p><strong>과정 요약</strong></p>

<ol>
  <li>
    <p>client → server : <code class="language-plaintext highlighter-rouge">SYN</code> 플래그 세팅된 패킷 전송 (연결 요청)</p>
  </li>
  <li>
    <p>server → client : <code class="language-plaintext highlighter-rouge">SYN + ACK</code> 패킷 전송 (요청 수락 + 서버도 연결 요청)</p>
  </li>
  <li>
    <p>client → server : <code class="language-plaintext highlighter-rouge">ACK</code> 전송 (서버의 연결 수락)</p>
  </li>
</ol>

<blockquote>
  <p>이 과정을 거친 뒤 양쪽 모두 연결이 되었고, 데이터를 주고받을 수 있어</p>
</blockquote>

<p><strong>예시 흐름</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">송신자</th>
      <th style="text-align: center">수신자</th>
      <th style="text-align: center">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">SYN, seq = x</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">SYN + ACK, seq = y, ack = x+1</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">ACK, seq = x+1, ack = y+1</td>
    </tr>
  </tbody>
</table>

<p><strong>TCP 데이터 전송</strong></p>

<ol>
  <li>
    <p>데이터는 스트림(stream)으로 보내짐. 내부적으로 작은 단위로 나뉘어 전송됨.</p>
  </li>
  <li>
    <p>각 패킷은 시퀸스 번호(sequence number)를 가짐</p>
  </li>
  <li>
    <p>수신자는 받은 순서대로 조립하고, ACK로 확인 메시지 보냄</p>
  </li>
  <li>
    <p>손실되면 재전송함</p>
  </li>
</ol>

<p><strong>TCP 연결 종료 : 4-way handshake</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">전송</th>
      <th style="text-align: center">인자</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">A → B</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">FIN</code></td>
      <td style="text-align: center">A가 종료 요청</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">B → A</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">ACK</code></td>
      <td style="text-align: center">B가 확인</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">B → A</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">FIN</code></td>
      <td style="text-align: center">B도 종료 요청</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">A → B</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">ACK</code></td>
      <td style="text-align: center">A가 확인하고 종료</td>
    </tr>
  </tbody>
</table>

<h2 id="비교-요약">비교 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">Datagram Socket (UDP)</th>
      <th style="text-align: center">Stream Socket (TCP)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">연결 여부</td>
      <td style="text-align: center">비연결 (Connectionless)</td>
      <td style="text-align: center">연결 (Connection-oriented)</td>
    </tr>
    <tr>
      <td style="text-align: center">연결 과정</td>
      <td style="text-align: center">없음</td>
      <td style="text-align: center">3-way handshake 필요</td>
    </tr>
    <tr>
      <td style="text-align: center">오류 처리</td>
      <td style="text-align: center">없음</td>
      <td style="text-align: center">ACK + 재전송</td>
    </tr>
    <tr>
      <td style="text-align: center">신뢰성</td>
      <td style="text-align: center">낮음</td>
      <td style="text-align: center">높음</td>
    </tr>
    <tr>
      <td style="text-align: center">Data 순서 보장</td>
      <td style="text-align: center">안됨</td>
      <td style="text-align: center">됨(시퀸스 번호로 순서 보장)</td>
    </tr>
    <tr>
      <td style="text-align: center">속도</td>
      <td style="text-align: center">빠름</td>
      <td style="text-align: center">상대적으로 느림</td>
    </tr>
    <tr>
      <td style="text-align: center">오버헤드</td>
      <td style="text-align: center">작음</td>
      <td style="text-align: center">큼</td>
    </tr>
    <tr>
      <td style="text-align: center">사용 예시</td>
      <td style="text-align: center">실시간 전송, DNS 등</td>
      <td style="text-align: center">웹, 이메일, 파일 전송 등</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[Datagram Socket과 Stream Socket은 네트워크 통신 방식에 따라 소켓을 분류한 두 가지 종류이며, 각각은 UDP와 TCP를 기반으로 두고 있음]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">HTTP, TCP, UDP</title><link href="/blog/computersystem/http-tcp-udp/" rel="alternate" type="text/html" title="HTTP, TCP, UDP" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>/blog/computersystem/http-tcp-udp</id><content type="html" xml:base="/blog/computersystem/http-tcp-udp/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#개념-요약" id="markdown-toc-개념-요약">개념 요약</a></li>
  <li><a href="#각-프로토콜-상세-비교" id="markdown-toc-각-프로토콜-상세-비교">각 프로토콜 상세 비교</a>    <ul>
      <li><a href="#1-http" id="markdown-toc-1-http">1. HTTP</a></li>
      <li><a href="#2-tcp" id="markdown-toc-2-tcp">2. TCP</a></li>
      <li><a href="#3-udp" id="markdown-toc-3-udp">3. UDP</a></li>
    </ul>
  </li>
  <li><a href="#계층별-차이-예시로-이해하기" id="markdown-toc-계층별-차이-예시로-이해하기">계층별 차이 예시로 이해하기</a></li>
  <li><a href="#정리-요약" id="markdown-toc-정리-요약">정리 요약</a></li>
</ul>

<h2 id="개념-요약">개념 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">프로토콜</th>
      <th style="text-align: center">설명</th>
      <th style="text-align: center">위치하는 계층 (TCP/IP 기준)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">HTTP (HyperText Transfer Protocol)</td>
      <td style="text-align: center">웹 브라우저와 서버 간의 데이터 전송 (ex. HTML, 이미지 요청 등)</td>
      <td style="text-align: center">애플리케이션 계층</td>
    </tr>
    <tr>
      <td style="text-align: center">TCP (Transmission Control Protocol)</td>
      <td style="text-align: center">신뢰성 있는 연결 지향형 데이터 전송 (패킷 손실 검사 및 재전송)</td>
      <td style="text-align: center">전송 계층</td>
    </tr>
    <tr>
      <td style="text-align: center">UDP (User Datagram Protocol)</td>
      <td style="text-align: center">빠르지만 신뢰성 없는 연결less형 데이터 전송</td>
      <td style="text-align: center">전송 계층</td>
    </tr>
  </tbody>
</table>

<p>TCP/ IP 게층 모델에 관하여서는 <a href="../../computersystem/osi-7-layer" class="heading flip-title">OSI 7 계층(OSI7 Layer)</a>의 하단에 잠깐 다루니 참고하도록 하자</p>

<h2 id="각-프로토콜-상세-비교">각 프로토콜 상세 비교</h2>

<h3 id="1-http">1. HTTP</h3>

<ul>
  <li>
    <p>계층 : application 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>client-server 구조 (browser가 server에 요청)</p>
      </li>
      <li>
        <p>요청/응답 방식(GET, POST 등)</p>
      </li>
      <li>
        <p>TCP 위에서 동작함 (즉, HTTP는 TCP를 기반으로 함)</p>
      </li>
      <li>
        <p>예 : 웹사이트 접속, API 호출</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="2-tcp">2. TCP</h3>

<ul>
  <li>
    <p>계층 : 전송 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>연결 지향 (3-way handshake로 연결 수립)</p>
      </li>
      <li>
        <p>데이터 순서 보장</p>
      </li>
      <li>
        <p>손실된 패킷 재전송</p>
      </li>
      <li>
        <p>속도는 상대적으로 느림</p>
      </li>
      <li>
        <p>예 : 웹서핑, 이메일, 파일 다운로드</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="3-udp">3. UDP</h3>

<ul>
  <li>
    <p>계층 : 전송 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>비연결형 (handshake 없이 즉시 전송)</p>
      </li>
      <li>
        <p>데이터 순서/전송 보장 없음</p>
      </li>
      <li>
        <p>빠름, 지연 최소화</p>
      </li>
      <li>
        <p>예 : 실시간 스트리밍, VoIP, 게임</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="계층별-차이-예시로-이해하기">계층별 차이 예시로 이해하기</h2>

<p>웹 브라우저로 웹 페이지 접속 시 흐름 :</p>

<ol>
  <li>
    <p>HTTP 요청 생성 → (애플리케이션 계층)</p>
  </li>
  <li>
    <p>TCP 연결 수립 후 데이터 전송 → (전송 계층)</p>
  </li>
  <li>
    <p>IP 주소 기반으로 목적지 라우팅 → (인터넷 계층)</p>
  </li>
  <li>
    <p>Ethernet/Wi-Fi를 통해 실제 전송 → (네트워크 인터페이스 계층)</p>
  </li>
</ol>

<h2 id="정리-요약">정리 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">HTTP</th>
      <th style="text-align: center">TCP</th>
      <th style="text-align: center">UDP</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">계층</td>
      <td style="text-align: center">application</td>
      <td style="text-align: center">전송</td>
      <td style="text-align: center">전송</td>
    </tr>
    <tr>
      <td style="text-align: center">연결 방식</td>
      <td style="text-align: center">연결 필요 (TCP 기반)</td>
      <td style="text-align: center">연결 지향</td>
      <td style="text-align: center">비연결형</td>
    </tr>
    <tr>
      <td style="text-align: center">신뢰성</td>
      <td style="text-align: center">TCP에 의존</td>
      <td style="text-align: center">높음 (재전송, 순서 보장)</td>
      <td style="text-align: center">낮음 (손실 허용)</td>
    </tr>
    <tr>
      <td style="text-align: center">속도</td>
      <td style="text-align: center">중간</td>
      <td style="text-align: center">느림</td>
      <td style="text-align: center">빠름</td>
    </tr>
    <tr>
      <td style="text-align: center">용도</td>
      <td style="text-align: center">웹, API</td>
      <td style="text-align: center">웹, 이메일</td>
      <td style="text-align: center">스트리밍, 게임, DNS</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[HTTP, TCP, UDP는 네트워크 통신에서 자주 등장하는 개념들이고, 이들은 OSI 7계층 모델 또는 TCP/IP 4계층 모델의 서로 다른 계층에 위치해 있어. 아래에 각 개념과 계층별 차이점을 정리해줄게]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">IP Layer</title><link href="/blog/computersystem/ip-layer/" rel="alternate" type="text/html" title="IP Layer" /><published>2025-05-05T00:00:00+00:00</published><updated>2025-05-05T00:00:00+00:00</updated><id>/blog/computersystem/ip-layer</id><content type="html" xml:base="/blog/computersystem/ip-layer/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#ip-layer란" id="markdown-toc-ip-layer란">IP Layer란?</a></li>
  <li><a href="#왜-필요한가" id="markdown-toc-왜-필요한가">왜 필요한가?</a></li>
  <li><a href="#핵심-기능-상세" id="markdown-toc-핵심-기능-상세">핵심 기능 상세</a></li>
  <li><a href="#ipv4-헤더-구조-한눈에-보기" id="markdown-toc-ipv4-헤더-구조-한눈에-보기">IPv4 헤더 구조 한눈에 보기</a></li>
  <li><a href="#흐름-예시-간단-시나리오" id="markdown-toc-흐름-예시-간단-시나리오">흐름 예시 (간단 시나리오)</a></li>
  <li><a href="#개발자-관점--유용한-cli" id="markdown-toc-개발자-관점--유용한-cli">개발자 관점 : 유용한 CLI</a></li>
  <li><a href="#자주-헷갈리는-점-정리" id="markdown-toc-자주-헷갈리는-점-정리">자주 헷갈리는 점 정리</a></li>
  <li><a href="#마무리" id="markdown-toc-마무리">마무리</a></li>
</ul>

<h2 id="ip-layer란">IP Layer란?</h2>

<p>IP (Internet Protocol) Layer는 <strong>TCP/IP 4계층 모델</strong>에서 네트워크 계층(Network Layer)에 해당하며, OSI 7계층으로 치면 <strong>3계층</strong>임
가장 핵심적인 역할은 “<strong>패킷을 한 네트워크에서 다른 네트워크로 최적의 경로를 따라 전달</strong>”하는 것—즉 <strong>논리적 주소(=IP 주소)</strong> 기반의 <strong>라우팅</strong></p>

<h2 id="왜-필요한가">왜 필요한가?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">문제</th>
      <th style="text-align: center">IP Layer가 제공하는 해결책</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">물리적으로 떨어져 있는 수많은 LAN·WAN을 하나의 ‘인터넷’으로 묶어야 함</td>
      <td style="text-align: center">전 세계적으로 유일한 주소 체계(IPv4/IPv6)와 계층적 라우팅</td>
    </tr>
    <tr>
      <td style="text-align: center">이기종 네트워크(이더넷, Wi-Fi, 5G, 광망 …)간 데이터 전달</td>
      <td style="text-align: center">서로 다른 링크 계층을 통일된 패킷 형식(IP Datagram)으로 캡슐화</td>
    </tr>
    <tr>
      <td style="text-align: center">큰 데이터그램이 링크 MTU보다 클 때</td>
      <td style="text-align: center">Fragmentation &amp; Reassembly(IPv4만 IPv6은 PMTU 디스커버리 사용)</td>
    </tr>
    <tr>
      <td style="text-align: center">전송 중 오류·혼잡·노드 고장 감지</td>
      <td style="text-align: center">ICMP로 오류·제어 메시지 전달</td>
    </tr>
  </tbody>
</table>

<h2 id="핵심-기능-상세">핵심 기능 상세</h2>

<ol>
  <li>
    <p>논리적 주소 지정 (Addressing)</p>

    <ul>
      <li>
        <p>IPv4 : 32-bit, dotted-decimal(192.0.2.4)</p>
      </li>
      <li>
        <p>IPv6 : 128-bit, hexadecimal 콜론 표기(2001:db8::1)</p>
      </li>
      <li>
        <p>네트워크/호스트 부분을 사용해 계층적(aggregation) 라우팅을 가능케 함</p>
      </li>
    </ul>
  </li>
  <li>
    <p>패킷화 (Encapsulation)</p>

    <ul>
      <li>상위 계층(TCP, UDP, ICMP 등) 세그먼트를 IP Header + Payload 형태로 감싼 뒤 하위 링크 계층(이더넷 프레임 등)에 다시 캡슐화</li>
    </ul>
  </li>
  <li>
    <p>라우팅 (Routing &amp; Forwarding)</p>

    <ul>
      <li>
        <p>Forwarding : 라우터가 목적지 주소를 보고 다음 홉(next-hop) 인터페이스로 패킷을 넘김</p>
      </li>
      <li>
        <p>Routing : 라우터들이 RIP, OSPF, BGP 같은 라우팅 프로토콜로 테이블을 동적으로 구축</p>
      </li>
    </ul>
  </li>
  <li>
    <p>분할 및 재조합 (Fragmentation/Reassembly)</p>

    <ul>
      <li>
        <p>IPv4 헤더의 Identification, Flags, Fragment Offset 필드로 조각화 추적</p>
      </li>
      <li>
        <p>IPv6은 기본적으로 조각화를 금지, 발신 호스트가 Path MTU Discovery로 크기를 조정</p>
      </li>
    </ul>
  </li>
  <li>
    <p>품질과 오류 제어</p>

    <ul>
      <li>
        <p>IPv4 Header Checksum으로 1-hop 오류 검출(IPv6에는 없음 : 링크 계층/전송 계층에 맡김)</p>
      </li>
      <li>
        <p>ICMP를 통해 “Destination Unreachable”, “Time Exceeded” 등 메시지 반환</p>
      </li>
    </ul>
  </li>
</ol>

<h2 id="ipv4-헤더-구조-한눈에-보기">IPv4 헤더 구조 한눈에 보기</h2>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
</span><span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|Ver|</span> IHL|DSCP|ECN|         Total Length                        |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>        Identification         |Flags|      Fragment Offset    |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>  TTL  | Protocol |    Header Checksum                         |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>                       Source Address                          |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>                    Destination Address                        |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>                    Options      (0 ~ 40 bytes)                |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></code></pre></div></div>

<ul>
  <li>
    <p>Ver/IHL : 버전(4)과 헤더 길이(32비트 word 수)</p>
  </li>
  <li>
    <p>Total Length : 헤더 + 데이터 전체 길이</p>
  </li>
  <li>
    <p>TTL : 홉 수 제한(루프 방지)</p>
  </li>
  <li>
    <p>Protocol : 상위 프로토콜 번호(TCP = 6, UDP = 17…)</p>
  </li>
  <li>
    <p>Options : Timestamp, Record Route 등 거의 사용 안함</p>
  </li>
</ul>

<p>IPv6는 고정 40바이트 헤더에 별도 확장 헤더 체인을 사용해 단순화/고속화함</p>

<h2 id="흐름-예시-간단-시나리오">흐름 예시 (간단 시나리오)</h2>

<ol>
  <li>
    <p>192.168.1.10:5000 → 142.250.78.14:443(TCP)</p>
  </li>
  <li>
    <p>TCP 세그먼트가 IP Datagram으로 캡슐화</p>
  </li>
  <li>
    <p>로컬 라우터가 목적지 네트워크(AS15169)를 향한 default route 선택</p>
  </li>
  <li>
    <p>중간 BGP 라우터들이 TTL을 1씩 감소시키며 패킷 포워딩</p>
  </li>
  <li>
    <p>Google 프런트엔드 서버에서 TCP ACK, HTTP/2 응답 → 역방향 경로로 전송</p>
  </li>
</ol>

<h2 id="개발자-관점--유용한-cli">개발자 관점 : 유용한 CLI</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">작업</th>
      <th style="text-align: center">IPv4</th>
      <th style="text-align: center">IPv6</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">라우팅 테이블 확인</td>
      <td style="text-align: center">ip route show</td>
      <td style="text-align: center">ip -6 route show</td>
    </tr>
    <tr>
      <td style="text-align: center">패킷 흐름 추적</td>
      <td style="text-align: center">traceroute 8.8.8.8</td>
      <td style="text-align: center">traceroute -6 2001:4860:4860::8888</td>
    </tr>
    <tr>
      <td style="text-align: center">ICMP Echo</td>
      <td style="text-align: center">ping -c 4 host</td>
      <td style="text-align: center">ping6 -c 4 host</td>
    </tr>
  </tbody>
</table>

<h2 id="자주-헷갈리는-점-정리">자주 헷갈리는 점 정리</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">오해</th>
      <th style="text-align: center">실제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">“IP = 인터넷 전체 프로토콜 스택”</td>
      <td style="text-align: center">IP는 한 계층일 뿐, 아래(링크)/위(전송)/위의 위(애플리케이션) 계층이 따로 있다</td>
    </tr>
    <tr>
      <td style="text-align: center">“IP가 연결 지향”</td>
      <td style="text-align: center">IP는 비연결형, 비신뢰성∙Best-Effort. 신뢰성은 TCP가 따로 보장</td>
    </tr>
    <tr>
      <td style="text-align: center">“IPv6는 단순히 주소 길이만 4배”</td>
      <td style="text-align: center">헤더 단순화, Neighbour Discovery, 확장 헤더, IPsec 의무 지원 등 근본적 개선 포함</td>
    </tr>
  </tbody>
</table>

<h2 id="마무리">마무리</h2>

<p>IP Layer는 <strong>인터넷을 ‘한 덩어리’로 보이게 해 주는 추상화</strong>입니다. 여기서 다룬 주소 지정, 라우팅, 조각화, ICMP 등의 기초가 잡혀 있으면 TCP, UDP, TLS 같은 상위 계층을 배울 때 훨씬 수월해짐</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[IP (Internet Protocol) Layer는 TCP/IP 4계층 모델에서 네트워크 계층(Network Layer)에 해당하며, OSI 7계층으로 치면 3계층입니다. 가장 핵심적인 역할은 “패킷을 한 네트워크에서 다른 네트워크로 최적의 경로를 따라 전달”하는 것—즉 논리적 주소(=IP 주소) 기반의 라우팅입니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">OSI 7 계층(OSI7 Layer)</title><link href="/blog/computersystem/osi-7-layer/" rel="alternate" type="text/html" title="OSI 7 계층(OSI7 Layer)" /><published>2025-05-05T00:00:00+00:00</published><updated>2025-05-05T00:00:00+00:00</updated><id>/blog/computersystem/osi-7-layer</id><content type="html" xml:base="/blog/computersystem/osi-7-layer/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#한눈에-보는-osi-7계층" id="markdown-toc-한눈에-보는-osi-7계층">한눈에 보는 OSI 7계층</a></li>
  <li><a href="#계층별-세부사항" id="markdown-toc-계층별-세부사항">계층별 세부사항</a></li>
  <li><a href="#왜-tcpip-4계층-모델을-더-많이-쓸까" id="markdown-toc-왜-tcpip-4계층-모델을-더-많이-쓸까">왜 TCP/IP 4계층 모델을 더 많이 쓸까?</a></li>
  <li><a href="#osi-7계층을-배우는-이유" id="markdown-toc-osi-7계층을-배우는-이유">OSI 7계층을 배우는 이유</a></li>
</ul>

<p><strong>OSI 7 계층</strong>은 <strong>물리 신호부터 user application</strong>까지 <strong>네트워크 기능을 일곱 단계로 나눈 개념적 설계도</strong>이다. 실무에선 TCP/IP 4계층으로 단순화해 쓰지만, 문제 분석과 개념 정리에 여전히 유용함</p>

<h2 id="한눈에-보는-osi-7계층">한눈에 보는 OSI 7계층</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">번호</th>
      <th style="text-align: center">계층 이름</th>
      <th style="text-align: center">주요 기능</th>
      <th style="text-align: center">예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">응용 계층 (Application)</td>
      <td style="text-align: center">사용자와 직접 상호작용, 네트워크 서비스 제공</td>
      <td style="text-align: center">HTTPS/HTTPS, FTP, SMTP, DNS, SSH</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">표현 계층 (Presentation)</td>
      <td style="text-align: center">데이터 형식 변환, 암호화/복호화, 압축</td>
      <td style="text-align: center">JPEG, MP3, SSL</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">세션 계층 (Session)</td>
      <td style="text-align: center">연결 설정/유지/종료, 세션 관리</td>
      <td style="text-align: center">NetBIOS, RPC, PPTP</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">전송 계층 (Transport)</td>
      <td style="text-align: center">데이터 전송 보장(신뢰성), 오류 제어</td>
      <td style="text-align: center">TCP, UDP, QUIC, SCTP</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">네트워크 계층 (Network)</td>
      <td style="text-align: center">주소 지정/경로 선택(라우팅)</td>
      <td style="text-align: center">IP, ICMP, ARP, OSPF, BGP</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">데이터링크 계층 (Data-Link)</td>
      <td style="text-align: center">프레임 생성, MAC 주소 기반 전달, 에러 감지</td>
      <td style="text-align: center">Ethernet, Wi-Fi 802.11, PPP, VLAN, 스위치</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">물리 계층 (Physical)</td>
      <td style="text-align: center">0/1 신호를 실제 매체로 전송</td>
      <td style="text-align: center">UTP 케이블, 광섬유, 전파, 허브, 리피터</td>
    </tr>
  </tbody>
</table>

<h2 id="계층별-세부사항">계층별 세부사항</h2>

<ol>
  <li>물리 계층</li>
</ol>

<p>“전길줄에 0과 1을 어떻게 흘려보낼까?”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 전압 크기, 광펄스 세기, 라디오 주파수 등 **신호**의 물리적 특성을 정의함

- 허브/리피터처럼 "증폭만 하고 아무 판단도 못 하는" 장비가 여기에 속함
</code></pre></div></div>

<ol>
  <li>데이터링크 계층</li>
</ol>

<p>“같은 네트워크(브로드캐스트 도메인) 안에서 누가 누구인지 구분하려면?”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **MAC 주소**를 붙여 프레임 단위로 전송하며, CRC로 프레임 오류를 검출함

- 스위치/브리지·VLAN·ARP 캐시 같은 개념이 등장함
</code></pre></div></div>

<ol>
  <li>네트워크 계층</li>
</ol>

<p>“지구 반대편 호스트까지 가려면 중간길(라우팅)을 어떻게 잡지?”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **IP 주소**를 붙이고, 라우터가 최적 경로를 찾아 포워딩함

- ICMP '목적지 도달 불가', OSPF/BGP 등 라우팅 프로토콜이 여기에 있음
</code></pre></div></div>

<ol>
  <li>전송 계층</li>
</ol>

<p>“프로세스 간에 패킷이 유실돼도 재전송하고, 순서도 맞춰야지”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- TCP : 3-Way Handshake, 흐름/혼잡 제어, 세그먼트 재전송

- UDP : 최소한의 헤더로 "빠르지만 책임 안 진다"

- QUIC : HTTP/3가 쓰는 신흥 강자, UDP 위에 신뢰성·TLS 포함
</code></pre></div></div>

<ol>
  <li>세션 계층</li>
</ol>

<p>“논리적인 대화방(세션)을 열고 닫는 관리를 맡자”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 체크포인트·재동기화·다중 스트림 제어 가능

- 실무에선 애매함, OSI만의 전통적인 구분이며, 실제 구현은 주로 응용/전송이 흡수
</code></pre></div></div>

<ol>
  <li>표현 계층</li>
</ol>

<p>“바이트를 사람이 읽을 수 있게/암호화된 형태로 변환하자”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 문자 집합 변환(UTF-8↔EUC-KR), 압축(GZIP), 암복호(TLS) 담당

- 응용계층과 합쳐서 다루는 경우가 많지만, 보안·멀티미디어 코덱 설명 때 유용
</code></pre></div></div>

<ol>
  <li>응용 계층</li>
</ol>

<p>“사용자 프로그램이 원하는 서비스 그 자체”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 웹브라우저-HTTP, 메일-SMTP/IMAP, 파일전송-FTP/SFTP 처럼 **실제 앱 프로토콜**이 자리함

- API 호출(REST/GraphQL)·메신저 프로토콜도 여기서 논의됨
</code></pre></div></div>

<h2 id="왜-tcpip-4계층-모델을-더-많이-쓸까">왜 TCP/IP 4계층 모델을 더 많이 쓸까?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">OSI</th>
      <th style="text-align: center">TCP/IP(실무)</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">7-5</td>
      <td style="text-align: center">응용 계층</td>
      <td style="text-align: center">HTTP·TLS·RPC 등 모두 한 덩어리</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">전송 계층</td>
      <td style="text-align: center">TCP·UDP·QUIC</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">인터넷 계층</td>
      <td style="text-align: center">IP, ICMP 등</td>
    </tr>
    <tr>
      <td style="text-align: center">2-1</td>
      <td style="text-align: center">네트워크 접근 계층</td>
      <td style="text-align: center">Ethernet·Wi-Fi·물리 매체</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p><strong>간소화</strong> : 실제 구현에서는 세션/표현 계층이 따로 분리돼 작동하지 않는 경우가 많아 4단계로 줄임</p>
  </li>
  <li>
    <p><strong>표준화 주체</strong>도 다름. OSI는 ISO(국제표준화기구) 주도, TCP/IP는 IETF(인터넷 엔지니어링 태스크포스)가 주도함</p>
  </li>
</ul>

<h2 id="osi-7계층을-배우는-이유">OSI 7계층을 배우는 이유</h2>

<ol>
  <li>
    <p>문제 진단 : “이건 3계층 문제인가 4계층 문제인가?”를 구분해야 디버깅이 쉬움</p>
  </li>
  <li>
    <p>역할 분리 : “ 새 프로토콜 설계 시 “이 기능은 어느 계층 책임인가?”를 결정하는 기준 세우기가 가능해짐</p>
  </li>
  <li>
    <p>학습 프레임 : 물리 → 응용으로 올라가며 추상화·책임 범위를 체계적으로 이해할 수 있음</p>
  </li>
</ol>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[OSI 7계층(Open Systems Interconnection 7 Layers)은 네트워크 통신 과정을 7단계로 나눈 모델이며, 이 모델은 각 계층마다 맡은 역할이 정해져 있어서, 복잡한 통신 과정을 구조화하고 표준화하는 데 도움이 됩니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">7주차 퀴즈</title><link href="/blog/algorithm/7th-week/" rel="alternate" type="text/html" title="7주차 퀴즈" /><published>2025-04-29T00:00:00+00:00</published><updated>2025-04-29T00:00:00+00:00</updated><id>/blog/algorithm/7th-week</id><content type="html" xml:base="/blog/algorithm/7th-week/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#7주차-퀴즈" id="markdown-toc-7주차-퀴즈">7주차 퀴즈</a>    <ul>
      <li><a href="#페이징과-세그멘테이션의-정의-및-각각의-장단점에-대해-서술하시오-1점" id="markdown-toc-페이징과-세그멘테이션의-정의-및-각각의-장단점에-대해-서술하시오-1점">페이징과 세그멘테이션의 정의 및 각각의 장단점에 대해 서술하시오. (1점)</a></li>
      <li><a href="#first-fit에-대한-예시를-보고-next-fit과-best-fit일-때요청에-대한-메모리-할당-순서를-기록하세요-1점" id="markdown-toc-first-fit에-대한-예시를-보고-next-fit과-best-fit일-때요청에-대한-메모리-할당-순서를-기록하세요-1점">First-fit에 대한 예시를 보고, Next-fit과 Best-fit일 때요청에 대한 메모리 할당 순서를 기록하세요. (1점)</a></li>
      <li><a href="#dma의-기본-개념을-설명하고-dma가-시스템-성능에-미치는-이점을-두-가지-이상-제시하시오-1점" id="markdown-toc-dma의-기본-개념을-설명하고-dma가-시스템-성능에-미치는-이점을-두-가지-이상-제시하시오-1점">DMA의 기본 개념을 설명하고, DMA가 시스템 성능에 미치는 이점을 두 가지 이상 제시하시오. (1점)</a></li>
      <li><a href="#다음-코드의-출력-값을-예측해-보시오-1점" id="markdown-toc-다음-코드의-출력-값을-예측해-보시오-1점">다음 코드의 출력 값을 예측해 보시오. (1점)</a></li>
      <li><a href="#1-2-4-4-3-5-5-6의-입력이-do-it-알고리즘-책-p294의-알고리즘에-주어질-때의-상태를-그리면-됩니다-주어진-입력으로-부터-p294의-1단계를-거치고-나서-부터-그리면-되고-p291의-그림을-그릴-때는-좌측의-힙트리은-그리-않아도-됩니다-배열-상태로-부터-힙은-충분히-그릴-수-있기-때문입니다-2점" id="markdown-toc-1-2-4-4-3-5-5-6의-입력이-do-it-알고리즘-책-p294의-알고리즘에-주어질-때의-상태를-그리면-됩니다-주어진-입력으로-부터-p294의-1단계를-거치고-나서-부터-그리면-되고-p291의-그림을-그릴-때는-좌측의-힙트리은-그리-않아도-됩니다-배열-상태로-부터-힙은-충분히-그릴-수-있기-때문입니다-2점">1 2 4 4 3 5 5 6의 입력이 Do it 알고리즘 책 p.294의 알고리즘에 주어질 때의 상태를 그리면 됩니다. 주어진 입력으로 부터 p.294의 1단계를 거치고 나서 부터 그리면 되고, p.291의 그림을 그릴 때는 좌측의 힙(트리)은 그리 않아도 됩니다. 배열 상태로 부터 힙은 충분히 그릴 수 있기 때문입니다. (2점)</a></li>
    </ul>
  </li>
</ul>

<h2 id="7주차-퀴즈">7주차 퀴즈</h2>

<h3 id="페이징과-세그멘테이션의-정의-및-각각의-장단점에-대해-서술하시오-1점">페이징과 세그멘테이션의 정의 및 각각의 장단점에 대해 서술하시오. (1점)</h3>

<p>세그멘테이션(Segmentation)과 페이징(Paging)은 컴퓨터 메모리 관리 방법입니다.</p>

<p>세그멘테이션 : 이는 메모리를 의미 있는 단위인 ‘세그먼트’로 나누는 방법입니다. 각 세그먼트는 시작 주소와 길이를 가지며, 다른 유형의 데이터(예: 코드, 데이터, 스택)를 위해 사용됩니다. 세그멘테이션은 메모리를 더 유연하게 관리할 수 있게 해주며, 프로그램의 논리적 구조를 반영할 수 있습니다.</p>

<p>페이징 : 페이징은 메모리를 동일한 크기의 블록, 즉 ‘페이지’로 나누는 방법입니다. 각 페이지는 가상 메모리 주소와 매핑되며, 페이지 테이블을 통해 물리적 메모리 주소로 변환됩니다. 페이징은 메모리 관리를 단순화하고, 메모리의 낭비를 줄이며, 프로그램 간의 메모리 충돌을 방지합니다.</p>

<p>장단점 :</p>

<ul>
  <li>
    <p>세그멘테이션</p>

    <ul>
      <li>
        <p>장점 :</p>

        <ul>
          <li>
            <p>메모리를 논리적 단위로 나누어 프로그램의 구조를 반영함.</p>
          </li>
          <li>
            <p>세그먼트별 보호와 공유가 용이함.</p>
          </li>
        </ul>
      </li>
      <li>
        <p>단점 :</p>

        <ul>
          <li>
            <p>외부 단편화 발생 가능성이 있음.</p>
          </li>
          <li>
            <p>메모리 관리가 복잡해질 수 있음.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>페이징</p>

    <ul>
      <li>
        <p>장점 :</p>

        <ul>
          <li>
            <p>외부 단편화 문제를 해결함.</p>
          </li>
          <li>
            <p>메모리 관리가 상대적으로 단순함.</p>
          </li>
        </ul>
      </li>
      <li>
        <p>단점 :</p>

        <ul>
          <li>
            <p>내부 단편화 발생 가능성이 있음.</p>
          </li>
          <li>
            <p>페이지 테이블 관리에 추가적인 메모리가 필요함.</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
</ul>

<h3 id="first-fit에-대한-예시를-보고-next-fit과-best-fit일-때요청에-대한-메모리-할당-순서를-기록하세요-1점">First-fit에 대한 예시를 보고, Next-fit과 Best-fit일 때요청에 대한 메모리 할당 순서를 기록하세요. (1점)</h3>

<p>메모리에는 다음과 같은 블록들이 있으며, 각 블록의 크기는 괄호 안에 표시되어 있습니다.</p>

<p>메모리 블록: A(10), B(50), C(25), D(30), E(40)</p>

<p>다음 순서로 메모리 요청이 들어옵니다.</p>

<p>요청 순서: 1(30), 2(25), 3(25), 4(10)</p>

<p>예) First-fit 
1 - B 
2 - C 
3 - D 
4 - A</p>

<p>Next-Fit 
1 - B 
2 - C 
3 - D 
4 - E</p>

<p>Best-Fit 
1 - D 
2 - C 
3 - E 
4 - A</p>

<h3 id="dma의-기본-개념을-설명하고-dma가-시스템-성능에-미치는-이점을-두-가지-이상-제시하시오-1점">DMA의 기본 개념을 설명하고, DMA가 시스템 성능에 미치는 이점을 두 가지 이상 제시하시오. (1점)</h3>

<p>DMA는 Direct Memory Access의 약자로, CPU의 중재 없이 주변장치가 메모리에 직접 접근하여 데이터를 읽고 쓸 수 있게 해주는 시스템의 한 기능이다. DMA를 사용함으로써, 데이터 전송 과정에서 CPU가 필요하지 않으므로, CPU는 다른 작업을 수행하는 데 더 많은 시간을 할애할 수 있다. 이는 시스템 성능의 향상으로 이어지는데, 특히 I/O 작업이 많은 시스템에서 그 이점이 두드러진다.</p>

<p>첫째, CPU의 부하가 감소하여 전체 시스템의 효율성이 증가한다.</p>

<p>둘째, 데이터 전송 속도가 향상되므로, 전반적인 시스템 응답 시간이 단축된다.</p>

<h3 id="다음-코드의-출력-값을-예측해-보시오-1점">다음 코드의 출력 값을 예측해 보시오. (1점)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> </span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> 
<span class="p">{</span> 
    <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">6</span><span class="p">};</span> 
    <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
    <span class="n">p</span> <span class="o">=</span> <span class="n">arr</span><span class="p">;</span> 
     
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span><span class="p">));</span> 
    <span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span> 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>답 : 
8
9</p>

<h3 id="1-2-4-4-3-5-5-6의-입력이-do-it-알고리즘-책-p294의-알고리즘에-주어질-때의-상태를-그리면-됩니다-주어진-입력으로-부터-p294의-1단계를-거치고-나서-부터-그리면-되고-p291의-그림을-그릴-때는-좌측의-힙트리은-그리-않아도-됩니다-배열-상태로-부터-힙은-충분히-그릴-수-있기-때문입니다-2점">1 2 4 4 3 5 5 6의 입력이 Do it 알고리즘 책 p.294의 알고리즘에 주어질 때의 상태를 그리면 됩니다. 주어진 입력으로 부터 p.294의 1단계를 거치고 나서 부터 그리면 되고, p.291의 그림을 그릴 때는 좌측의 힙(트리)은 그리 않아도 됩니다. 배열 상태로 부터 힙은 충분히 그릴 수 있기 때문입니다. (2점)</h3>

<p>처음 :6 4 5 2 3 4 5 1 
‘0’ : 5 4 5 2 3 4 1 6 
‘1’ : 5 4 4 2 3 1 5 6 
‘2’ : 4 3 4 2 1 5 5 6 
‘3’ : 4 3 1 2 4 5 5 6 
‘4’ : 3 2 1 4 4 5 5 6 
‘5’ : 2 1 3 4 4 5 5 6 
‘6’ : 1 2 3 4 4 5 5 6 
final : 1 2 3 4 4 5 5 6</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/Algorithm.png" /><media:content medium="image" url="/assets/img/blog/postimage/Algorithm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Demand-zero memory</title><link href="/blog/computersystem/demand-zero-memory/" rel="alternate" type="text/html" title="Demand-zero memory" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>/blog/computersystem/demand-zero-memory</id><content type="html" xml:base="/blog/computersystem/demand-zero-memory/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#동작-흐름" id="markdown-toc-동작-흐름">동작 흐름</a></li>
  <li><a href="#왜-쓰일까" id="markdown-toc-왜-쓰일까">왜 쓰일까?</a></li>
  <li><a href="#언제-볼-수-있을까" id="markdown-toc-언제-볼-수-있을까">언제 볼 수 있을까?</a></li>
  <li><a href="#요약" id="markdown-toc-요약">요약</a>    <ul>
      <li><a href="#나만의-요약" id="markdown-toc-나만의-요약">나만의 요약</a></li>
    </ul>
  </li>
</ul>

<p><strong>Demand-zero memory(또는 zero-filled-on-demand page)</strong>는 운영체제가 <strong>“필요해질 때(demand)”</strong> 처음 접근되는 순간에만 물리 페이지를 연결하고, 그 페이지의 모든 바이트를 0으로 채워서(zero-fill) 사용자 프로세스에 넘겨주는 메모리 할당 기법</p>

<h2 id="동작-흐름">동작 흐름</h2>

<ol>
  <li>가상 주소 공간만 잡아 두기</li>
</ol>

<ul>
  <li>
    <p>프로그램이 malloc, VirtualAlloc(…, MEM_RESERVE), 스택 확대, BSS(전역/정적 0-초기화 변수) 등으로 “새 메모리를” 요구하면,</p>
  </li>
  <li>
    <p>커널은 대응되는 물리 페이지 없이 가상 주소 범위를 예약해 두고, PTE(Page-Table Entry)에 “아직 물리 페이지 없음, demand-zero”라는 플래그를 세워 둠</p>
  </li>
</ul>

<ol>
  <li>첫 접근 → 페이지 폴트(page fault)</li>
</ol>

<ul>
  <li>CPU가 그 주소를 읽거나 쓰려고 하면 PTE에 실제 프레임이 없으므로 페이지 폴트가 발생</li>
</ul>

<ol>
  <li>커널이 물리 페이지 할당 &amp; 0으로 초기화</li>
</ol>

<ul>
  <li>
    <p>커널의 Zero Page List에서 이미 0으로 클리어돼 있는 여유 페이지를 하나 꺼내오거나,</p>
  </li>
  <li>
    <p>여유 페이지가 없다면 새 페이지를 확보한 뒤 memset(page, 0, PAGE_SIZE)로 0-필(fill) 한다</p>
  </li>
</ul>

<ol>
  <li>PTE 갱신 후 재시도</li>
</ol>

<ul>
  <li>PTE를 “valid + 해당 물리 프레임”으로 고쳐 놓고, fault 된 명령을 재실행하면 이제 정상적으로 0값이 보임</li>
</ul>

<h2 id="왜-쓰일까">왜 쓰일까?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">장점</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">메모리 절약</td>
      <td style="text-align: center">큰 배열/구조체를 “0으로 초기화”해 예약만 해 놓고, 실제로 접근한 부분만 물리 메모리를 소비함</td>
    </tr>
    <tr>
      <td style="text-align: center">보안 &amp; 안정성</td>
      <td style="text-align: center">항상 0으로 채워 주므로, 이전 프로세스의 잔류 데이터가 노출되지 않음</td>
    </tr>
    <tr>
      <td style="text-align: center">속도(평균)</td>
      <td style="text-align: center">초기화 루프를 사용자 코드에서 돌릴 필요가 없고, 커널은 미리 0-클리어 해 둔 zero-page 풀을 재사용해 페이지 폴트 처리 시간을 최소화함</td>
    </tr>
  </tbody>
</table>

<h2 id="언제-볼-수-있을까">언제 볼 수 있을까?</h2>

<ul>
  <li>
    <p>Windows - MEM_COMMIT 없이 VirtualAlloc으로 예약만 한 뒤 접근할 때, 또는 일반 HeapAlloc/new 내부적으로</p>
  </li>
  <li>
    <p>Linux/Unix - 익명 매핑 mmap(…, MAP_ANONYMOUS)·스택·BSS·brk/sbrk 등</p>
  </li>
  <li>
    <p>하이퍼바이저/가상머신 - 게스트가 처음 쓰는 시점까지 진짜 호스트 RAM을 배정하지 않는 ballooning 기법과 결합되기도 함</p>
  </li>
</ul>

<h2 id="요약">요약</h2>

<p>Demand-zero memory = “필요할 때 0으로 초기화된 물리 페이지를 뒤늦게 붙이는 가상 메모리 기술”</p>

<p>→ 프로그램 입장에서는 ‘이미 0으로 초기화돼 있는 새 메모리’를 즉시 얻은 것처럼 보이지만, 실제 RAM은 첫 사용 시점까지 쓰이지 않아 메모리를 아끼고 보안을 높여 줌</p>

<h3 id="나만의-요약">나만의 요약</h3>

<ol>
  <li>
    <p>물리 메모리 같은 경우 첫 사용 전까지는 메모리 할당이 되지 않음</p>
  </li>
  <li>
    <p>하지만 가상 메모리에서는 공간이 확보된 상태</p>
  </li>
  <li>
    <p>실제 사용시에는 page fault 되면서 물리 메모리 할당이 이루어짐, PTE의 Not-present → Present로 갱신</p>
  </li>
</ol>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[Demand-zero memory(또는 zero-filled-on-demand page)는 운영체제가 “필요해질 때(demand)” 처음 접근되는 순간에만 물리 페이지를 연결하고, 그 페이지의 모든 바이트를 0으로 채워서(zero-fill) 사용자 프로세스에 넘겨주는 메모리 할당 기법이다]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Direct Memory Access</title><link href="/blog/computersystem/dma/" rel="alternate" type="text/html" title="Direct Memory Access" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>/blog/computersystem/dma</id><content type="html" xml:base="/blog/computersystem/dma/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#dmadirect-memory-access란" id="markdown-toc-dmadirect-memory-access란">DMA(Direct Memory Access)란?</a></li>
  <li><a href="#왜-dma가-필요한가" id="markdown-toc-왜-dma가-필요한가">왜 DMA가 필요한가?</a></li>
  <li><a href="#기본-구성-요소" id="markdown-toc-기본-구성-요소">기본 구성 요소</a>    <ul>
      <li><a href="#dma-레지스터-src-dst-len" id="markdown-toc-dma-레지스터-src-dst-len">DMA 레지스터 SRC, DST, LEN</a></li>
    </ul>
  </li>
  <li><a href="#동작-흐름-x86-pc-예시" id="markdown-toc-동작-흐름-x86-pc-예시">동작 흐름 (x86 PC 예시)</a>    <ul>
      <li><a href="#동작-흐름-더-자세히" id="markdown-toc-동작-흐름-더-자세히">동작 흐름 더 자세히</a>        <ul>
          <li><a href="#1-단계---cpu까-준비만-하고-손을-뗀다" id="markdown-toc-1-단계---cpu까-준비만-하고-손을-뗀다">1 단계 - CPU까 준비만 하고 손을 뗀다</a></li>
          <li><a href="#2-단계---버스-소유권-교환" id="markdown-toc-2-단계---버스-소유권-교환">2 단계 - 버스 소유권 교환</a></li>
          <li><a href="#3-단계---실제-데이터-이동" id="markdown-toc-3-단계---실제-데이터-이동">3 단계 - 실제 데이터 이동</a></li>
          <li><a href="#4-단계---전송-완료-알림" id="markdown-toc-4-단계---전송-완료-알림">4 단계 - 전송 완료 알림</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#전송-모드" id="markdown-toc-전송-모드">전송 모드</a></li>
  <li><a href="#현대-시스템에서의-dma-변화" id="markdown-toc-현대-시스템에서의-dma-변화">현대 시스템에서의 DMA 변화</a></li>
  <li><a href="#장점과-단점-요약" id="markdown-toc-장점과-단점-요약">장점과 단점 요약</a></li>
  <li><a href="#실무-예시" id="markdown-toc-실무-예시">실무 예시</a></li>
  <li><a href="#운영체제-관점" id="markdown-toc-운영체제-관점">운영체제 관점</a></li>
</ul>

<h2 id="dmadirect-memory-access란">DMA(Direct Memory Access)란?</h2>

<p>DMA는 CPU를 거치지 않고 I/O 장치가 주 메모리(RAM)에 직접 읽기·쓰기 할 수 있도록 시스템 버스를 “잠깐” 빌려서 데이터 블록을 전송하는 하드웨어 메커니즘</p>

<h2 id="왜-dma가-필요한가">왜 DMA가 필요한가?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">문제점(전통적 PIO)</th>
      <th style="text-align: center">DMA가 주는 이점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">CPU가 I/O 레지스터를 통해 바이트 단위로 데이터를 옮기면 레이턴시·오버헤드가 큼</td>
      <td style="text-align: center">한 번에 수십~수천 바이트 블록을 메모리로 직행 ⇒ CPU cycles 절약</td>
    </tr>
    <tr>
      <td style="text-align: center">빠른 장치(SSD, 10 GbE NIC 등)는 CPU 속도보다 I/O 대역폭이 큼 → CPU가 “목”이 됨</td>
      <td style="text-align: center">DMA 엔진이 버스 마스터로 동작해 메모리 버스를 직접 차단·사용</td>
    </tr>
    <tr>
      <td style="text-align: center">멀티코어 시대에 CPU는 계산에 집중하고 싶음</td>
      <td style="text-align: center">CPU는 전송 시작/종료만 관리 → I/O wait 시간 줄고, 캐시 miss도 감소</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>덕분에 대역폭·지연시간 모두 절감, 특히 디스크 I/O, 네트워크 카드, 오디오 스트리밍처럼 폭이 넓고 반복적인 전송에 필수적이다</li>
</ul>

<h2 id="기본-구성-요소">기본 구성 요소</h2>

<ol>
  <li>
    <p>DMA 컨트롤러(DMAC)</p>

    <ul>
      <li>
        <p>전용 칩(고전 ISA-DMA) 또는 주변장치 내부 DMA 엔진(PCIe, NVMe 컨트롤러)</p>
      </li>
      <li>
        <p>소스/목적지 물리 주소, 전송 길이, 모드, 제어 플래그 등을 저장하는 레지스터(메모리 맵 레지스터) 보유</p>
      </li>
      <li>
        <p>여러 채널이 있으면 동시에 여러 장치 지원</p>
      </li>
    </ul>
  </li>
  <li>
    <p>시스템 버스</p>

    <ul>
      <li>
        <p>CPU ↔ 메모리 ↔ DMA 컨트롤러가 공유</p>
      </li>
      <li>
        <p>CPU와 DMAC가 동시에 쓰지 않도록 <strong>버스 중재(bus arbitration)</strong> 를 수행</p>
      </li>
    </ul>
  </li>
  <li>
    <p>메모리 버스</p>

    <ul>
      <li>DMAC가 버스 마스터(master) 권한을 요청(Bus Request, BR) → 메모리와 직접 주고받음</li>
    </ul>
  </li>
  <li>
    <p>주변장치(Device)</p>

    <ul>
      <li>디스크, NIC, GPU, 오디오 코드 … 데이터가 실제로 존재/필요한 곳</li>
    </ul>
  </li>
  <li>
    <p>CPU &amp; OS</p>

    <ul>
      <li>전송 파라미터를 DMAC 레지스터에 써 주고, 완료 인터럽트(DMA done)를 처리</li>
    </ul>
  </li>
  <li>
    <p>I/O 장치(버스 마스터 가능 장치)</p>

    <ul>
      <li>PCIe NIC, NVMe SSD, GPU 등은 자체 DMA 엔진을 내장해 버스 마스터 가 되기도 한다</li>
    </ul>
  </li>
</ol>

<h3 id="dma-레지스터-src-dst-len">DMA 레지스터 SRC, DST, LEN</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">레지스터</th>
      <th style="text-align: center">역할</th>
      <th style="text-align: center">일반적 크기</th>
      <th style="text-align: center">세부 사항</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">SRC (Source Address)</td>
      <td style="text-align: center">읽어 올 원본 주소. 장치 → RAM 전송이면 장치 쪽 FIFO 주소, RAM → 장치 전송이면 RAM의 시작 주소</td>
      <td style="text-align: center">32 bit(SoC) 또는 64 bit(서버)</td>
      <td style="text-align: center">* 버스트·비버스트 여부, 버스트 길이에 따라 자동 증가(inc) 여부 선택 플래그 존재<br />* Scatter-Gather 모드에선 “다음 표(list) 항목” 주소로 해석되기도 함</td>
    </tr>
    <tr>
      <td style="text-align: center">DST (Destination Address)</td>
      <td style="text-align: center">쓰기 대상 주소</td>
      <td style="text-align: center">32/64 bit</td>
      <td style="text-align: center">* 자동 증가/고정 선택 가능 (예: 오디오 DAC 같은 스트리밍 장치는 고정 주소, 메모리 버퍼는 증가)</td>
    </tr>
    <tr>
      <td style="text-align: center">LEN (Length / Count)</td>
      <td style="text-align: center">총 바이트(혹은 워드) 수</td>
      <td style="text-align: center">16 bit(65 kB) ~ 32 bit(4 GB) 이상</td>
      <td style="text-align: center">* 전송이 끝날 때마다 LEN–; 0 → 인터럽트 발생<br />* 어떤 컨트롤러는 LEN 대신 COUNT×DATA_WIDTH 형태 사용</td>
    </tr>
  </tbody>
</table>

<p><strong>요약</strong> : SRC·DST는 “어디서 → 어디로”를, LEN은 “얼마나”를 알려주는 좌표 + 거리 정보라고 생각하면 된다</p>

<h2 id="동작-흐름-x86-pc-예시">동작 흐름 (x86 PC 예시)</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">신호선 &amp; 동작</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">① CPU 설정</td>
      <td style="text-align: center">DMAC 레지스터에 &lt;소스, 목적지, 길이, 모드&gt; 기록 후 Bus Request(BR) 활성화</td>
    </tr>
    <tr>
      <td style="text-align: center">② 버스 획득</td>
      <td style="text-align: center">CPU가 <em>Bus Grant(BG)</em>로 응답 → CPU 파이프라인이 버스를 놓고 다른 연산(레지스터 계산 등) 수행</td>
    </tr>
    <tr>
      <td style="text-align: center">③ 데이터 전송</td>
      <td style="text-align: center">DMAC가 메모리 ↔ 장치 간 버스 싸이클 생성</td>
    </tr>
    <tr>
      <td style="text-align: center">④ 완료 인터럽트</td>
      <td style="text-align: center">전송 길이가 0이 되면 DMAC가 CPU에 DMA 완료 인터럽트. CPU는 이후 버스 재획득</td>
    </tr>
  </tbody>
</table>

<p><strong>중요</strong> : DMAC가 버스를 잡은 동안 메모리 전체 버스 주도권을 갖기 때문에 CPU는 RAM을 전혀 접근하지 못한다. 개별 “주소 권한”이 아닌 “버스 소유권”의 문제다. 이 때문에 짝수 클럭마다 한 워드만 빼앗고 바로 돌려주는 Cycle Stealing 모드가 등장했다</p>

<h3 id="동작-흐름-더-자세히">동작 흐름 더 자세히</h3>

<p><img src="/assets/img/blog/computerscience/dma.png" alt="DMA" /></p>

<h4 id="1-단계---cpu까-준비만-하고-손을-뗀다">1 단계 - CPU까 준비만 하고 손을 뗀다</h4>

<ol>
  <li>
    <p>전송 파라미터 설정</p>

    <ul>
      <li>
        <p>SRC, DST, LEN, MODE을 레지스터에 값을 써 넣습니다</p>
      </li>
      <li>
        <p>마지막으로 Enable 플래그를 1로 두면 DMAC가 “이제 내가 처리할게!”하고 대기</p>
      </li>
    </ul>
  </li>
  <li>
    <p>버스 요청(BR 신호)</p>

    <ul>
      <li>DMAC는 버스 중재기(arbiter)에게 “버스 좀 빌려주세요” 라고 손을 듦</li>
    </ul>
  </li>
</ol>

<h4 id="2-단계---버스-소유권-교환">2 단계 - 버스 소유권 교환</h4>

<ol>
  <li>
    <p>CPU → DMAC ‘Bus Grant(BG)’</p>

    <ul>
      <li>
        <p>CPU가 진행 중인 버스 싸이클을 마치면 주소·데이터 라인을 tristate해 두고 계산 같은 비-버스 작업에 집중함</p>

        <ul>
          <li>
            <p>tristate란, 여러개의 마스터(CPU, DMAC, GPU…)가 하나의 전선을 공유하고, 한 쪽이 0V, 다른쪽이 동시에 Vcc를 내보내면 단락(short) 위험을 방지하고자 버스를 넘겨받은 쪽만 드라이버를 켜고 나머지는 Hi-Z로 물러나야 함</p>
          </li>
          <li>
            <p>버스가 필요 없는 작업이란, 파이프라인이 레지스터와 내부 캐시 만으로 실행 가능한 명령들</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>DMAC가 버스 장악</p>

    <ul>
      <li>
        <p>이 순간부터 RAM과 I/O 장치 사이를 오가는 모든 신호는 DMAC가 생성</p>
      </li>
      <li>
        <p>CPU는 RAM을 못 만지기 때문에 캐시 miss가 나도 대기해야 함</p>
      </li>
    </ul>
  </li>
</ol>

<h4 id="3-단계---실제-데이터-이동">3 단계 - 실제 데이터 이동</h4>

<ol>
  <li>
    <p>전송 모드에 따른 사이클</p>

    <ul>
      <li>
        <p>Burst/Block : LEN만큼 연속으로 → 최고속, 대신 CPU 길게 정지</p>
      </li>
      <li>
        <p>Cycle-Stealing : 한 사이클씩 “훔치고” 바로 돌려줌 → 실시간 오디어/비디오</p>
      </li>
      <li>
        <p>Scatter-Gather : 메모리 리스트 따라 다중 블록 자동 전송 → NVMe·NIC</p>
      </li>
    </ul>
  </li>
  <li>
    <p>주소·카운터 자동 증가</p>

    <ul>
      <li>DMAC 내부 카운터가 0이 될 때까지 SRC++, DST++, LEN–</li>
    </ul>
  </li>
</ol>

<h4 id="4-단계---전송-완료-알림">4 단계 - 전송 완료 알림</h4>

<ol>
  <li>
    <p>DMA 완료 인터럽트</p>

    <ul>
      <li>
        <p>LEN==0 → DMAC가 IRQ를 날리고 버스 요청을 내림</p>
      </li>
      <li>
        <p>CPU는 인터럽트 핸들러에서 데이터 후처리(예: 패킷 파싱, 디스크 블록 체크섬) 수행</p>
      </li>
    </ul>
  </li>
  <li>
    <p>버스 복귀</p>

    <ul>
      <li>Arbiter가 다시 CPU에 ‘Bus Grant’ → 평상시 메모리 접근 재개</li>
    </ul>
  </li>
</ol>

<h2 id="전송-모드">전송 모드</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">모드</th>
      <th style="text-align: center">특징</th>
      <th style="text-align: center">사용 예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Cycle-Stealing</td>
      <td style="text-align: center">버스 싸이클 1 개만 “훔친” 뒤 즉시 CPU에 반환 → CPU 지연 최소</td>
      <td style="text-align: center">실시간 오디오, 비디오 스트림</td>
    </tr>
    <tr>
      <td style="text-align: center">Block/Burst</td>
      <td style="text-align: center">전체 블록(혹은 버스트) 한 번에 전송 → 가장 빠르지만 CPU 길게 정지</td>
      <td style="text-align: center">SATA, SDIO, 대부분의 PCIe 장치</td>
    </tr>
    <tr>
      <td style="text-align: center">Demand/Scatter-Gather</td>
      <td style="text-align: center">장치가 필요할 때마다, 혹은 메모리 리스트 기반 다중 블록 이동</td>
      <td style="text-align: center">고성능 NIC, NVMe SSD, GPU VRAM 업로드</td>
    </tr>
  </tbody>
</table>

<h2 id="현대-시스템에서의-dma-변화">현대 시스템에서의 DMA 변화</h2>

<ol>
  <li>
    <p>PCIe Bus mastering - 주변장치가 메인 메모리를 완전히 “빌려” 직접 읽고/쓴다</p>
  </li>
  <li>
    <p>IOMMU(DMA-Remapping) - 가상화·보안 목적. 장치가 접근 가능한 주소를 OS가 테이블로 전환 → 버퍼 오염·DMA 공격 방어</p>
  </li>
  <li>
    <p>Cache coherency 문제 - CPU 캐시에 남은 더러운(line dirty) 데이터 vs DMA가 본 메모리 불일치. 해결 : dma_sync_*() - (Linux)·Cache flush, non-cacheable region, snoopint 버스.</p>
  </li>
  <li>
    <p>Zero-copy - 네트워크 스택이나 GPU ↔ CPU 사이에서 “복사 없는” 파이프라인 구축 (DPDK, RDMA, CUDA cudaMemcpyAsync 등)</p>

    <ul>
      <li>운영체제 버퍼를 추가로 “복사(copy)”하지 않고, 장치 ↔ 응용이 같은 메모리 페이지를 공유하도록 하는 기법. CPU가 불필요한 memcpy()를 안 하므로 지연과 캐시오염↓</li>
    </ul>
  </li>
  <li>
    <p>RDMA(Remode DMA) - NIC가 원격 호스트의 메모리에까지 DMA 쓰기/읽기를 수행. 커널 네트워크 스택을 우회하여 μs 단위 지연시간을 제공한다. 고속 HPC, 데이터베이스 복제에서 필수</p>
  </li>
</ol>

<h2 id="장점과-단점-요약">장점과 단점 요약</h2>

<p><strong>장점</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- CPU 사용률 감소, 전력 효율 ↑

- 대역폭 활용 극대화(PCIe Gen4 x4 ≈ 8 GB/s 급)

- 실시간 스트리밍 지원(오디오 스터터링 방지 등)
</code></pre></div></div>

<p><strong>단점</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 하드웨어·드라이버 복잡도 증가

- 버스 우선순위 조정 실패 시 CPU 지연 가능

- 캐시 일관성, 보안("DMA 공격") 이슈 처리 필요

    - IOMMU로 보완
</code></pre></div></div>

<h2 id="실무-예시">실무 예시</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">장치</th>
      <th style="text-align: center">DMA 활용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">SSD/NVMe</td>
      <td style="text-align: center">플래시 컨트롤러가 OS 버퍼를 읽어 와 NAND로 쓰기, 반대 방향 읽기</td>
    </tr>
    <tr>
      <td style="text-align: center">10 GbE NIC</td>
      <td style="text-align: center">패킷을 커널 버퍼나 XSP ring으로 직접 놓고, 완료 시 인터럽트</td>
    </tr>
    <tr>
      <td style="text-align: center">GPU</td>
      <td style="text-align: center">대용량 텍스처/버퍼를 PCIe로 복사하거나, VRAM↔CPU RAM pinned transfer</td>
    </tr>
    <tr>
      <td style="text-align: center">Audio Codec</td>
      <td style="text-align: center">PCM 버퍼를 주기적으로 DMA → DAC, 실시간 재생</td>
    </tr>
    <tr>
      <td style="text-align: center">USB 컨트롤러</td>
      <td style="text-align: center">호스트 메모리의 전송 링(Transfer Ring)을 DMA 로 순회</td>
    </tr>
  </tbody>
</table>

<h2 id="운영체제-관점">운영체제 관점</h2>

<ul>
  <li>
    <p>Linux : dma_map_single(), dma_alloc_coherent(), struct dma_async_tx_descriptor, DMAengine 프레임워크</p>
  </li>
  <li>
    <p>Windows : WdfDmaTransaction*, KeFlushIoBuffers(), Scatter/Gather 목록 지원</p>
  </li>
  <li>
    <p>RTOS(FreeRTOS, Zephyr) : MCU마다 별도의 DMAMUX &amp; HAP API 제공</p>
  </li>
</ul>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[여태까지 컴퓨터는 직접 메모리에 대해 접근하지 않고 가상 메모리를 사용하는 것으로 배웠는데, 만약 직접 메모리 접근이 있다면?]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>