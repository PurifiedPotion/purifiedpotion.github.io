<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-05-18T14:27:21+00:00</updated><id>/feed.xml</id><title type="html">PurifiedPotion’s Blog</title><subtitle>A blog for computer science
</subtitle><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><entry><title type="html">Donation</title><link href="/blog/computersystem/donation/" rel="alternate" type="text/html" title="Donation" /><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-15T00:00:00+00:00</updated><id>/blog/computersystem/donation</id><content type="html" xml:base="/blog/computersystem/donation/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#donation이란" id="markdown-toc-donation이란">Donation이란?</a></li>
  <li><a href="#왜-donation이-필요할까" id="markdown-toc-왜-donation이-필요할까">왜 Donation이 필요할까?</a></li>
  <li><a href="#해결-방법--priority-donation" id="markdown-toc-해결-방법--priority-donation">해결 방법 : Priority Donation</a></li>
</ul>

<h2 id="donation이란">Donation이란?</h2>

<p>Donation은 운영체제, 특히 <strong>스레드 우선순위(priority schedulling)</strong>가 있는 시스템에서 중요한 개념으로, <strong>(Priority Donation)</strong>를 의미합니다. 이 개념은 특히 PintOS 프로젝트나 스레드 동기화 구현에서 자주 등장합니다.</p>

<h2 id="왜-donation이-필요할까">왜 Donation이 필요할까?</h2>

<p>운영체제에서 스레드는 각자 <code class="language-plaintext highlighter-rouge">priority</code> 값을 가지고 CPU를 사용할 수 있는 기회를 경쟁합니다. 그런데 <strong>높은 우선순위를 가진 스레드가 낮은 우선순위를 가진 스레드 때문에 block 되는 상황</strong>이 생기면 문제가 됩니다. 이 현상을 <strong>우선순위 역전(Priority Inversion)</strong>이라고 합니다.</p>

<p><strong>예시:</strong></p>

<ol>
  <li>
    <p>낮은 우선순위 스레드 <code class="language-plaintext highlighter-rouge">L</code>이 lock을 잡고 실행 중</p>
  </li>
  <li>
    <p>높은 우선순위 스레드 <code class="language-plaintext highlighter-rouge">H</code>가 같은 lock을 acquire 하려다 block 됨</p>
  </li>
  <li>
    <p>CPU는 <code class="language-plaintext highlighter-rouge">H</code>를 먼저 실행해야 하는데, <code class="language-plaintext highlighter-rouge">L</code>이 lock을 쥐고 있어 실행을 못함</p>
  </li>
  <li>
    <p>그런데 <code class="language-plaintext highlighter-rouge">L</code>보다 약간 높은 중간 우선순위 스레드 <code class="language-plaintext highlighter-rouge">M</code>들이 계속 실행됨</p>
  </li>
  <li>
    <p>결과적으로 <code class="language-plaintext highlighter-rouge">H</code>는 오랫동안 block 되어 <strong>우선순위 역전 현상</strong> 발생</p>
  </li>
</ol>

<h2 id="해결-방법--priority-donation">해결 방법 : Priority Donation</h2>

<p>높은 우선순위 스레드가 낮은 우선순위 스레드에게 <strong>자신의 우선순위를 잠시 기부</strong>해서 CPU를 더 빨리 사용할 수 있도록 합니다.</p>

<p><strong>동작 방식</strong></p>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">H</code>가 <code class="language-plaintext highlighter-rouge">L</code>이 잡고 있는 lock을 기다릴 때, <code class="language-plaintext highlighter-rouge">L</code>에게 <code class="language-plaintext highlighter-rouge">H</code>의 우선순위를 임시로 부여 (donation)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">L</code>은 높은 우선순위로 빨리 실행되어 lock을 release</p>
  </li>
  <li>
    <p>lock을 release하면 다시 원래의 우선순위로 복원</p>
  </li>
</ul>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[임계구역에 대한 권한은 있지만, priority가 낮아서 일을 하고 있지 않는 상태라면, 모든 시스템이 작동이 중지될 위험이 있다. 이 상황을 방지하기 위해 Donation이 등장한다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">PintOS 1주차 thread 구현</title><link href="/blog/computersystem/pintos-thread/" rel="alternate" type="text/html" title="PintOS 1주차 thread 구현" /><published>2025-05-15T00:00:00+00:00</published><updated>2025-05-15T00:00:00+00:00</updated><id>/blog/computersystem/pintos-thread</id><content type="html" xml:base="/blog/computersystem/pintos-thread/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#alarm-clock---busy-waiting-에서-sleepwakeup-방식으로의-변경" id="markdown-toc-alarm-clock---busy-waiting-에서-sleepwakeup-방식으로의-변경">Alarm Clock - Busy Waiting 에서 Sleep/Wakeup 방식으로의 변경</a>    <ul>
      <li><a href="#busy-waiting이란" id="markdown-toc-busy-waiting이란">Busy Waiting이란?</a>        <ul>
          <li><a href="#busy-waiting의-문제점" id="markdown-toc-busy-waiting의-문제점">Busy Waiting의 문제점</a></li>
          <li><a href="#busy-waiting을-없애면" id="markdown-toc-busy-waiting을-없애면">Busy Waiting을 없애면?</a></li>
          <li><a href="#그래서-효율이-왜-좋아지나" id="markdown-toc-그래서-효율이-왜-좋아지나">그래서 효율이 왜 좋아지나?</a></li>
          <li><a href="#간단한-예시" id="markdown-toc-간단한-예시">간단한 예시</a></li>
          <li><a href="#요약" id="markdown-toc-요약">요약</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#busy-waiting-에서-sleepwakeup-방식으로의-병경-return" id="markdown-toc-busy-waiting-에서-sleepwakeup-방식으로의-병경-return">Busy Waiting 에서 Sleep/Wakeup 방식으로의 병경 return</a></li>
  <li><a href="#priority-scheduling---preemption기능과-semaphore-condition-variable의-우선순위-기능-구현" id="markdown-toc-priority-scheduling---preemption기능과-semaphore-condition-variable의-우선순위-기능-구현">Priority Scheduling - Preemption기능과 Semaphore, Condition Variable의 우선순위 기능 구현</a>    <ul>
      <li><a href="#preemption" id="markdown-toc-preemption">Preemption</a></li>
      <li><a href="#preemption-구현" id="markdown-toc-preemption-구현">Preemption 구현</a></li>
      <li><a href="#synchronization" id="markdown-toc-synchronization">Synchronization</a></li>
      <li><a href="#donation" id="markdown-toc-donation">Donation</a>        <ul>
          <li><a href="#one-donation" id="markdown-toc-one-donation">One Donation</a></li>
          <li><a href="#nested-donation" id="markdown-toc-nested-donation">Nested Donation</a></li>
          <li><a href="#multiple-donation" id="markdown-toc-multiple-donation">Multiple Donation</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#주의사항" id="markdown-toc-주의사항">주의사항</a></li>
</ul>

<p>이번 주차부터 PintOS 프로젝트가 시작 되었다. OS를 만드는 프로젝트이다 보니, 두려움이 있었지만, 다행히도 구현하기 위한 자료들이 hint를 많이 줘서 구현하는 데에는 크게 문제가 없었다. 다만 마지막 multiple donation에 관련한 코드들에 대해서는 조금 애먹는 부분이 있었다. 여기서는 Alarm Clock, Priority Scheduling에 대해서 다룰것이다. 그러면 thread 구현 처음부터 시작하겠다.</p>

<h2 id="alarm-clock---busy-waiting-에서-sleepwakeup-방식으로의-변경">Alarm Clock - Busy Waiting 에서 Sleep/Wakeup 방식으로의 변경</h2>

<p>현재 thread 같은 경우 busy Waiting 방식으로 구동되고 있다.</p>

<h3 id="busy-waiting이란">Busy Waiting이란?</h3>

<p>아래 그림처럼 어떤 리소스를 기달리 때 CPU를 계속 사용하면서 반복적으로 검사(polling)하는 방식이야.</p>

<p><img src="/assets/img/blog/computerscience/busywaiting.png" alt="Busy-waiting" /></p>

<h4 id="busy-waiting의-문제점">Busy Waiting의 문제점</h4>

<ul>
  <li>
    <p>CPU 낭비 : 프로그램이 실제로는 ‘기다리기만’하고 있음에도 CPU를 100% 사용한다는 점.</p>
  </li>
  <li>
    <p>다른 작업 불가 : 기다리는 동안 CPU가 다른 프로세스(또는 스레드)를 수행할 수가 없음.</p>
  </li>
  <li>
    <p>에너지 비효율 : 특히 모바일, 서버 환경에서는 불필요한 전력 소모를 일으킨다.</p>
  </li>
</ul>

<h4 id="busy-waiting을-없애면">Busy Waiting을 없애면?</h4>

<p>OS는 Busy Waiting 대신 <strong>“Blocking” (or “Sleep”)</strong>이라는 기법을 사용함.</p>

<ul>
  <li>
    <p>기다려야 할 일이 생기면 CPU를 반납하고, 자신은 Sleep 상태로 들어간다.</p>
  </li>
  <li>
    <p>CPU는 바로 다른 프로세스를 실행할 수 있게 됨.</p>
  </li>
  <li>
    <p>이벤트가 발생하면 OS가 해당 프로세스를 다시 깨운다(Wakeup).</p>
  </li>
  <li>
    <p>이 방법을 “Interrupt-driven” 방식이라고도 해.</p>
  </li>
</ul>

<h4 id="그래서-효율이-왜-좋아지나">그래서 효율이 왜 좋아지나?</h4>

<p><strong>→ CPU 사용률, 시스템 자원 효율, 에너지 소모 관점 모두 개선되기 때문</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">Busy Waiting</th>
      <th style="text-align: center">Blocking</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">CPU 사용</td>
      <td style="text-align: center">기다리는 동안 100%</td>
      <td style="text-align: center">기다릴 때 0% (다른 작업 실행)</td>
    </tr>
    <tr>
      <td style="text-align: center">웅답성</td>
      <td style="text-align: center">나쁨(CPU를 계속 점유)</td>
      <td style="text-align: center">좋음(필요할 때만 CPU 점유)</td>
    </tr>
    <tr>
      <td style="text-align: center">에너지 소모</td>
      <td style="text-align: center">높음</td>
      <td style="text-align: center">낮음</td>
    </tr>
    <tr>
      <td style="text-align: center">시스템 처리량</td>
      <td style="text-align: center">낮음</td>
      <td style="text-align: center">높음</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>시스템 전체로 보면 훨씬 많은 프로세스가 공정하게 실행될 수 있게 됨.</p>
  </li>
  <li>
    <p>사용자가 체감하는 반응성도 좋아진다.</p>
  </li>
  <li>
    <p>서버 입장에서도 <strong>병렬 처리량(throughput)</strong>이 훨씬 올라간다.</p>
  </li>
</ul>

<h4 id="간단한-예시">간단한 예시</h4>

<p>만약 100개의 프로세스가 어떤 이벤트를 기다린다고 해보자.</p>

<ul>
  <li>
    <p>Busy Waiting이면 100개 모두 CPU를 쓰려고 하니까,</p>

    <ul>
      <li>CPU가 1개일 경우 전혀 다른 일을 못 해.</li>
    </ul>
  </li>
  <li>
    <p>Blocking이면,</p>

    <ul>
      <li>
        <p>99개는 잠자고, 필요한 프로세스만 CPU를 쓴다.</p>
      </li>
      <li>
        <p>CPU는 다른 요처도 병행 처리할 수 있어.</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="요약">요약</h4>

<p><strong>Busy Waiting을 없애고 Blocking으로 바꾸면,</strong></p>

<ul>
  <li>
    <p>CPU 낭비 없이</p>
  </li>
  <li>
    <p>동시에 여러 작업을 잘 처리할 수 있게 되고</p>
  </li>
  <li>
    <p>에너지도 절약하고</p>
  </li>
  <li>
    <p>사용자 응답성(인터렉티브성)도 좋아진다.</p>
  </li>
</ul>

<h2 id="busy-waiting-에서-sleepwakeup-방식으로의-병경-return">Busy Waiting 에서 Sleep/Wakeup 방식으로의 병경 return</h2>

<p>그러면 어떤 구조로 바꾸어야 할까? 아래와 같이 sleep_list를 하나 만들어서 wakeup_tick(alarm 시간)만큼 쉬게 할 thread를 넣어주고, wakeup_tick이 도달하면 ready_list에 넣어주는 구조로 바꾸어야 한다.</p>

<p><img src="/assets/img/blog/computerscience/sleepwakeup.png" alt="Sleep-Wakeup" /></p>

<p>그러기 위해선 sleep_list 구조체를 ready_list와 동일하게 thread.c 파일 상단에 선언해주고 global_tick(sleep_list의 최소 wakeup_tick값)을 선언해 주었다. 여기서 처음에 INT64_MAX값으로 선언한 이유는, global_tick은 sleep_list에 들어가서 깨울 thread가 있는지 확인하기 위함인데, 일단은 아무것도 없을때, 확인하러 들어가지 않게끔 하려고 MAX로 선언하였다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int64_t</span> <span class="n">global_tick</span> <span class="o">=</span> <span class="n">INT64_MAX</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list</span> <span class="n">ready_list</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list</span> <span class="n">sleep_list</span><span class="p">;</span>
</code></pre></div></div>

<p>thread_init이 될때, sleep_list가 초기화 되면서 list로써의 기능을 할 수 있게 list_init함수를 써주었다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">thread_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">intr_get_level</span> <span class="p">()</span> <span class="o">==</span> <span class="n">INTR_OFF</span><span class="p">);</span>

	<span class="cm">/* Reload the temporal gdt for the kernel
	 * This gdt does not include the user context.
	 * The kernel will rebuild the gdt with user context, in gdt_init (). */</span>
	<span class="k">struct</span> <span class="n">desc_ptr</span> <span class="n">gdt_ds</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">// x86 에서 세그먼트 테이블 정의</span>
		<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">gdt</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">gdt</span>
	<span class="p">};</span>
	<span class="n">lgdt</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">gdt_ds</span><span class="p">);</span>

	<span class="cm">/* Init the globla thread context */</span>
	<span class="n">lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tid_lock</span><span class="p">);</span> <span class="c1">// 쓰레드 tid 할당 락 (세마포어로 되어있음)</span>
	<span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">);</span> <span class="c1">// 쓰레드 ready 리스트</span>
	<span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">);</span> <span class="c1">// 쓰레드 sleep 리스트</span>
	<span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">destruction_req</span><span class="p">);</span> <span class="c1">//삭제 예약된 스레드들의 리스트</span>

	<span class="cm">/* Set up a thread structure for the running thread. */</span>
	<span class="n">initial_thread</span> <span class="o">=</span> <span class="n">running_thread</span> <span class="p">();</span>
	<span class="n">init_thread</span> <span class="p">(</span><span class="n">initial_thread</span><span class="p">,</span> <span class="s">"main"</span><span class="p">,</span> <span class="n">PRI_DEFAULT</span><span class="p">);</span>
	<span class="n">initial_thread</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">THREAD_RUNNING</span><span class="p">;</span>
	<span class="n">initial_thread</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">allocate_tid</span> <span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>sleep_list에서 깨울 thread의 기준이 되는 wakeup_tick을 struct thread에 추가해준다</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="kr">thread</span> <span class="p">{</span>
	<span class="cm">/* Owned by thread.c. */</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>                          <span class="cm">/* Thread identifier. */</span>
	<span class="k">enum</span> <span class="n">thread_status</span> <span class="n">status</span><span class="p">;</span>          <span class="cm">/* Thread state. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>                      <span class="cm">/* Name (for debugging purposes). */</span>
	<span class="kt">int64_t</span> <span class="n">wakeup_tick</span><span class="p">;</span>				<span class="c1">// 깨울시간</span>
	<span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>                       <span class="cm">/* Priority. */</span>
	<span class="kt">int</span> <span class="n">original_priority</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list</span> <span class="n">donations</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_elem</span> <span class="n">d_elem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock</span> <span class="o">*</span><span class="n">wait_on_lock</span><span class="p">;</span>

	<span class="cm">/* Shared between thread.c and synch.c. */</span>
	<span class="k">struct</span> <span class="n">list_elem</span> <span class="n">elem</span><span class="p">;</span>              <span class="cm">/* List element. */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>위 과정을 진행하였으면, 이제 timer_sleep에서 Busy Waiting을 Sleep/Wakeup 구조로 바꿀 때가 되었다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">timer_sleep</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">ticks</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int64_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">timer_ticks</span> <span class="p">();</span>

	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">intr_get_level</span> <span class="p">()</span> <span class="o">==</span> <span class="n">INTR_ON</span><span class="p">);</span>
	<span class="c1">// while (timer_elapsed (start) &lt; ticks)</span>
	<span class="c1">// 	thread_yield ();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_elapsed</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ticks</span><span class="p">)</span> 
		 <span class="n">thread_sleep</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">ticks</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위에서 thread_sleep으로 넘어가니, thread_sleep에서도 구조를 바꿔줘야 한다.</p>

<p>wakeup_tick에 ticks값이 저장되도록 하고, sleep_list에 정렬 삽입을 통해 깨울 시간이 임박한것이 제일 앞에 오게끔 한다. 그런 후 updat_global_tick 함수 같은 경우 편의상 추가했는데, 이 함수를 통해서 global_tick이 sleep_list에서 최소값으로 갱신되게끔 한다. 함수 내용은 아래에 추가하였다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">thread_sleep</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">ticks</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thread_current</span><span class="p">()</span> <span class="o">!=</span> <span class="n">idle_thread</span><span class="p">){</span>
		<span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span><span class="p">();</span>
		<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">thread_current</span><span class="p">();</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">wakeup_tick</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">;</span>

		<span class="c1">// 정렬 삽입</span>
		<span class="n">list_insert_ordered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">,</span> <span class="n">cmp_wakeup_tick</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="c1">// global tick 갱신</span>
		<span class="n">update_global_tick</span><span class="p">();</span>


		<span class="n">thread_block</span><span class="p">();</span> <span class="c1">// block 상태로 변경</span>
		<span class="n">intr_set_level</span><span class="p">(</span><span class="n">old_level</span><span class="p">);</span> <span class="c1">// 인터럽트 disable 해제</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="c1">// 추가 함수 : 깨어날 순으로 오름차순 정렬 함수</span>
<span class="n">cmp_wakeup_tick</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">list_elem</span> <span class="o">*</span><span class="n">a_</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">list_elem</span> <span class="o">*</span><span class="n">b_</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span> <span class="n">UNUSED</span><span class="p">){</span> 
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">a_</span><span class="p">,</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">b_</span><span class="p">,</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">wakeup_tick</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">wakeup_tick</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_global_tick</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 추가 함수 : global_ticks 작은 값으로 초기화</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">)){</span>
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">),</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
	<span class="n">global_tick</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">wakeup_tick</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">else</span><span class="p">{</span>
		<span class="n">global_tick</span> <span class="o">=</span> <span class="n">INT64_MAX</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>timer_interrupt에서는 global_tick을 확인해주는 check_global_tick 함수를 통해서 wakeup_thread가 실행되게끔 한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Timer interrupt handler. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="c1">// timer_interrupt 가 일어났을때 확인할 것 !</span>
<span class="n">timer_interrupt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">intr_frame</span> <span class="o">*</span><span class="n">args</span> <span class="n">UNUSED</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ticks</span><span class="o">++</span><span class="p">;</span>
	<span class="n">thread_tick</span> <span class="p">();</span> <span class="c1">// running 스레드의 cpu 사용량 업데이트</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_global_tick</span><span class="p">(</span><span class="n">ticks</span><span class="p">))</span>
		<span class="n">wakeup_thread</span> <span class="p">(</span><span class="n">ticks</span><span class="p">);</span> <span class="c1">// 깨울친구 찾아가기</span>
<span class="p">}</span>

<span class="n">bool</span>
<span class="nf">check_global_tick</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">ticks</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">ticks</span> <span class="o">&gt;=</span> <span class="n">global_tick</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> 
<span class="nf">wakeup_thread</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">target_ticks</span><span class="p">){</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_elem</span> <span class="o">*</span><span class="n">target_ele</span> <span class="o">=</span> <span class="n">list_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">);</span>
		<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">target_ele</span><span class="p">,</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">wakeup_tick</span> <span class="o">&lt;=</span> <span class="n">target_ticks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_remove</span><span class="p">(</span><span class="n">target_ele</span><span class="p">);</span>
			<span class="n">thread_unblock</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//갱신</span>
	<span class="n">update_global_tick</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 수정한다면, 아래와 같이 결과가 나온다.</p>

<p><img src="/assets/img/blog/computerscience/alarmresult.png" alt="Alarm-result" /></p>

<h2 id="priority-scheduling---preemption기능과-semaphore-condition-variable의-우선순위-기능-구현">Priority Scheduling - Preemption기능과 Semaphore, Condition Variable의 우선순위 기능 구현</h2>

<p>구현에 앞서, Preemption과 Semaphore, Condition Variable의 우선순위 기능을 어떻게 구현할지 설명하겠다.</p>

<h3 id="preemption">Preemption</h3>

<p>Preemption이란 선취권이라는 뜻으로 여기서는 ready_list에 thread가 들어갈 때, 현재 작동중인 running_thread와의 priority를 비교했을 때, running_thread보다 높다면 running_thread를 재우고 ready_list에서 제일 높은 priority를 갖는 thread를 running 시키겠다는 의미이다.</p>

<h3 id="preemption-구현">Preemption 구현</h3>

<p>먼저 thread_create() 될때, priority가 설정되면서 ready_list에 넣어진다. 그렇지만, 여기서 ready_list에 넣어진 후 위에서 언급한 기능 추가를 위해 thread_ready_check()함수를 썼다. 이 함수는 현재 작동중인 thread의 priority와 thread_create되는 thread의 priority를 비교하고 그 조건에 따라서 thread_yield()되는 함수이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tid_t</span>
<span class="nf">thread_create</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">,</span>
		<span class="n">thread_func</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>

	<span class="c1">// 새로운 스레드를 생성할 때 커널 스택 할당</span>
	<span class="c1">// 실행할 함수로 start_process를 등록</span>
	<span class="c1">// 이 스레드를 ready_list에 추가함</span>

	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">function</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Allocate thread. */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">palloc_get_page</span> <span class="p">(</span><span class="n">PAL_ZERO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">TID_ERROR</span><span class="p">;</span>

	<span class="cm">/* Initialize thread. */</span>
	<span class="n">init_thread</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
	<span class="n">tid</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">allocate_tid</span> <span class="p">();</span>

	<span class="cm">/* Call the kernel_thread if it scheduled.
	 * Note) rdi is 1st argument, and rsi is 2nd argument. */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">rip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">kernel_thread</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">rdi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">function</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">rsi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">aux</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">ds</span> <span class="o">=</span> <span class="n">SEL_KDSEG</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="n">SEL_KDSEG</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">ss</span> <span class="o">=</span> <span class="n">SEL_KDSEG</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">SEL_KCSEG</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">eflags</span> <span class="o">=</span> <span class="n">FLAG_IF</span><span class="p">;</span>

	<span class="cm">/* Add to run queue. */</span>
	<span class="n">thread_unblock</span> <span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="n">thread_ready_check</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">thread_ready_check</span> <span class="p">(</span><span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">thread_current</span><span class="p">()</span> <span class="o">!=</span> <span class="n">idle_thread</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">thread_current</span> <span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span>
		<span class="n">thread_yield</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>thread_unblock 함수에서는 priority 기준으로 ready_list에 들어가게끔 수정해준다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">thread_unblock</span> <span class="p">(</span><span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span><span class="p">;</span>

	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">is_thread</span> <span class="p">(</span><span class="n">t</span><span class="p">));</span>

	<span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span> <span class="p">();</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">THREAD_BLOCKED</span><span class="p">);</span>
	<span class="n">list_insert_ordered</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">,</span> <span class="n">cmp_priority</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">THREAD_READY</span><span class="p">;</span>
	<span class="n">intr_set_level</span> <span class="p">(</span><span class="n">old_level</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>현재 thread가 priority가 낮은 이유로 thread_yield가 된다고 했을 때, 이때도 마찬가지로 ready_list에 정렬되어서 들어가게 수정했다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">thread_yield</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">thread_current</span> <span class="p">();</span>
	<span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span><span class="p">;</span>

	<span class="n">ASSERT</span> <span class="p">(</span><span class="o">!</span><span class="n">intr_context</span> <span class="p">());</span>

	<span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span> <span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">idle_thread</span><span class="p">)</span>
		<span class="n">list_insert_ordered</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">,</span> <span class="n">cmp_priority</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">do_schedule</span> <span class="p">(</span><span class="n">THREAD_READY</span><span class="p">);</span>
	<span class="n">intr_set_level</span> <span class="p">(</span><span class="n">old_level</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>thread_set_priority 함수는 도중에 running_thread의 priority를 바꾸는 함수인데, 이때 ready_list의 최대 priority보다 낮게 변경되면, 이때도 preemption을 위해 아래와 같이 thread_ready_check()함수를 추가해 줬다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Sets the current thread's priority to NEW_PRIORITY. */</span>
<span class="kt">void</span>
<span class="nf">thread_set_priority</span> <span class="p">(</span><span class="kt">int</span> <span class="n">new_priority</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">thread_current</span> <span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">new_priority</span><span class="p">;</span>
	<span class="c1">// list_sort(&amp;ready_list, cmp_priority, NULL);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">))</span>
		<span class="n">thread_ready_check</span><span class="p">(</span><span class="n">list_entry</span><span class="p">(</span><span class="n">list_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">),</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 3가지 함수를 고치면, preemption구현은 완료된 상태이다.</p>

<h3 id="synchronization">Synchronization</h3>

<p>그렇다면, 위에서 언급한 semaphore, condition variable, lock에 대해서 설명하자면, <a href="../../computersystem/lock-semaphore-condition" class="heading flip-title">동기화 기법 3대장 : Lock/Semaphore/Condition Variable</a>에 나와 있다.</p>

<h3 id="donation">Donation</h3>

<p>Donation도 마찬가지로 개념은 <a href="../../computersystem/donation" class="heading flip-title">Donation</a>에 나와 있다. 개념 외적으로, 여기서 구현할 Donation에 대해 알려주겠다.</p>

<h4 id="one-donation">One Donation</h4>

<p>가장 기본적인 Donation으로, lock이 된 semaphore의 waiter리스트에 있는 thread중 priority가 제일 높은 값으로 donation되는것이다.</p>

<p><img src="/assets/img/blog/computerscience/donationone.png" alt="Donation One" /></p>

<h4 id="nested-donation">Nested Donation</h4>

<p>아래 사진처럼, lock을 갖고 있는 thread가 또 다른 lock의 waiter일때의 경우에 적용되는데, priority가 제일 높은 thread 기준으로 요청하고 있는 lock쪽으로 donation이 되는 원리이다.</p>

<p><img src="/assets/img/blog/computerscience/nesteddonation.png" alt="Nested Donation" /></p>

<h4 id="multiple-donation">Multiple Donation</h4>

<p>하나의 thread가 여러개의 lock을 갖고 있을때의 경우이다. 이런 경우에는, 모든 lock에 대한 waiter중 제일 높은 priority가 donation되는것이다. 제일 높은 priority를 내준 thread에게 lock 권한을 넘겨주면, 알래 사진 기준으로 T1의 priority는 T4보다 낮은 제일 높은 priority를 갖게 되고 일할 권한은 T4가 가지게 된다.</p>

<p><img src="/assets/img/blog/computerscience/multipledonation.png" alt="Multiple Donation" /></p>

<p>다른 예를 들어보자, 아래 그림을 보았을때, T3가 T4에게 lock을 넘겨준 후의 얘기이다. 보면, T3의 priority는 계속 높기 때문에, T4는 일을 아직 하지 못한다. T3가 T6가 요청한 lock을 넘겨주고 T6가 모든일을 마쳤을 경우에만, T4가 일을 할 수 있다.</p>

<p><img src="/assets/img/blog/computerscience/multipledonated.png" alt="Multiple Donation" /><img src="/assets/img/blog/computerscience/t3stillrunning.png" alt="Multiple Donation" /></p>

<h2 id="주의사항">주의사항</h2>

<ul>
  <li>list에 변경 작업이 있을시에는 interrupt를 끄고 작업후에는 키는것이 좋다고 한다.</li>
</ul>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[이 글에서는 PintOS 첫주차에 thread 구현에 관련하여서 다루겠다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">프로세스(Process)</title><link href="/blog/computersystem/process/" rel="alternate" type="text/html" title="프로세스(Process)" /><published>2025-05-13T00:00:00+00:00</published><updated>2025-05-13T00:00:00+00:00</updated><id>/blog/computersystem/process</id><content type="html" xml:base="/blog/computersystem/process/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#프로세스processs란" id="markdown-toc-프로세스processs란">프로세스(Processs)란?</a></li>
  <li><a href="#프로세스의-주요-특징" id="markdown-toc-프로세스의-주요-특징">프로세스의 주요 특징</a></li>
  <li><a href="#프로세스의-메모리-구조-4영역" id="markdown-toc-프로세스의-메모리-구조-4영역">프로세스의 메모리 구조 (4영역)</a></li>
  <li><a href="#프로세스의-상태-state" id="markdown-toc-프로세스의-상태-state">프로세스의 상태 (State)</a></li>
  <li><a href="#프로세스와-스레드" id="markdown-toc-프로세스와-스레드">프로세스와 스레드</a></li>
  <li><a href="#프로세스-간-통신-ipc" id="markdown-toc-프로세스-간-통신-ipc">프로세스 간 통신 (IPC)</a></li>
  <li><a href="#요약" id="markdown-toc-요약">요약</a></li>
</ul>

<h2 id="프로세스processs란">프로세스(Processs)란?</h2>

<p><strong>프로세스(Process)</strong>는</p>

<blockquote>
  <p>“실행 중인 프로그램”을 뜻해.</p>
</blockquote>

<ul>
  <li>
    <p>프로그램은 단지 디스크에 저장된 정적인 파일이야. (<code class="language-plaintext highlighter-rouge">.exe</code>, <code class="language-plaintext highlighter-rouge">.out</code>, <code class="language-plaintext highlighter-rouge">.py</code> 같은 것들)</p>
  </li>
  <li>
    <p>이 프로그램을 실행하면, <strong>운영체제(OS)</strong>가 이 프로그램을 <strong>메모리(RAM)</strong>에 올리고, CPU가 실행할 수 있도록 준비하는데, 이 상태를 <strong>프로세스</strong>라고 불러.</p>
  </li>
</ul>

<p>즉,</p>

<ul>
  <li>
    <p>프로그램 ≠ 프로세스</p>
  </li>
  <li>
    <p>“프로그램”을 실행 중인 것이 “프로세스”야.</p>
  </li>
</ul>

<h2 id="프로세스의-주요-특징">프로세스의 주요 특징</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">구분</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">고유한 메모리 공간</td>
      <td style="text-align: center">코드, 데이터, 스택, 힙 등의 독립적인 메모리 구조를 가짐</td>
    </tr>
    <tr>
      <td style="text-align: center">고유한 PID</td>
      <td style="text-align: center">OS는 각 프로세스를 식별하기 위해 <strong>Process ID(PID)</strong>를 부여함</td>
    </tr>
    <tr>
      <td style="text-align: center">자원(Resource) 소유</td>
      <td style="text-align: center">파일 디스크립터, 메모리, CPU 시간 등을 소유함</td>
    </tr>
    <tr>
      <td style="text-align: center">독립성</td>
      <td style="text-align: center">프로세스끼리는 기본적으로 메모리를 공유하지 않고 독립적으로 동작함</td>
    </tr>
    <tr>
      <td style="text-align: center">생명주기</td>
      <td style="text-align: center">생성(Create) → 준비(Ready) → 실행(Running) → 대기(Waiting) → 종료(Terminated) 흐름을 가짐</td>
    </tr>
  </tbody>
</table>

<h2 id="프로세스의-메모리-구조-4영역">프로세스의 메모리 구조 (4영역)</h2>

<p>프로세스가 메모리 위에 올라오면 이렇게 4개의 영역으로 나뉘어.</p>

<div class="language-scss highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="err">┌───────────────┐</span>
  <span class="err">│</span>    <span class="nt">Stack</span>      <span class="err">│</span>  <span class="err">➔</span> <span class="err">함수</span> <span class="err">호출</span> <span class="err">시</span> <span class="err">지역변수</span><span class="o">,</span> <span class="err">매개변수</span> <span class="err">저장</span>
  <span class="err">├───────────────┤</span>
  <span class="err">│</span>     <span class="nt">Heap</span>      <span class="err">│</span>  <span class="err">➔</span> <span class="err">동적</span> <span class="err">메모리</span> <span class="err">할당</span> <span class="err">영역</span> <span class="o">(</span><span class="nt">malloc</span><span class="o">,</span> <span class="nt">new</span><span class="o">)</span>
  <span class="err">├───────────────┤</span>
  <span class="err">│</span>   <span class="nt">Data</span> <span class="err">영역</span>   <span class="err">│</span>  <span class="err">➔</span> <span class="err">전역변수</span><span class="o">,</span> <span class="nt">static</span> <span class="err">변수</span> <span class="err">저장</span>
  <span class="err">├───────────────┤</span>
  <span class="err">│</span>    <span class="nt">Code</span> <span class="err">영역</span>  <span class="err">│</span>  <span class="err">➔</span> <span class="err">실행할</span> <span class="err">프로그램</span> <span class="err">코드</span> <span class="o">(</span><span class="err">명령어</span><span class="o">)</span> <span class="err">저장</span>
  <span class="err">└───────────────┘</span>
</code></pre></div></div>

<ul>
  <li>
    <p><strong>Stack</strong> : 함수 호출마다 자동으로 push/pop되는 메모리 (ex. 지역 변수)</p>
  </li>
  <li>
    <p><strong>Heap</strong> : 개발자가 직접 <code class="language-plaintext highlighter-rouge">malloc</code>, <code class="language-plaintext highlighter-rouge">new</code>로 할당하고 <code class="language-plaintext highlighter-rouge">free</code>, <code class="language-plaintext highlighter-rouge">delete</code>로 해제해야 하는 메모리</p>
  </li>
  <li>
    <p><strong>Data</strong> : 전역변수나 static 변수 저장</p>
  </li>
  <li>
    <p><strong>Code</strong> : 컴파일된 명령어(machine code)</p>
  </li>
</ul>

<h2 id="프로세스의-상태-state">프로세스의 상태 (State)</h2>

<p>프로세스는 CPU에서 실행되면서 다양한 상태를 가진다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">상태</th>
      <th style="text-align: center">의미</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">New</td>
      <td style="text-align: center">프로그램이 메모리에 적재되는 중</td>
    </tr>
    <tr>
      <td style="text-align: center">Ready</td>
      <td style="text-align: center">CPU를 받을 준비가 된 상태</td>
    </tr>
    <tr>
      <td style="text-align: center">Running</td>
      <td style="text-align: center">CPU를 점유해서 실제 실행 중인 상태</td>
    </tr>
    <tr>
      <td style="text-align: center">Waiting</td>
      <td style="text-align: center">어떤 이벤트(I/O 등)를 기다리는 상태</td>
    </tr>
    <tr>
      <td style="text-align: center">Terminated</td>
      <td style="text-align: center">실행이 끝나서 종료된 상태</td>
    </tr>
  </tbody>
</table>

<p>(※ 프로세스는 보통 Ready ↔ Running ↔ Waiting 을 반복하다가 종료돼.)</p>

<h2 id="프로세스와-스레드">프로세스와 스레드</h2>

<ul>
  <li>
    <p><strong>프로세스</strong> : 완전히 독립된 실행 단위</p>
  </li>
  <li>
    <p><strong>스레드</strong> : 프로세스 안에 있는 작업 단위(같은 메모리 공간을 공유)</p>
  </li>
</ul>

<blockquote>
  <p>“프로세스는 집이고, 스레드는 집안에 있는 가족”이라고 비유할 수 있어.</p>
</blockquote>

<ul>
  <li>
    <p>프로세스끼리는 서로 <strong>독립적</strong>이지만,</p>
  </li>
  <li>
    <p>같은 프로세스 안의 스레드들은 <strong>메모리를 공유</strong>해.</p>
  </li>
</ul>

<h2 id="프로세스-간-통신-ipc">프로세스 간 통신 (IPC)</h2>

<p>서로 독립적인 프로세스끼리 정보를 주고받기 위해 여러 방법을 사용해.</p>

<p><strong>주요 방법들</strong></p>

<ul>
  <li>
    <p><strong>Pipe(파이프)</strong></p>
  </li>
  <li>
    <p><strong>Message Queue(메시지 큐)</strong></p>
  </li>
  <li>
    <p><strong>Shared Memory(공유 메모리)</strong></p>
  </li>
  <li>
    <p><strong>Socket(소켓 통신)</strong></p>
  </li>
  <li>
    <p><strong>Signal(시그널)</strong></p>
  </li>
</ul>

<blockquote>
  <p>왜냐하면, 기본적으로 프로세스끼리는 서로 메모리를 공유하지 않기 때문이야.</p>
</blockquote>

<h2 id="요약">요약</h2>

<blockquote>
  <p>프로세스는 실행 중인 프로그램이고,
고유한 메모리 공간과 자원을 소유하며,
여러 상태를 가지면서 실행된다.</p>
</blockquote>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">스레드(Thread) 심화</title><link href="/blog/computersystem/thread-advanced/" rel="alternate" type="text/html" title="스레드(Thread) 심화" /><published>2025-05-13T00:00:00+00:00</published><updated>2025-05-13T00:00:00+00:00</updated><id>/blog/computersystem/thread-advanced</id><content type="html" xml:base="/blog/computersystem/thread-advanced/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#스레드-스케줄링-전략-scheduling-policy" id="markdown-toc-스레드-스케줄링-전략-scheduling-policy">스레드 스케줄링 전략 (Scheduling Policy)</a>    <ul>
      <li><a href="#fifo-first-in-first-out-선입선출" id="markdown-toc-fifo-first-in-first-out-선입선출">FIFO (First-In, First-Out, 선입선출)</a></li>
      <li><a href="#round-robin-라운드-로빈" id="markdown-toc-round-robin-라운드-로빈">Round Robin (라운드 로빈)</a></li>
      <li><a href="#priority-scheduling-우선순위-스케줄링" id="markdown-toc-priority-scheduling-우선순위-스케줄링">Priority Scheduling (우선순위 스케줄링)</a></li>
      <li><a href="#shortest-job-first-sjf" id="markdown-toc-shortest-job-first-sjf">Shortest Job First (SJF)</a></li>
      <li><a href="#multilevel-queue-scheduling-다단계-큐-스케줄링" id="markdown-toc-multilevel-queue-scheduling-다단계-큐-스케줄링">Multilevel Queue Scheduling (다단계 큐 스케줄링)</a></li>
    </ul>
  </li>
  <li><a href="#스케줄링-타이밍-scheduling-timing" id="markdown-toc-스케줄링-타이밍-scheduling-timing">스케줄링 타이밍 (Scheduling Timing)</a>    <ul>
      <li><a href="#선점형-스케줄링-preemptive-scheduling" id="markdown-toc-선점형-스케줄링-preemptive-scheduling">선점형 스케줄링 (Preemptive Scheduling)</a></li>
      <li><a href="#비선점형-스케줄링-non-preemptive-scheduling" id="markdown-toc-비선점형-스케줄링-non-preemptive-scheduling">비선점형 스케줄링 (Non-Preemptive Scheduling)</a></li>
      <li><a href="#요약" id="markdown-toc-요약">요약</a></li>
    </ul>
  </li>
  <li><a href="#user-level-threadult-vs-kernel-level-threadklt-스케줄링-차이" id="markdown-toc-user-level-threadult-vs-kernel-level-threadklt-스케줄링-차이">User-Level Thread(ULT) vs Kernel-Level Thread(KLT) 스케줄링 차이</a></li>
  <li><a href="#실전에서-스케줄링은-어떻게-동작할까" id="markdown-toc-실전에서-스케줄링은-어떻게-동작할까">실전에서 스케줄링은 어떻게 동작할까?</a></li>
  <li><a href="#현대-os-예시" id="markdown-toc-현대-os-예시">현대 OS 예시</a></li>
  <li><a href="#심화--cfscompletely-fair-scheduler-아주-간단-설명" id="markdown-toc-심화--cfscompletely-fair-scheduler-아주-간단-설명">심화 : CFS(Completely Fair Scheduler) 아주 간단 설명</a></li>
  <li><a href="#스레드-스케줄링-요약" id="markdown-toc-스레드-스케줄링-요약">스레드 스케줄링 요약</a></li>
</ul>

<p>스레드의 기초적인 개념에 대해서는 <a href="../../computersystem/thread" class="heading flip-title">스레드(Thread)</a>에서 다루었다.</p>

<h2 id="스레드-스케줄링-전략-scheduling-policy">스레드 스케줄링 전략 (Scheduling Policy)</h2>

<p>스레드를 선택할 때 사용하는 “우선순위”나 “기준”을 말해. 주요 방식은 다음과 같아.</p>

<h3 id="fifo-first-in-first-out-선입선출">FIFO (First-In, First-Out, 선입선출)</h3>

<ul>
  <li>
    <p>먼저 Ready 상태가 된 스레드가 먼저 CPU를 사용.</p>
  </li>
  <li>
    <p>단순하고 공정하지만, 긴 작업이 먼저 오면 다른 짧은 작업이 오래 기다려야 할 수 있음.</p>
  </li>
</ul>

<h3 id="round-robin-라운드-로빈">Round Robin (라운드 로빈)</h3>

<ul>
  <li>
    <p>각 스레드에 시간 조각(time slice 또는 quantum)을 나눠서 순서대로 CPU를 줌.</p>
  </li>
  <li>
    <p>한 번에 오래 점유 못하고, 조금만 CPU를 쓰고 다른 스레드에게 넘김.</p>
  </li>
  <li>
    <p>반응성 좋은 시스템을 만드는 데 유리해 (예: 서버, 게임).</p>
  </li>
</ul>

<h3 id="priority-scheduling-우선순위-스케줄링">Priority Scheduling (우선순위 스케줄링)</h3>

<ul>
  <li>
    <p>스레드마다 우선순위를 부여하고, 우선순위가 높은 스레드를 먼저 실행.</p>
  </li>
  <li>
    <p>Priority Inversion(우선순위 반전) 문제가 생길 수 있어 → 별도로 대응 필요(Mutex 상속 같은 기법 사용).</p>
  </li>
</ul>

<h3 id="shortest-job-first-sjf">Shortest Job First (SJF)</h3>

<ul>
  <li>
    <p>실행 시간이 짧은 작업을 먼저 실행.</p>
  </li>
  <li>
    <p>평균 대기 시간은 최적이지만, 스레드의 실행 시간을 미리 알아야 해서 실제로는 구현이 어려움.</p>
  </li>
</ul>

<h3 id="multilevel-queue-scheduling-다단계-큐-스케줄링">Multilevel Queue Scheduling (다단계 큐 스케줄링)</h3>

<ul>
  <li>
    <p>스레드를 여러 “큐”로 나눔 (예: 인터랙티브 작업, 배치 작업)</p>
  </li>
  <li>
    <p>각 큐마다 다른 스케줄링 정책을 적용</p>
  </li>
  <li>
    <p>큐 간에도 우선순위를 정할 수 있어.</p>
  </li>
</ul>

<h2 id="스케줄링-타이밍-scheduling-timing">스케줄링 타이밍 (Scheduling Timing)</h2>

<p>언제 스케줄링을 트리거할까? (스레드를 바꿀까?)에 대한 이야기야.</p>

<h3 id="선점형-스케줄링-preemptive-scheduling">선점형 스케줄링 (Preemptive Scheduling)</h3>

<ul>
  <li>
    <p>스레드가 실행 중이어도, 운영체제가 강제로 뺏어서 다른 스레드에 CPU를 넘김.</p>
  </li>
  <li>
    <p>예를 들어 시간 조각(time quantum)이 다 되면 강제 전환.</p>
  </li>
  <li>
    <p>멀티태스킹 시스템(리눅스, 윈도우)은 거의 다 이 방식을 씀.</p>
  </li>
</ul>

<h3 id="비선점형-스케줄링-non-preemptive-scheduling">비선점형 스케줄링 (Non-Preemptive Scheduling)</h3>

<ul>
  <li>
    <p>스레드가 자발적으로 양보(yield) 하기 전까지 CPU를 계속 쓴다.</p>
  </li>
  <li>
    <p>스레드가 블로킹 되거나 명시적으로 종료할 때만 다른 스레드에게 CPU를 넘긴다.</p>
  </li>
  <li>
    <p>단순하지만 하나의 스레드가 CPU를 계속 점유하면 시스템 전체가 멈춘다.</p>
  </li>
</ul>

<h3 id="요약">요약</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">방식</th>
      <th style="text-align: center">특징</th>
      <th style="text-align: center">장단점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">선점형</td>
      <td style="text-align: center">운영체제가 강제 전환</td>
      <td style="text-align: center">응답성 좋음, 구현 복잡</td>
    </tr>
    <tr>
      <td style="text-align: center">비선점형</td>
      <td style="text-align: center">스레드가 자발적 양보</td>
      <td style="text-align: center">구현 간단, 응답성 낮을 수 있음</td>
    </tr>
  </tbody>
</table>

<h2 id="user-level-threadult-vs-kernel-level-threadklt-스케줄링-차이">User-Level Thread(ULT) vs Kernel-Level Thread(KLT) 스케줄링 차이</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">ULT</th>
      <th style="text-align: center">KLT</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">스케줄링 주체</td>
      <td style="text-align: center">사용자 레벨 라이브러리</td>
      <td style="text-align: center">운영체제 커널</td>
    </tr>
    <tr>
      <td style="text-align: center">컨텍스트 스위칭 비용</td>
      <td style="text-align: center">작음(빠름)</td>
      <td style="text-align: center">큼(느릴 수 있음)</td>
    </tr>
    <tr>
      <td style="text-align: center">블로킹 처리</td>
      <td style="text-align: center">하나 블록되면 전체 블록</td>
      <td style="text-align: center">개별적으로 블록 처리 가능</td>
    </tr>
    <tr>
      <td style="text-align: center">예시</td>
      <td style="text-align: center">Green Thread, Lightweight Thread</td>
      <td style="text-align: center">pthreads(Linux), Windows threads</td>
    </tr>
  </tbody>
</table>

<p>특히 ULT에서는 “한 스레드가 Block되면 프로세스 전체가 Block” 되는 문제가 있어서, 실제 상용 시스템에서는 KLT를 기반으로 스케줄링하는 경우가 많아.</p>

<h2 id="실전에서-스케줄링은-어떻게-동작할까">실전에서 스케줄링은 어떻게 동작할까?</h2>

<p>운영체제 커널은 보통 다음과 같은 상황에서 스케줄링을 발동시켜</p>

<ul>
  <li>
    <p>스레드가 Sleep()이나 Wait()을 호출하여 Block될 때</p>
  </li>
  <li>
    <p>스레드가 타임슬라이스(time slice)를 다 써버렸을 때</p>
  </li>
  <li>
    <p>스레드가 종료되었을 때</p>
  </li>
  <li>
    <p>인터럽트가 발생했을 때(예 : 타이머 인터럽트)</p>
  </li>
  <li>
    <p>다른 스레드가 높은 우선순위로 등장했을 때</p>
  </li>
</ul>

<p>타이머 인터럽트로 주기적으로 선점(preemption)을 유발하는 것이 선점형 스케줄링 시스템의 핵심이다!</p>

<h2 id="현대-os-예시">현대 OS 예시</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">OS</th>
      <th style="text-align: center">기본 스케줄링 정책</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Linux</td>
      <td style="text-align: center">Completely Fair Scheduler (CFS)</td>
    </tr>
    <tr>
      <td style="text-align: center">Windows</td>
      <td style="text-align: center">Multilevel Feedback Queue</td>
    </tr>
    <tr>
      <td style="text-align: center">macOS</td>
      <td style="text-align: center">Hybrid (Priority + Multilevel)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>Lunux CFS는 “모든 스레드가 공평하게 CPU를 나눠 갖자”는 원칙을 따르는 아주 세련된 알고리즘이야.</p>
  </li>
  <li>
    <p>Windows는 인터랙티브 작업에 우선순위를 두는 편.</p>
  </li>
  <li>
    <p>macOS도 우선순위와 타임 슬라이스를 조합해서 하이브리드 방식으로 스케줄링함.</p>
  </li>
</ul>

<h2 id="심화--cfscompletely-fair-scheduler-아주-간단-설명">심화 : CFS(Completely Fair Scheduler) 아주 간단 설명</h2>

<p>Linux의 기본 스케줄러인 CFS는 이렇게 동작해</p>

<ul>
  <li>
    <p>각 스레드가 CPU를 쓴 “시간”을 트래킹한다.</p>
  </li>
  <li>
    <p>“가장 적게 CPU를 쓴 스레드”에게 CPU를 넘긴다.</p>
  </li>
  <li>
    <p>실행 가능한 스레드들을 “Red-Black Tree”라는 자료구조에 정렬해 관리한다.</p>
  </li>
  <li>
    <p>O(log N) 시간에 가장 공정한 스레드를 찾아낼 수 있다.</p>
  </li>
</ul>

<blockquote>
  <p>즉, “CPU를 공평하게 쓸 기회를 준다”는 게 핵심!</p>
</blockquote>

<h2 id="스레드-스케줄링-요약">스레드 스케줄링 요약</h2>

<ul>
  <li>
    <p>스레드 스케줄링은 “누구를 언제 CPU에 태울지”를 결정하는 것.</p>
  </li>
  <li>
    <p>스케줄링 전략(FIFO, Round Robin, Priority 등) + 스케줄링 타이밍(선점형/비선점형)이 기본 개념.</p>
  </li>
  <li>
    <p>현대 운영체제는 거의 선점형 + 우선순위 + 공정성을 조합한 복합적 방식을 사용.</p>
  </li>
</ul>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[스레드는 프로세스(process) 내에서 실제로 작업을 수행하는 실행 단위이다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">스레드(Thread)</title><link href="/blog/computersystem/thread/" rel="alternate" type="text/html" title="스레드(Thread)" /><published>2025-05-13T00:00:00+00:00</published><updated>2025-05-13T00:00:00+00:00</updated><id>/blog/computersystem/thread</id><content type="html" xml:base="/blog/computersystem/thread/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#스레드thread란" id="markdown-toc-스레드thread란">스레드(Thread)란?</a></li>
  <li><a href="#왜-스레드를-사용할까" id="markdown-toc-왜-스레드를-사용할까">왜 스레드를 사용할까?</a>    <ul>
      <li><a href="#성능-개선병렬성" id="markdown-toc-성능-개선병렬성">성능 개선(병렬성)</a></li>
      <li><a href="#리소스-공유" id="markdown-toc-리소스-공유">리소스 공유</a></li>
      <li><a href="#응답성-향상" id="markdown-toc-응답성-향상">응답성 향상</a></li>
    </ul>
  </li>
  <li><a href="#스레드의-구성-요소" id="markdown-toc-스레드의-구성-요소">스레드의 구성 요소</a></li>
  <li><a href="#스레드의-상태-변화" id="markdown-toc-스레드의-상태-변화">스레드의 상태 변화</a></li>
  <li><a href="#스레드의-종류" id="markdown-toc-스레드의-종류">스레드의 종류</a>    <ul>
      <li><a href="#사용자-수준-스레드user-level-thread-ult" id="markdown-toc-사용자-수준-스레드user-level-thread-ult">사용자 수준 스레드(User-Level Thread, ULT)</a></li>
      <li><a href="#커널-수준-스레드kernel-level-thread-klt" id="markdown-toc-커널-수준-스레드kernel-level-thread-klt">커널 수준 스레드(Kernel-Level Thread, KLT)</a></li>
      <li><a href="#하이브리드2-level-model" id="markdown-toc-하이브리드2-level-model">하이브리드(2-Level Model)</a></li>
    </ul>
  </li>
  <li><a href="#스레드-생성-방법-예--c언어-posix-pthread" id="markdown-toc-스레드-생성-방법-예--c언어-posix-pthread">스레드 생성 방법 (예 : C언어 POSIX pthread)</a></li>
  <li><a href="#스레드-사용-시-주의할-점" id="markdown-toc-스레드-사용-시-주의할-점">스레드 사용 시 주의할 점</a>    <ul>
      <li><a href="#경쟁-조건race-condition" id="markdown-toc-경쟁-조건race-condition">경쟁 조건(Race Condition)</a></li>
      <li><a href="#데드락deadlock" id="markdown-toc-데드락deadlock">데드락(Deadlock)</a></li>
      <li><a href="#기아starvation" id="markdown-toc-기아starvation">기아(Starvation)</a></li>
    </ul>
  </li>
  <li><a href="#스레드와-프로세스-비교-요약" id="markdown-toc-스레드와-프로세스-비교-요약">스레드와 프로세스 비교 요약</a></li>
  <li><a href="#스레드-활용-예시" id="markdown-toc-스레드-활용-예시">스레드 활용 예시</a></li>
  <li><a href="#시각화-그림" id="markdown-toc-시각화-그림">시각화 그림</a></li>
  <li><a href="#스레드-심화" id="markdown-toc-스레드-심화">스레드 심화</a></li>
</ul>

<h2 id="스레드thread란">스레드(Thread)란?</h2>

<p>스레드(Thread)는 프로세스(Process) 내에서 실제로 작업을 수행하는 실행 단위를 말해.</p>

<ul>
  <li>
    <p>하나의 프로세스는 최소 하나 이상의 스레드를 가지고 있어.</p>
  </li>
  <li>
    <p>스레드들은 <strong>프로세스의 메모리 공간(코드, 데이터, 힙, 파일 디스크립터 등)을 공유</strong>한다.</p>
  </li>
  <li>
    <p>하지만 <strong>각 스레드는 자신의 레지스터 집합과 스택을 별도로 가지고 있어</strong>.</p>
  </li>
</ul>

<p>요약하면,</p>

<ul>
  <li>
    <p><strong>프로세스</strong> : 리소스를 가진 실행 단위</p>
  </li>
  <li>
    <p><strong>스레드</strong> : 프로세스 내에서 실행 흐름을 가진 실행 단위</p>
  </li>
</ul>

<h2 id="왜-스레드를-사용할까">왜 스레드를 사용할까?</h2>

<h3 id="성능-개선병렬성">성능 개선(병렬성)</h3>

<ul>
  <li>CPU 코어가 여러 개라면 여러 스레드를 동시에 실행시켜 작업 속도를 높일 수 있어.</li>
</ul>

<h3 id="리소스-공유">리소스 공유</h3>

<ul>
  <li>같은 프로세스 내 스레드들은 메모리를 공유하기 때문에, 프로세스 간 통신(IPC)보다 훨씬 가볍고 빠른 스레드 간 통신이 가능해.</li>
</ul>

<h3 id="응답성-향상">응답성 향상</h3>

<ul>
  <li>예를 들어, 서버가 요청을 처리할 때, 메인 스레드는 계속 사용자 입력을 받고, 다른 스레드가 요청 처리를 맡아버리면 시스템 응답성이 좋아져.</li>
</ul>

<h2 id="스레드의-구성-요소">스레드의 구성 요소</h2>

<p>각 스레드는 다음을 갖고 있어</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">구성 요소</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Thread ID</td>
      <td style="text-align: center">스레드를 식별하는 고유 ID</td>
    </tr>
    <tr>
      <td style="text-align: center">Program Counter</td>
      <td style="text-align: center">다음에 실행할 명령어의 주소</td>
    </tr>
    <tr>
      <td style="text-align: center">Registers</td>
      <td style="text-align: center">스레드가 현재 수행 중인 작업에 필요한 데이터 저장</td>
    </tr>
    <tr>
      <td style="text-align: center">Stack</td>
      <td style="text-align: center">함수 호출 정보, 지역 변수 저장</td>
    </tr>
    <tr>
      <td style="text-align: center">State</td>
      <td style="text-align: center">실행 상태 (Running, Ready, Blocked 등)</td>
    </tr>
  </tbody>
</table>

<p><strong><em>참고 : 코드 영역, 데이터 영역, 열린 파일들은 같은 프로세스 내 스레드끼리 공유한다.</em></strong></p>

<h2 id="스레드의-상태-변화">스레드의 상태 변화</h2>

<p>스레드는 아래처럼 상태가 변한다.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">New</span> <span class="o">-</span><span class="k">-&gt;</span> <span class="n">Ready</span> <span class="o">-</span><span class="k">-&gt;</span> <span class="n">Running</span> <span class="o">-</span><span class="k">-&gt;</span> <span class="p">(</span><span class="n">Blocked</span> <span class="n">or</span> <span class="n">Terminated</span><span class="p">)</span>
             <span class="err">↑</span>          <span class="err">↓</span>
          <span class="p">(</span><span class="n">Unblocked</span><span class="p">)</span>
</code></pre></div></div>

<ul>
  <li>
    <p><strong>New</strong> : 생성됨</p>
  </li>
  <li>
    <p><strong>Ready</strong> : CPU를 기다림</p>
  </li>
  <li>
    <p><strong>Running</strong> : CPU를 점유해서 실행 중</p>
  </li>
  <li>
    <p><strong>Blocked</strong> : 입출력 등으로 기다림</p>
  </li>
  <li>
    <p><strong>Terminated</strong> : 작업 완료하고 종료</p>
  </li>
</ul>

<h2 id="스레드의-종류">스레드의 종류</h2>

<h3 id="사용자-수준-스레드user-level-thread-ult">사용자 수준 스레드(User-Level Thread, ULT)</h3>

<ul>
  <li>
    <p>커널이 스레드의 존재를 모름.</p>
  </li>
  <li>
    <p>사용자 라이브러리(예: pthread)가 직접 스케줄링.</p>
  </li>
  <li>
    <p>컨텍스트 스위칭이 빠름(커널 호출 없음), 하지만 하나가 Block되면 전체가 Block될 수 있음.</p>
  </li>
</ul>

<h3 id="커널-수준-스레드kernel-level-thread-klt">커널 수준 스레드(Kernel-Level Thread, KLT)</h3>

<ul>
  <li>
    <p>커널이 스레드를 관리함.</p>
  </li>
  <li>
    <p>하나의 스레드가 Block돼도 다른 스레드는 계속 실행 가능.</p>
  </li>
  <li>
    <p>하지만 스케줄링할 때마다 커널모드 진입/탈출(시스템 콜)이 필요해 느릴 수 있음.</p>
  </li>
</ul>

<h3 id="하이브리드2-level-model">하이브리드(2-Level Model)</h3>

<ul>
  <li>사용자 수준 스레드와 커널 수준 스레드를 조합하여 장점을 살림.</li>
</ul>

<h2 id="스레드-생성-방법-예--c언어-posix-pthread">스레드 생성 방법 (예 : C언어 POSIX pthread)</h2>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;pthread.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">myThreadFunc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Thread 실행 중</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
    <span class="n">pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">myThreadFunc</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="n">pthread_join</span><span class="p">(</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span> <span class="c1">// main 스레드가 tid 스레드 종료를 기다림</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">pthread_create</code> : 새로운 스레드 생성</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">pthread_join</code> : 생성된 스레드가 끝날 때까지 기다림</p>
  </li>
</ul>

<h2 id="스레드-사용-시-주의할-점">스레드 사용 시 주의할 점</h2>

<h3 id="경쟁-조건race-condition">경쟁 조건(Race Condition)</h3>

<ul>
  <li>
    <p>여러 스레드가 동시에 같은 데이터를 수정할 때 발생하는 오류</p>
  </li>
  <li>
    <p>해결 방법 : 뮤텍스(Mutex), 세마포어(Semaphore), 락(Lock) 사용</p>
  </li>
</ul>

<h3 id="데드락deadlock">데드락(Deadlock)</h3>

<ul>
  <li>
    <p>둘 이상의 스레드가 서로 자원을 기다리며 영원히 멈춰버리는 현상</p>
  </li>
  <li>
    <p>해결 방법 : 자원 할당 순서를 정하거나, 타임아웃 적용</p>
  </li>
</ul>

<h3 id="기아starvation">기아(Starvation)</h3>

<ul>
  <li>어떤 스레드가 자원을 독점해서 다른 스레드가 계속 기회를 얻지 못하는 문제</li>
</ul>

<h2 id="스레드와-프로세스-비교-요약">스레드와 프로세스 비교 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">프로세스</th>
      <th style="text-align: center">스레드</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">메모리</td>
      <td style="text-align: center">각각 독립</td>
      <td style="text-align: center">공유</td>
    </tr>
    <tr>
      <td style="text-align: center">생성 비용</td>
      <td style="text-align: center">크다</td>
      <td style="text-align: center">작다</td>
    </tr>
    <tr>
      <td style="text-align: center">통신 비용</td>
      <td style="text-align: center">IPC(느림)</td>
      <td style="text-align: center">메모리 공유(빠름)</td>
    </tr>
    <tr>
      <td style="text-align: center">오류 전파</td>
      <td style="text-align: center">프로세스끼리 독립</td>
      <td style="text-align: center">하나가 죽으면 전체 프로세스 영향 가능</td>
    </tr>
  </tbody>
</table>

<h2 id="스레드-활용-예시">스레드 활용 예시</h2>

<ul>
  <li>
    <p><strong>웹 서버</strong> : 요청마다 스레드 하나 생성</p>
  </li>
  <li>
    <p><strong>게임 엔진</strong> : 물리 엔진, 렌더링 엔진, 네트워크 처리 등을 각각 다른 스레드에서 수행</p>
  </li>
  <li>
    <p><strong>멀티미디어 앱</strong> : 음악 재생, 동영상 디코딩, 자막 처리 등을 별도 스레드로 처리</p>
  </li>
</ul>

<h2 id="시각화-그림">시각화 그림</h2>

<p>프로세스 하나 안에 여러 스레드가 존재하는 모습은 이렇게 볼 수 있어</p>

<div class="language-lua highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">+</span><span class="c1">----------------------------------------+</span>
<span class="err">|</span>             <span class="n">Process</span> <span class="p">(</span><span class="err">프로세스</span><span class="p">)</span>          <span class="err">|</span>
<span class="err">|</span>                                        <span class="err">|</span>
<span class="err">|</span>    <span class="o">+</span><span class="c1">---------+   +---------+           |</span>
<span class="err">|</span>    <span class="err">|</span> <span class="n">Thread</span> <span class="mi">1</span><span class="err">|</span>   <span class="err">|</span> <span class="n">Thread</span> <span class="mi">2</span> <span class="err">|</span>           <span class="err">|</span>
<span class="err">|</span>    <span class="o">+</span><span class="c1">---------+   +---------+           |</span>
<span class="err">|</span>        <span class="err">↕</span>             <span class="err">↕</span>                 <span class="err">|</span>
<span class="err">|</span>    <span class="p">(</span><span class="err">공유하는</span> <span class="err">메모리</span><span class="p">,</span> <span class="err">열린</span> <span class="err">파일</span><span class="p">,</span> <span class="err">등등</span><span class="p">)</span>  <span class="err">|</span>
<span class="o">+</span><span class="c1">----------------------------------------+</span>
</code></pre></div></div>

<p>요약하면,
<strong>“프로세스 = 자원을 가진 집”</strong>,
<strong>“스레드 = 집 안에서 일하는 사람”</strong>
이라고 이해하면 좋아</p>

<h2 id="스레드-심화">스레드 심화</h2>

<p>더 깊고 자세한 내용은 <a href="../../computersystem/thread-advanced" class="heading flip-title">스레드(Thread) 심화</a>에서 다루겠다.</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[스레드는 프로세스(process) 내에서 실제로 작업을 수행하는 실행 단위이다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">동기화 기법 3대장 : Lock/Semaphore/Condition Variable</title><link href="/blog/computersystem/lock-semaphore-condition/" rel="alternate" type="text/html" title="동기화 기법 3대장 : Lock/Semaphore/Condition Variable" /><published>2025-05-12T00:00:00+00:00</published><updated>2025-05-12T00:00:00+00:00</updated><id>/blog/computersystem/lock-semaphore-condition</id><content type="html" xml:base="/blog/computersystem/lock-semaphore-condition/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#동기화synchronization란" id="markdown-toc-동기화synchronization란">동기화(Synchronization)란?</a></li>
  <li><a href="#왜-동기화가-필요할까" id="markdown-toc-왜-동기화가-필요할까">왜 동기화가 필요할까?</a>    <ul>
      <li><a href="#동기화가-없으면-생기는-문제" id="markdown-toc-동기화가-없으면-생기는-문제">동기화가 없으면 생기는 문제</a></li>
    </ul>
  </li>
  <li><a href="#동기화의-목적" id="markdown-toc-동기화의-목적">동기화의 목적</a></li>
  <li><a href="#동기화하는-방법들-기술" id="markdown-toc-동기화하는-방법들-기술">동기화하는 방법들 (기술)</a>    <ul>
      <li><a href="#lock뮤텍스-포함" id="markdown-toc-lock뮤텍스-포함">Lock(뮤텍스 포함)</a></li>
      <li><a href="#semaphore" id="markdown-toc-semaphore">Semaphore</a></li>
      <li><a href="#condition-variable-조건-변수" id="markdown-toc-condition-variable-조건-변수">Condition Variable (조건 변수)</a></li>
      <li><a href="#요약-비교" id="markdown-toc-요약-비교">요약 비교</a></li>
    </ul>
  </li>
</ul>

<h2 id="동기화synchronization란">동기화(Synchronization)란?</h2>

<p>동기화란, 여러 개의 스레드나 프로세스가 “공유 자원”을 사용할 때, 충돌이나 오류 없이 올바르게 작동하도록 순서를 맞춰주는 기술이다.</p>

<h2 id="왜-동기화가-필요할까">왜 동기화가 필요할까?</h2>

<p>여러 스레드/프로세스가 동시에 :</p>

<ul>
  <li>
    <p>같은 메모리,</p>
  </li>
  <li>
    <p>같은 파일,</p>
  </li>
  <li>
    <p>같은 네트워크 리소스를</p>
  </li>
  <li>
    <p>아무 조정 없이 건드리면,</p>
  </li>
</ul>

<p><strong>문제</strong>가 터진다!</p>

<blockquote>
  <p>값이 꼬인다(데이터 레이스)
프로그램이 이상하게 동작한다(논리 오류)
심지어 프로그램이 죽을 수도 있다(crash)</p>
</blockquote>

<h3 id="동기화가-없으면-생기는-문제">동기화가 없으면 생기는 문제</h3>

<p><strong>1. 데이터 레이스(Data Race)</strong></p>

<blockquote>
  <p>두 스레드가 동시에 같은 데이터를 읽고 수정해서 예상 못 한 값이 생기는 문제.</p>
</blockquote>

<p>예시 :</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// counter를 1000번 증가시키는 코드</span>
<span class="n">counter</span><span class="o">++</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>
    <p>A 스레드가 <code class="language-plaintext highlighter-rouge">counter</code>를 읽고,</p>
  </li>
  <li>
    <p>B 스레드가 거의 동시에 <code class="language-plaintext highlighter-rouge">counter</code>를 읽으면,</p>
  </li>
  <li>
    <p>둘 다 <code class="language-plaintext highlighter-rouge">counter = 5</code>를 봤고;</p>
  </li>
  <li>
    <p>둘 다 <code class="language-plaintext highlighter-rouge">counter = 6</code>을 저장해버린다.</p>
  </li>
  <li>
    <p>→ 사실은 두 번 증가해야 하는데, 한 번만 증가한 꼴이 됨!</p>
  </li>
</ul>

<p>(동시에 수정하면 제대로 합쳐지지 않아)</p>

<p><strong>2. 교착상태(Deadlock)</strong></p>

<blockquote>
  <p>서로 Lock을 잡고 영원히 기다리는 상황.</p>
</blockquote>

<p>예시 :</p>

<ul>
  <li>
    <p>A는 프린터 락을 잡고 스캐너 락을 기다림.</p>
  </li>
  <li>
    <p>B는 스캐너 락을 잡고 프린터 락을 기다림.</p>
  </li>
  <li>
    <p>둘 다 서로 기다리다 아무것도 못하고 멈춤.</p>
  </li>
</ul>

<p><strong>3. 기아(Starvation)</strong></p>

<blockquote>
  <p>어떤 스레드가 계속 자원을 못 받아서 굶는 문제.</p>
</blockquote>

<ul>
  <li>
    <p>높은 우선순위 스레드가 계속 차지하면</p>
  </li>
  <li>
    <p>낮은 우선순위 스레드는 기회 자체를 못 얻는다.</p>
  </li>
</ul>

<h2 id="동기화의-목적">동기화의 목적</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">목표</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">일관성 유지</td>
      <td style="text-align: center">데이터가 꼬이지 않게 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">공정성 보장</td>
      <td style="text-align: center">모든 스레드가 자원을 쓸 기회를 갖는다.</td>
    </tr>
    <tr>
      <td style="text-align: center">교착상태 방지</td>
      <td style="text-align: center">스레드들이 서로 영원히 기다리지 않게 한다.</td>
    </tr>
    <tr>
      <td style="text-align: center">효율적인 협력</td>
      <td style="text-align: center">여러 스레드가 협력해서 작업할 수 있게 한다.</td>
    </tr>
  </tbody>
</table>

<h2 id="동기화하는-방법들-기술">동기화하는 방법들 (기술)</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">기술</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Lock/Mutex</td>
      <td style="text-align: center">임계 구역 보호 (하나만 들어가게)</td>
    </tr>
    <tr>
      <td style="text-align: center">Semaphore</td>
      <td style="text-align: center">자원의 개수 관리 (여러 개도 가능)</td>
    </tr>
    <tr>
      <td style="text-align: center">Condition Variable</td>
      <td style="text-align: center">어떤 조건이 충족될 때까지 대기/깨우기</td>
    </tr>
    <tr>
      <td style="text-align: center">Monitor</td>
      <td style="text-align: center">Lock + Condition을 합친 고급 동기화 추상화</td>
    </tr>
    <tr>
      <td style="text-align: center">Barrier</td>
      <td style="text-align: center">여러 스레드가 한 지점에서 다 모일 때까지 기다리기</td>
    </tr>
  </tbody>
</table>

<p>이 글에서는 Lock, Semaphore, Condition Variable에 대해서 다룰거야</p>

<h3 id="lock뮤텍스-포함">Lock(뮤텍스 포함)</h3>

<p><strong>개념</strong></p>

<ul>
  <li>
    <p>Critical Section(공유 자원을 접근하는 코드 블록)을 한 번에 하나만 실행하도록 막는 기법.</p>
  </li>
  <li>
    <p>보통 뮤텍스(Mutex)를 통해 구현.</p>
  </li>
</ul>

<p><strong>특징</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">기본 기능</td>
      <td style="text-align: center">진입 시 lock, 작업 후 unlock</td>
    </tr>
    <tr>
      <td style="text-align: center">기본 상태</td>
      <td style="text-align: center">잠금(Locked) / 잠금 해제(Unlocked)</td>
    </tr>
    <tr>
      <td style="text-align: center">소유권</td>
      <td style="text-align: center">있음(lock한 스레드만 unlock할 수 있음)</td>
    </tr>
    <tr>
      <td style="text-align: center">주 용도</td>
      <td style="text-align: center">공유 데이터 보호, 임계 구역 보호</td>
    </tr>
  </tbody>
</table>

<p><strong>간단 예제</strong></p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="c1">// critical section (공유 데이터 접근)</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>

<h3 id="semaphore">Semaphore</h3>

<p><strong>개념</strong></p>

<ul>
  <li>“자원의 개수”를 세는 정수 변수를 관리해서, 자원 접근을 조율하는 동기화 도구.</li>
</ul>

<p><strong>특징</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">기본 기능</td>
      <td style="text-align: center">wait(P) : 자원 요청, signal(V) : 자원 반환</td>
    </tr>
    <tr>
      <td style="text-align: center">기본 상태</td>
      <td style="text-align: center">0 이상 정수</td>
    </tr>
    <tr>
      <td style="text-align: center">소유권</td>
      <td style="text-align: center">없음 (누구나 wait, signal 호출 가능)</td>
    </tr>
    <tr>
      <td style="text-align: center">주 용도</td>
      <td style="text-align: center">여러 개의 리소스 접근 제한 (ex. 프린터 5대)</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>Binary Semaphore : Lock처럼 0/1만 관리 (뮤텍스 비슷)</p>
  </li>
  <li>
    <p>Counting Semaphore : 2개 이상 리소스 관리</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">sem_t</span> <span class="n">sem</span><span class="p">;</span>
<span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="p">);</span>   <span class="c1">// 자원 요청</span>
<span class="c1">// critical section</span>
<span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="p">);</span>   <span class="c1">// 자원 반환</span>
</code></pre></div></div>

<h3 id="condition-variable-조건-변수">Condition Variable (조건 변수)</h3>

<p><strong>개념</strong></p>

<ul>
  <li>
    <p>스레드가 어떤 “특정 조건이 될 때까지 기다리게 하는” 도구</p>
  </li>
  <li>
    <p>Lock과 함께 써야 함! (단독 사용 불가)</p>
  </li>
</ul>

<p><strong>특징</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">기본 기능</td>
      <td style="text-align: center">wait(조건), signal(조건 성취 시 알림)</td>
    </tr>
    <tr>
      <td style="text-align: center">기본 상태</td>
      <td style="text-align: center">조건을 기다리는 대기열</td>
    </tr>
    <tr>
      <td style="text-align: center">소유권</td>
      <td style="text-align: center">Lock과 함께 사용 (Lock 보유해야 wait 가능)</td>
    </tr>
    <tr>
      <td style="text-align: center">주 용도</td>
      <td style="text-align: center">어떤 상태 변화에 따라 스레드 깨우기</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p><code class="language-plaintext highlighter-rouge">wait()</code> : 조건이 만족될 때까지 슬립 (잠깐 Lock도 반납)</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">signal()</code> : 대기 중인 스레드 하나 깨우기</p>
  </li>
  <li>
    <p><code class="language-plaintext highlighter-rouge">broadcast()</code> : 대기 중인 스레드 모두 깨우기</p>
  </li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pthread_mutex_t</span> <span class="n">lock</span><span class="p">;</span>
<span class="n">pthread_cond_t</span> <span class="n">cond</span><span class="p">;</span>

<span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(</span><span class="err">조건이</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_cond_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cond</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="c1">// 조건 만족했으면 수행</span>
<span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
</code></pre></div></div>
<p>(※ wait()할 때 lock을 잠시 반납하고, 조건 충족되면 다시 lock을 잡은 채 깨어나)</p>

<h3 id="요약-비교">요약 비교</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">기법</th>
      <th style="text-align: center">주 용도</th>
      <th style="text-align: center">특징</th>
      <th style="text-align: center">주의할 점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Lock/Mutex</td>
      <td style="text-align: center">임계 구역 보호</td>
      <td style="text-align: center">하나만 진입 허용</td>
      <td style="text-align: center">교착 상태(deadlock) 조심</td>
    </tr>
    <tr>
      <td style="text-align: center">Semaphore</td>
      <td style="text-align: center">여러 자원 수 조절</td>
      <td style="text-align: center">카운트 기반</td>
      <td style="text-align: center">signal/wait 관리 조심</td>
    </tr>
    <tr>
      <td style="text-align: center">Condition Variable</td>
      <td style="text-align: center">조건 기다리기</td>
      <td style="text-align: center">Lock과 세트 사용</td>
      <td style="text-align: center">signal/broadcast 명확하게 써야함</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[Lock, Semaphore, Condition Variable 전부 동기화(Synchronization) 기법으로, 여러 스레드/프로세스가 공유 자원을 엉키지 않게 사용하게 만드는 기술이다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">CS:APP 11장 네트워크 프로그래밍 &amp;amp; Proxy 서버 C언어로 구현</title><link href="/blog/computersystem/network-programming/" rel="alternate" type="text/html" title="CS:APP 11장 네트워크 프로그래밍 &amp;amp; Proxy 서버 C언어로 구현" /><published>2025-05-08T00:00:00+00:00</published><updated>2025-05-08T00:00:00+00:00</updated><id>/blog/computersystem/network-programming</id><content type="html" xml:base="/blog/computersystem/network-programming/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#클라이언트---서버-프로그래밍-모델" id="markdown-toc-클라이언트---서버-프로그래밍-모델">클라이언트 - 서버 프로그래밍 모델</a></li>
  <li><a href="#네트워크" id="markdown-toc-네트워크">네트워크</a>    <ul>
      <li><a href="#nic-network-interface-card" id="markdown-toc-nic-network-interface-card">NIC (Network Interface Card)</a></li>
      <li><a href="#이더넷-ethernet" id="markdown-toc-이더넷-ethernet">이더넷 (Ethernet)</a>        <ul>
          <li><a href="#더-큰-lan---브릿지의-등장" id="markdown-toc-더-큰-lan---브릿지의-등장">더 큰 LAN - 브릿지의 등장</a></li>
          <li><a href="#브릿지와-허브의-차이점" id="markdown-toc-브릿지와-허브의-차이점">브릿지와 허브의 차이점</a></li>
        </ul>
      </li>
      <li><a href="#wan-wide-area-network" id="markdown-toc-wan-wide-area-network">WAN (Wide Area Network)</a></li>
      <li><a href="#internet" id="markdown-toc-internet">internet</a></li>
    </ul>
  </li>
  <li><a href="#글로벌-ip-인터넷" id="markdown-toc-글로벌-ip-인터넷">글로벌 IP 인터넷</a>    <ul>
      <li><a href="#ip-주소" id="markdown-toc-ip-주소">IP 주소</a>        <ul>
          <li><a href="#dotted-decimal" id="markdown-toc-dotted-decimal">Dotted-decimal</a></li>
        </ul>
      </li>
      <li><a href="#인터넷-도메인-이름" id="markdown-toc-인터넷-도메인-이름">인터넷 도메인 이름</a></li>
      <li><a href="#인터넷-연결" id="markdown-toc-인터넷-연결">인터넷 연결</a></li>
    </ul>
  </li>
  <li><a href="#소켓-인터페이스" id="markdown-toc-소켓-인터페이스">소켓 인터페이스</a>    <ul>
      <li><a href="#소켓-주소-구조체" id="markdown-toc-소켓-주소-구조체">소켓 주소 구조체</a></li>
      <li><a href="#socket-함수" id="markdown-toc-socket-함수">socket 함수</a></li>
      <li><a href="#connect-함수" id="markdown-toc-connect-함수">connect 함수</a></li>
      <li><a href="#bind-함수" id="markdown-toc-bind-함수">bind 함수</a></li>
      <li><a href="#listen-함수" id="markdown-toc-listen-함수">listen 함수</a></li>
      <li><a href="#accept-함수" id="markdown-toc-accept-함수">accept 함수</a>        <ul>
          <li><a href="#듣기-식별자와-연결-식별자" id="markdown-toc-듣기-식별자와-연결-식별자">듣기 식별자와 연결 식별자</a></li>
        </ul>
      </li>
      <li><a href="#호스트와-서비스-변환getaddrinfo--getnameinfo" id="markdown-toc-호스트와-서비스-변환getaddrinfo--getnameinfo">호스트와 서비스 변환(getaddrinfo &amp; getnameinfo)</a>        <ul>
          <li><a href="#getaddrinfo-함수" id="markdown-toc-getaddrinfo-함수">getaddrinfo 함수</a></li>
          <li><a href="#getnameinfo-함수" id="markdown-toc-getnameinfo-함수">getnameinfo 함수</a></li>
        </ul>
      </li>
      <li><a href="#open_clientfd함수" id="markdown-toc-open_clientfd함수">open_clientfd함수</a></li>
      <li><a href="#open_listenfd함수" id="markdown-toc-open_listenfd함수">open_listenfd함수</a></li>
    </ul>
  </li>
  <li><a href="#echo-client와-server" id="markdown-toc-echo-client와-server">Echo client와 server</a></li>
  <li><a href="#웹-기초" id="markdown-toc-웹-기초">웹 기초</a>    <ul>
      <li><a href="#웹-컨텐츠" id="markdown-toc-웹-컨텐츠">웹 컨텐츠</a></li>
      <li><a href="#동적-컨텐츠의-처리" id="markdown-toc-동적-컨텐츠의-처리">동적 컨텐츠의 처리</a></li>
    </ul>
  </li>
  <li><a href="#소형-웹-서버tiny-web-server" id="markdown-toc-소형-웹-서버tiny-web-server">소형 웹 서버(Tiny web server)</a></li>
  <li><a href="#소형-웹-서버tiny-web-server--프록시-서버" id="markdown-toc-소형-웹-서버tiny-web-server--프록시-서버">소형 웹 서버(Tiny web server) + 프록시 서버</a>    <ul>
      <li><a href="#웹-프록시란" id="markdown-toc-웹-프록시란">웹 프록시란?</a></li>
    </ul>
  </li>
  <li><a href="#프록시-서버" id="markdown-toc-프록시-서버">프록시 서버</a></li>
  <li><a href="#프록시-서버-쓰레딩과-캐싱-기능-추가" id="markdown-toc-프록시-서버-쓰레딩과-캐싱-기능-추가">프록시 서버 쓰레딩과 캐싱 기능 추가</a></li>
</ul>

<p>흥미로운 것은 모든 네트워크 응용들은 동일한 기본적인 프로그래밍 모델에 기초하고 있으며, 이들은 비슷한 전체 논리 구조를 가지며, 동일한 프로그래밍 인터페이스를 사용한다는 점이다. 개념들을 설명하고 난 후 개념들을 모두 연결해서 아주 작지만 실제로 동작하는 웹 서버를 개발할 것이다.</p>

<h2 id="클라이언트---서버-프로그래밍-모델">클라이언트 - 서버 프로그래밍 모델</h2>

<p>** 모든 네트워크 응용 프로그램은 클라이언트-서버 모델에 기초하고 있다.** 아래와 같은 사진과 같이 한 개의 서버 프로세스와 한 개 이상의 클라이언트 프로세스로 구성된다.</p>

<p><img src="/assets/img/blog/computerscience/clientservertransaction.png" alt="클라이언트 서버 모델" /></p>

<ol>
  <li>
    <p>클라이언트가 한 개의 요청(request)을 서버에 보내는 것으로 트랜잭션을 개시한다. 예를 들어, 웹 브라우저가 파일을 필요로 할때, 웹 서버로 요청을 보낸다.</p>
  </li>
  <li>
    <p>서버는 요청을 받고, 해석하고, 자신의 자원들을 적절한 방법으로 조작한다. 예를 들어, 웹 서버가 브라우저로부터 요청을 받을 때, 디스크 파일을 읽는다.</p>
  </li>
  <li>
    <p>서버는 응답(response)을 클라이언트로 보내고, 그 후에 다음 요청을 기다린다. 예를 들어, 웹 서버는 이 파일을 다시 클라이언트로 돌려보낸다.</p>
  </li>
  <li>
    <p>클라이언트는 응답을 받고 이걸을 처리한다. 예를 들어, 웹 브라우저가 서버로부터 페이지를 한 개 받은 후, 이것을 스크린에 디스플레이한다.</p>
  </li>
</ol>

<h2 id="네트워크">네트워크</h2>

<p>물리적으로 네트워크는 기하학적 위치로 구성된 <strong>계층구조 시스템</strong>이다 하위수준은 <strong>LAN(Local Area Network)</strong>으로 빌딩이나 캠퍼스에 설치된다. 가장 대중적인 LAN기술은 현재까지는 이더넷(Ehternet)이며, 시간에 따라서 엄청 발전되어 왔다. 이더넷(Ethernet)에 관련한 설명은 아래에 있다.</p>

<h3 id="nic-network-interface-card">NIC (Network Interface Card)</h3>

<p>호스트에게 네트워크는 단지 또 다른 I/O 디바이스이다. 아래 사진과 같이 네트워크에서 수신한 데이터는 I/O와 메모리 버스를 거쳐서 어댑터에서 메모리로, 대개 DMA 전송으로 복사된다. 비슷하게 데이터는 또한 메모리에서 네트워크로 복사될 수 있다.</p>

<p><img src="/assets/img/blog/computerscience/hosthardwareorganization.png" alt="호스트의 네트워크 구성" /></p>

<h3 id="이더넷-ethernet">이더넷 (Ethernet)</h3>

<p>이더넷 세그먼트는 아래 사진과 같이 몇 개의 전선들과 허브라고 부르는 작은 상자로 구성된다. 한쪽 끝은 호스트의 어댑터에 연결되고, 다른 끝은 허브의 포트에 연결된다. 허브는 각 포트에서 수신한 모든 비트를 종속적으로 다른 모든 포트로 복사한다.</p>

<p><img src="/assets/img/blog/computerscience/ethernetsegment.png" alt="이더넷 세그먼트" /></p>

<ul>
  <li>
    <p><strong>이더넷 어댑터</strong>는 어댑터의 비휘발성 메모리에 저장된 전체적으로 <strong>고유한 48비트 주소</strong>를 가진다.</p>
  </li>
  <li>
    <p>호스트는 <strong>프레임</strong>이라고 부르는 비트들을 세그먼트의 다른 호스트에 보낼 수 있다.</p>
  </li>
  <li>
    <p>각 <strong>프레임</strong>은 프레임의 <strong>소스</strong>와 <strong>목적지</strong>, 프레임의 <strong>길이</strong>를 식별할 수 있는 고정된 <strong>헤더 비트</strong>를 가지고 있으며, 그 뒤에 데이터 비트가 이어진다.</p>
  </li>
  <li>
    <p>모든 호스트 어댑터는 이 프레임을 볼 수 있지만, 목적지 호스트만이 실제로 이것을 읽어들인다.</p>
  </li>
</ul>

<h4 id="더-큰-lan---브릿지의-등장">더 큰 LAN - 브릿지의 등장</h4>

<p>아래 사진에 나타난 것처럼 전선들과 브릿지라고 하는 작은 상자들을 사용해서 **다수의 이더넷 세그먼트가 연결되어 브릿지형 이더넷이라고 하는 더 큰 LAN을 구성할 수 있다.</p>

<p><img src="/assets/img/blog/computerscience/bridgedethernetsegments.png" alt="브릿지로 연결된 이더넷 세그먼트" /></p>

<ul>
  <li>
    <p>브릿지형 이더넷에서 일부 선은 브릿지를 브릿지로 연결하고, 다른 선들은 브릿지를 허브로 연결한다.</p>
  </li>
  <li>
    <p>각 선의 대역폭은 다를 수 있다. 우리의 예제에서 브릿지-브릿지선은 1Gb/s 대역폭을, 네 개의 허브-브릿지 선은 100Mb/s 대역폭을 가진다.</p>
  </li>
</ul>

<h4 id="브릿지와-허브의-차이점">브릿지와 허브의 차이점</h4>

<ul>
  <li>
    <p>브릿지는 허브보다 더 높은 전선의 대역폭을 가진다.</p>
  </li>
  <li>
    <p>허브는 각 포트에서 수신한 모든 비트를 종속적으로 다른 모든 포트로 복사한다.</p>
  </li>
  <li>
    <p>브릿지는 우수한 분산 알고리즘을 통해 필요한 경우 선택적으로 하나의 포트에서 다른 포트로 프레임을 복사한다.</p>
  </li>
</ul>

<h3 id="wan-wide-area-network">WAN (Wide Area Network)</h3>

<p>계층구조의 상부에서 다수의 비호환성 LAN들은 라우터라고 부르는 특별한 컴퓨터에 의해서 연결될 수 있으며, <strong>라우터는 네트워크 간 연결을 구성한다(상호연결 네트워크)</strong>. 각 라우터는 이들이 연결되는 각 네트워크에 대해 어댑터(포트)를 가지고 있다. <strong>라우터는 또한 고속의 point-to-point 전화 연결을 할 수 있으며, 이들은 WAN이라고 하는 네트워크의 사례다</strong>. 이 이름은 이들이 LAN보다 지리적으로 더 넓은 지역에서 운용되기 때문에 불리게 되었다.</p>

<h3 id="internet">internet</h3>

<p><strong>internet의 중요한 특성은 이것이 매우 다르고 비호환적인 기술을 갖는 여러 가지 LAN과 WAN들로 이루어져 있다는 점이다</strong>. internet 프로토콜은 두 가지 기본 기능을 제공해야 한다.</p>

<ul>
  <li>
    <p>명명법(Naming Scheme) : internet 프로토콜은 호스트 주소를 위한 통일된 포맷을 정의해서 이 차이점들을 줄인다.</p>
  </li>
  <li>
    <p>전달기법(Delivery Mechanism) : internet 프로토콜은 데이터 비트를 패킷(packet)이라고 부르는 비연속적인 단위로 묶는 통일된 방법을 정의해서 이 차이점을 줄인다. 패킷은 패킷 크기와 소스 및 목적지 호스트 주소를 포함하는 헤더와 소스 호스트가 보낸 데이터 비트를 포함하는 데이터로 구성된다. 이것을 Datagram이라고도 부른다.</p>
  </li>
</ul>

<p>전달기법 관련하여서 패킷화하는 과정은 아래 사진과 같다. 여기서 말하는 Datagram은 (1) → (2) 로 가는 방법이다.</p>

<p><img src="/assets/img/blog/computerscience/internetpacket.png" alt="인터넷 패킷화 과정" /></p>

<h2 id="글로벌-ip-인터넷">글로벌 IP 인터넷</h2>

<p>인터넷 클라이언트 - 서버 응용의 기본적인 하드웨어 및 소프트웨어 구조는 아래 사진과 같으며, 이 구조는 1980년대 이후로 안정적이었다.</p>

<p><img src="/assets/img/blog/computerscience/clientserverstructure.png" alt="클라이언트 서버 구조" /></p>

<p>각 인터넷 호스트는 TCP/IP 프로토콜(Transmission Control Protocol/Internet Protocol)을 구현한 소프트웨어를 실행하며, 이것은 거의 모든 현대 컴퓨터 시스템에서 지원되고 있다.</p>

<p>관련한 프로토콜 HTTP/TCP/UDP 관련하여서는 <a href="../../computersystem/http-tcp-udp" class="heading flip-title">HTTP, TCP, UDP</a>을 참고하면 된다.</p>

<h3 id="ip-주소">IP 주소</h3>

<p>IPv4 주소는 비부호형 32비트 정수다. 네트워크 프로그램은 IP주소를 아래와 같은 IP주소 구조체에 저장한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* IP address structure */</span>
<span class="k">struct</span> <span class="n">in_addr</span> <span class="p">{</span>
<span class="kt">uint32_t</span> <span class="n">s_addr</span><span class="p">;</span> <span class="cm">/* Address in network byte order (big-endian) */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>TCP/IP는 네트워크 패킷 헤더에 포함되는 IP 주소 같은 모든 정수형 데이터 아이템에 대해서 통일된 <strong>Network Byte Order(Big Endian 바이트 순서)</strong>를 정의한다.</p>

<ul>
  <li>
    <p>Big Endian : 가장 큰 자릿값(최상위 바이트)을 가장 낮은 주소에, 그 다음 바이트를 뒤쪽 주소에 차례로 저장</p>
  </li>
  <li>
    <p>Little Endian : 반대로 최하위 바이트를 가장 낮은 주소에 두고, 큰 바이트로 갈수록 주소가 커짐. x86, ARM(Android/iOS) 같은 현대 CPU 대부분이 사용함</p>
  </li>
</ul>

<h4 id="dotted-decimal">Dotted-decimal</h4>

<p>IP 주소는 대게 사람들에게 dotted-decimal 표기라고 하는 형식으로 제시되며, 이것은 각 바이트가 십진수 값을 사용하고 다른 바이트들과는 점을 사용해서 구분된다. 아래와 같은 것이 dotted-decimal이다.</p>

<pre><code class="language-linux">linux&gt; hostname -i
128.2.210.175
</code></pre>

<h3 id="인터넷-도메인-이름">인터넷 도메인 이름</h3>

<p><strong>DNS(Domain Name System)</strong> 데이터베이스는 수백만 개의 호스트 엔트리로 구성되어 있으며, 이들 각각은 도메인 이름의 집합과 IP 주소 집합 사이의 매핑을 정의한다.</p>

<p>4가지의 매핑을 아래에 나열하겠다.</p>

<ol>
  <li>가장 간단한 경우로, 도메인 이름과 IP 주소 사이의 일대일 매핑</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup whaleshark.ics.cs.cmu.edu
Address: 128.2.210.175
</code></pre>

<ol>
  <li>다수의 도메인 이름이 동일한 IP 주소에 매핑</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup cs.mit.edu
Address: 18.62.1.6

linux&gt; nslookup eecs.mit.edu
Address: 18.62.1.6
</code></pre>

<ol>
  <li>다수의 도메인 이름들은 다수의 IP 주소로 매핑</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup www.twitter.com
Address: 199.16.156.6
Address: 199.16.156.70
Address: 199.16.156.102
Address: 199.16.156.230

linux&gt; nslookup twitter.com
Address: 199.16.156.102
Address: 199.16.156.230
Address: 199.16.156.6
Address: 199.16.156.70
</code></pre>

<ol>
  <li>마지막으로, 일부 유효한 도메인 이름들은 어떤 IP 주소에도 매핑되어 있지 않다.</li>
</ol>

<pre><code class="language-linux">linux&gt; nslookup edu
*** Can’t find edu: No answer
linux&gt; nslookup ics.cs.cmu.edu
*** Can’t find ics.cs.cmu.edu: No answer
</code></pre>

<h3 id="인터넷-연결">인터넷 연결</h3>

<p><strong>인터넷 client와 server는 연결(connection)을 통해서 바이트 스트림을 주고받는 방식으로 통신한다</strong>. 이 연결은 두개의 프로세스를 연결한다는 점에서 <strong>point-to-point 연결</strong>이다. 데이터가 동시에 양방향으로 흐를 수 있다는 의미에서 이것은 <strong>완전양방향(full-duplex)</strong>이다.</p>

<ul>
  <li>
    <p>소켓(Socket)은 연결의 종단점이다.</p>
  </li>
  <li>
    <p>각 소켓은 인터넷 주소와 16비트 정수 포트로 이루어진 소켓 주소를 가지며, 이것은 address : port로 나타낸다.</p>
  </li>
  <li>
    <p>클라이언트의 소켓 주소 내의 포트는 클라이언트가 연결 요청을 할 때 커널이 자동으로 할당하며, 이것은 단기(Ephemeral) 포트라고 한다.</p>
  </li>
  <li>
    <p>서버는 서비스에 연관된 포트를 사용한다.</p>
  </li>
</ul>

<p>인터넷 연결같은 경우 두 개의 종단점의 소켓 주소에 의해 유일하게 식별된다. 이 두개의 소켓 주소는 소켓 쌍이라고 알려져 있으며, 아래와 같이 tuple로 나타낸다.</p>

<p><img src="/assets/img/blog/computerscience/internetconnection.png" alt="인터넷 연결의 구조" /></p>

<h2 id="소켓-인터페이스">소켓 인터페이스</h2>

<p>소켓 인터페이스는 네트워크 응용을 만들기 위한 Unix I/O 함수들과 함께 사용되는 함수들의 집합이다. 이것은 모든 Unix 변종, 윈동, 매킨토시 시스템을 포함하는 대부분의 현대 시스템에서 구현되었다. 아래와 같은 그림은 전형적인 client-server transaction의 문맥에서 소켓 인터페이스의 개요를 보여준다.</p>

<p><img src="/assets/img/blog/computerscience/socketinterfaceoverview.png" alt="소켓 인터페이스 기반 네트워크 응용 프로그램의 개요" /></p>

<h3 id="소켓-주소-구조체">소켓 주소 구조체</h3>

<p><strong>리눅스 커널의 관점에서 보면, 소켓은 통신을 위한 끝점이다. Unix 프로그램의 관점에서 보면 소켓은 해당 식별자를 가지는 열린 파일이다</strong>.</p>

<ul>
  <li>Unix 프로그램에서는 network도 파일처럼 여겨진다.</li>
</ul>

<p>인터넷 소켓 주소는 아래 코드와 같이 프로토콜에 특화된 구조체로, 모든 포인터를 포괄적인 구조체로 캐스팅하도록 정의하는 것이었다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* IP socket address structure */</span>
<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="p">{</span>
<span class="kt">uint16_t</span> <span class="n">sin_family</span><span class="p">;</span> <span class="cm">/* Protocol family (always AF_INET) */</span>
<span class="kt">uint16_t</span> <span class="n">sin_port</span><span class="p">;</span> <span class="cm">/* Port number(16bit) in network byte order */</span>
<span class="k">struct</span> <span class="n">in_addr</span> <span class="n">sin_addr</span><span class="p">;</span> <span class="cm">/* IP address in network byte order */</span>
<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">sin_zero</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* Pad to sizeof(struct sockaddr) */</span>
<span class="p">};</span>

<span class="cm">/* Generic socket address structure (for connect, bind, and accept) */</span>
<span class="k">struct</span> <span class="n">sockaddr</span> <span class="p">{</span>
<span class="kt">uint16_t</span> <span class="n">sa_family</span><span class="p">;</span> <span class="cm">/* Protocol family */</span>
<span class="kt">char</span> <span class="n">sa_data</span><span class="p">[</span><span class="mi">14</span><span class="p">];</span> <span class="cm">/* Address data */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>위에 두가지 구조체가 등장하는데, 첫번째 구조체는 IPv4전용 주소 구조체이며, 두번째 구조체는 TCP, IPv6, IPv4, UDP 등 범용적으로 사용할 수 있는 구조체이다.</p>

<p>첫번째 구조체에서 두번째 구조체로 캐스팅할 필요가 있을 떄, 아래와 같은 타입을 사용한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="n">SA</span><span class="p">;</span>
</code></pre></div></div>

<h3 id="socket-함수">socket 함수</h3>

<p><strong>Client</strong>와 <strong>server</strong>는 소켓 식별자를 생성하기 위해 socket 함수를 사용한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">socket</span><span class="p">(</span><span class="kt">int</span> <span class="n">domain</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">protocol</span><span class="p">);</span>

<span class="cm">/* Returns: nonnegative descriptor if OK, −1 on error */</span>
</code></pre></div></div>

<p>음이 아닌 정수를 반환하며, 이 정수는 식별자다. 이 식별자로 커널 내부의 소켓 자료구조를 찾아갈 수 있어서 프로그래머에게는 핸들(handle) 역할을 함</p>

<h3 id="connect-함수">connect 함수</h3>

<p><strong>Client</strong>는 connect함수를 호출해서 server와의 연결을 수립한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">connect</span><span class="p">(</span><span class="kt">int</span> <span class="n">clientfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
<span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
<span class="o">~~~</span><span class="n">c</span>

<span class="n">connect</span> <span class="err">함수는</span> <span class="err">소켓</span> <span class="err">주소</span> <span class="n">addr</span><span class="err">의</span> <span class="err">서버와</span> <span class="err">인터넷</span> <span class="err">연결을</span> <span class="err">시도하며</span><span class="p">,</span> <span class="n">addrlen</span><span class="err">은</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sockaddr_in</span><span class="p">)</span><span class="err">이</span> <span class="err">된다</span><span class="p">.</span> <span class="n">connect</span><span class="err">함수는</span> <span class="err">연결이</span> <span class="err">성공할</span> <span class="err">때까지</span> <span class="err">블록되어</span> <span class="err">있거나</span> <span class="err">에러가</span> <span class="err">발생한다</span><span class="p">.</span> <span class="err">만일</span> <span class="err">성공이라면</span><span class="p">,</span> <span class="n">clientfd</span> <span class="err">식별자는</span> <span class="err">이제</span> <span class="err">읽거나</span> <span class="err">쓸</span> <span class="err">준비가</span> <span class="err">되었으며</span><span class="p">,</span> <span class="err">이</span> <span class="err">연결은</span> <span class="err">다음과</span> <span class="err">같은</span> <span class="err">소켓</span> <span class="err">쌍으로</span> <span class="err">규정된다</span><span class="p">.</span>

<span class="o">~~~</span><span class="n">c</span>
<span class="p">(</span><span class="n">x</span><span class="o">:</span><span class="n">y</span><span class="p">,</span> <span class="n">addr</span><span class="p">.</span><span class="n">sin_addr</span><span class="o">:</span><span class="n">addr</span><span class="p">.</span><span class="n">sin_port</span><span class="p">)</span>
</code></pre></div></div>

<h3 id="bind-함수">bind 함수</h3>

<p>남아 있는 소켓 함수 bind, listen, accept는 server가 client와 연결을 수립하기 위해 사용한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">bind</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span>
<span class="n">socklen_t</span> <span class="n">addrlen</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span>
</code></pre></div></div>

<p>bind 함수는 kernel에게 addr에 있는 server의 소켓 주소를 소켓 식별자 sockfd와 연결하라고 물어본다.</p>

<h3 id="listen-함수">listen 함수</h3>

<p>client는 연결 요청을 개시하는 능동적 개체이다. server는 client로부터의 연결 요청을 기다리는 수동적 개체이다. 그래서 socket함수가 함수가 만든 식별자는 한 연결의 클라이언트 쪽 끝에서 존재하는 능동 소켓에 대응된다. 서버는 listen함수를 호출해서 이 식별자를 client 대신에 server가 사용하게 될 것이라고 알려준다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">listen</span><span class="p">(</span><span class="kt">int</span> <span class="n">sockfd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backlog</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, −1 on error */</span> 
</code></pre></div></div>

<p>listen 함수는 sockfd를 능동 소켓에서 듣기 소켓으로 변환하며, 듣기 소켓은 client로부터의 연결 요청을 승락할 수 있다.</p>

<h3 id="accept-함수">accept 함수</h3>

<p>서버는 accept함수를 호출해서 client로부터의 연결 요청을 기다린다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">accept</span><span class="p">(</span><span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">addr</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">addrlen</span><span class="p">);</span>

<span class="cm">/* Returns: nonnegative connected descriptor if OK, −1 on error */</span>
</code></pre></div></div>

<p>accept함수는 client로부터의 연결 요청이 듣기 식별자 listenfd에 도달하기를 기다리고, 그 후에 addr 내의 client의 소켓 주소를 채우고, Unix I/O 함수들을 사용해서 client와 통신하기 위해 사용될 수 있는 연결 식별자를 리턴한다.</p>

<h4 id="듣기-식별자와-연결-식별자">듣기 식별자와 연결 식별자</h4>

<p>듣기 식별자와 연결 식별자 사이의 구분은 많은 학생들을 혼란스럽게 한다. 듣기 식별자는 client 연결 요청에 대해 끝점으로서의 역할을 한다. 이것은 대개 한 번 생성되며, 서버가 살아있는 동안 계속 존재한다. 연결 식별자는 client와 server 사이에 성립된 연결의 끝점이다. 이것은 server가 연결 요청을 수락할 때마다 생성되며, server가 client에 서비스하는 동안에만 존재한다.</p>

<p>accept함수의 flow를 그림을 통해서 설명해 보겠다. 듣기 식별자와 연결 식별자 구분에 도움이 될 것이다.</p>

<p><img src="/assets/img/blog/computerscience/listeningandconnecteddescriptor.png" alt="듣기와 연결 식별자의 역할" /></p>

<ol>
  <li>
    <p>server는 accept를 호출하고, 이것은 연결 요청이 읽기 식별자에 도달하기를 기다리며, 명확하게 하기 위해서 이것을 식별자 3이라고 가정한다. 식별자 0 ~ 2는 표준 파일들을 위해 배정되어 있다는 점을 기억하라.</p>
  </li>
  <li>
    <p>client는 connect함수를 호출하고, 이것은 listenfd로 연결 요청을 보낸다.</p>
  </li>
  <li>
    <p>accept함수는 새로운 연결 식별자 connfd(이것은 식별자 4라고 가정한다)를 오픈하고, clientfd와 connfd 사이의 연결을 수립하고 응용에 connfd를 리턴한다. client는 또한 connect에서 return하고, 이 지점에서 client와 server는 clientfd와 connfd를 각각 읽고 쓰는 방법으로 data를 주고받을 수 있다.</p>
  </li>
</ol>

<h3 id="호스트와-서비스-변환getaddrinfo--getnameinfo">호스트와 서비스 변환(getaddrinfo &amp; getnameinfo)</h3>

<p>리눅스는 getaddrinfo와 getnameinfo라고 하는 강력한 함수들을 제공하는데, 소켓 interface와 함께 이용될 때 매우 유용하다. 또한 우리가 특정 IP 프로토콜의 버전에 의존하지 않는 네트워크 프로그램을 작성하게 해준다.</p>

<h4 id="getaddrinfo-함수">getaddrinfo 함수</h4>

<p>getaddrinfo함수는 host이름, host주소, service이름, port번호의 스트링 표시를 소켓 주소 구조체로 변환한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/types.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">getaddrinfo</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">service</span><span class="p">,</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">hints</span><span class="p">,</span>
<span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">**</span><span class="n">result</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, nonzero error code on error */</span>

<span class="kt">void</span> <span class="nf">freeaddrinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">result</span><span class="p">);</span>
<span class="n">Returns</span><span class="o">:</span> <span class="n">nothing</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">gai_strerror</span><span class="p">(</span><span class="kt">int</span> <span class="n">errcode</span><span class="p">);</span>

<span class="cm">/* Returns: error message */</span>
</code></pre></div></div>

<p>host와 service(소켓 주소의 두 개의 구성요소)가 주어지면, getaddrinfo는 각각이 host와 service에 대응되는 소켓 주소 구조체를 가리키는 addrinfo 구조체의 연결리스트를 가리키는 <strong>result(pointer)를 return</strong>한다. result로 부터의 연결 리스트는 아래 사진과 같다.</p>

<p><img src="/assets/img/blog/computerscience/getaddrinfolinkedlist.png" alt="getaddrinfo result의 자료구조" /></p>

<p>연결리스트로 반환하는 이유에 대해서는, 하나의 IP로 접속이 실패할 수 있기 때문에, 그것에 대한 backup용으로 여러개의 IP를 포함시키기 위함이다.</p>

<p>addrinfo에는 다음 같은 구조로 되어 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">addrinfo</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">ai_flags</span><span class="p">;</span> <span class="cm">/* Hints argument flags */</span>
<span class="kt">int</span> <span class="n">ai_family</span><span class="p">;</span> <span class="cm">/* First arg to socket function */</span>
<span class="kt">int</span> <span class="n">ai_socktype</span><span class="p">;</span> <span class="cm">/* Second arg to socket function */</span>
<span class="kt">int</span> <span class="n">ai_protocol</span><span class="p">;</span> <span class="cm">/* Third arg to socket function */</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">ai_canonname</span><span class="p">;</span> <span class="cm">/* Canonical hostname */</span>
<span class="kt">size_t</span> <span class="n">ai_addrlen</span><span class="p">;</span> <span class="cm">/* Size of ai_addr struct */</span>
<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">ai_addr</span><span class="p">;</span> <span class="cm">/* Ptr to socket address structure */</span>
<span class="k">struct</span> <span class="n">addrinfo</span> <span class="o">*</span><span class="n">ai_next</span><span class="p">;</span> <span class="cm">/* Ptr to next item in linked list */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>기본적으로, host에 연관된 각각의 고유의 주소에 대해, getaddrinfo함수는 최대 세개의 addrinfo 구조체를 return할 수 있으며, 각각은 서로 다른 ai_socktype 필드를 갖는다 : 한 개는 연결을 위해, 하나는 datagram, 마지막 하나는 원시 소켓을 위해.</p>

<h4 id="getnameinfo-함수">getnameinfo 함수</h4>

<p>getnameinfo함수는 getaddrinfo의 역이다. 이것은 소켓 주소 구조체를 대응되는 host와 service이름 스트링으로 변환한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;sys/socket.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;netdb.h&gt;</span><span class="cp">
</span><span class="kt">int</span> <span class="nf">getnameinfo</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">sa</span><span class="p">,</span> <span class="n">socklen_t</span> <span class="n">salen</span><span class="p">,</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">host</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">hostlen</span><span class="p">,</span>
<span class="kt">char</span> <span class="o">*</span><span class="n">service</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">servlen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/* Returns: 0 if OK, nonzero error code on error */</span>
</code></pre></div></div>

<h3 id="open_clientfd함수">open_clientfd함수</h3>

<p>client는 open_clientfd를 호출해서 server와 연결을 설정한다. 여기 안에 socket interface함수들이 많이 포함되어 있다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">open_clientfd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">clientfd</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">listp</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

    <span class="cm">/* Get a list of potential server addresses */</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">addrinfo</span><span class="p">));</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span> <span class="cm">/* Open a connection */</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="n">AI_NUMERICSERV</span><span class="p">;</span> <span class="cm">/* ... using a numeric port arg. */</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">|=</span> <span class="n">AI_ADDRCONFIG</span><span class="p">;</span> <span class="cm">/* Recommended for connections */</span>
    <span class="n">Getaddrinfo</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listp</span><span class="p">);</span>

    <span class="cm">/* Walk the list for one that we can successfully connect to */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">listp</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Create a socket descriptor */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">clientfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span> <span class="cm">/* Socket failed, try the next */</span>

        <span class="cm">/* Connect to the server */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">connect</span><span class="p">(</span><span class="n">clientfd</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span> <span class="cm">/* Success */</span>
        <span class="n">Close</span><span class="p">(</span><span class="n">clientfd</span><span class="p">);</span> <span class="cm">/* Connect failed, try another */</span>
    <span class="p">}</span>

    <span class="cm">/* Clean up */</span>
    <span class="n">Freeaddrinfo</span><span class="p">(</span><span class="n">listp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="cm">/* All connects failed */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">else</span> <span class="cm">/* The last connect succeeded */</span>
        <span class="k">return</span> <span class="n">clientfd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>함수를 실행하면 최종적으로 clientfd를 반환한다.</p>

<h3 id="open_listenfd함수">open_listenfd함수</h3>

<p>server는 open_listenfd함수를 호출해서 연결요청을 받을 준비가 된 듣기 식별자를 생성한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">open_listenfd</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">addrinfo</span> <span class="n">hints</span><span class="p">,</span> <span class="o">*</span><span class="n">listp</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">optval</span><span class="o">=</span><span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* Get a list of potential server addresses */</span>
    <span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">addrinfo</span><span class="p">));</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_socktype</span> <span class="o">=</span> <span class="n">SOCK_STREAM</span><span class="p">;</span> <span class="cm">/* Accept connections */</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">=</span> <span class="n">AI_PASSIVE</span> <span class="o">|</span> <span class="n">AI_ADDRCONFIG</span><span class="p">;</span> <span class="cm">/* ... on any IP address */</span>
    <span class="n">hints</span><span class="p">.</span><span class="n">ai_flags</span> <span class="o">|=</span> <span class="n">AI_NUMERICSERV</span><span class="p">;</span> <span class="cm">/* ... using port number */</span>
    <span class="n">Getaddrinfo</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hints</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">listp</span><span class="p">);</span>

    <span class="cm">/* Walk the list for one that we can bind to */</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">listp</span><span class="p">;</span> <span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_next</span><span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* Create a socket descriptor */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">listenfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_family</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_socktype</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_protocol</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span> <span class="cm">/* Socket failed, try the next */</span>

        <span class="cm">/* Eliminates "Address already in use" error from bind */</span>
        <span class="n">Setsockopt</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">SOL_SOCKET</span><span class="p">,</span> <span class="n">SO_REUSEADDR</span><span class="p">,</span>
                <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">optval</span> <span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>

        <span class="cm">/* Bind the descriptor to the address */</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">bind</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addr</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">ai_addrlen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">break</span><span class="p">;</span> <span class="cm">/* Success */</span>
        <span class="n">Close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span> <span class="cm">/* Bind failed, try the next */</span>
    <span class="p">}</span>

    <span class="cm">/* Clean up */</span>
    <span class="n">Freeaddrinfo</span><span class="p">(</span><span class="n">listp</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="cm">/* No address worked */</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="cm">/* Make it a listening socket ready to accept connection requests */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">listen</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="n">LISTENQ</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Close</span><span class="p">(</span><span class="n">listenfd</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">listenfd</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>함수를 실행하면 최종적으로 listenfd를 반환한다.</p>

<h2 id="echo-client와-server">Echo client와 server</h2>

<p>이것은 교제에 나오는 한 예제인데, client가 server에 data를 보내면 server가 다시 client에 똑같은 data를 보내는 방식의 소통이다. 나는 이걸 구현할 때, 우선 책에 나와있는 예제를 따라서 쳐 보았다.</p>

<ul>
  <li>echoclient.c
~~~c
#include “csapp.h” // robust I/O 함수들과 네트워크 래퍼 함수들이 정의된 헤더</li>
</ul>

<p>int main(int argc, char **argv)
{
    int clientfd; // 클라이언트 소켓 식별자
    char *host, *port, *buf[MAXLINE]; // 서버 호스트명, 포트 번호, 버퍼
    rio_t rio; // robust I/O 구조체</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 명령줄 인자가 3개가 아니면 사용법 출력 후 종료
if (argc != 3)
{
    fprintf(stderr, "usage: %s &lt;host&gt; &lt;port&gt;\n", argv[0]); // 사용법 출력
    exit(0);
}

// 호스트명과 포트 번호를 명령줄 인자에서 가져옴
host = argv[1]; // 호스트명
port = argv[2]; // 포트 번호

// 서버에 연결하기 위한 클라이언트 소켓 열기
clientfd = Open_clientfd(host, port); // 호스트와 포트 번호로 클라이언트 소켓 열기

// 클라이언트 소켓을 기반으로 robust I/O 구조체 초기화
Rio_readinitb(&amp;rio, clientfd); // 클라이언트 소켓을 기반으로 rio 구조체 초기화

// 사용자로부터 한 줄씩 입력받아 서버에 전송하는 반복문
while (Fgets(buf, MAXLINE, stdin) != NULL) // 표준 입력으로부터 한 줄 읽기
{
    // 읽은 데이터를 서버에 전송
    Rio_writen(clientfd, buf, strlen(buf)); // 클라이언트 소켓을 통해 서버에 데이터 전송

    // 서버로부터 응답을 읽어와서 출력
    Rio_readlineb(&amp;rio, buf, MAXLINE); // 서버로부터 한 줄 읽기
    
    // 읽은 데이터를 표준 출력으로 출력
    Fputs(buf, stdout);
}

Close(clientfd); // 클라이언트 소켓 닫기
exit(0); // 프로그램 종료 } ~~~
</code></pre></div></div>

<ul>
  <li>echoserveri.c
~~~c
#include “csapp.h”          // robust I/O 함수와 네트워크 함수 래퍼가 포함된 헤더 파일</li>
</ul>

<p>void echo(int connfd);</p>

<p>int main(int argc, char **argv)
{
    int listenfd, connfd;   // 서버의 listen용 듣기 식별자와 클라이언트 연결용 연결 식별자
    socklen_t clientlen;    // 클라이언트 주소 구조체의 크기
    struct sockaddr_storage clientaddr; // 클라이언트 주소 or domain name 저장할 구조체
    char client_hostname[MAXLINE], client_port[MAXLINE]; // 클라이언트 호스트명과 포트 번호를 저장할 버퍼</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// 명령줄 인자가 2개가 아니면 사용법 출력 후 종료
if (argc != 2)
{
    fprintf(stderr, "usage: %s &lt;port&gt;\n", argv[0]); // 사용법 출력
    exit(0);
}

// 포트 번호를 인자로 받아 서버 리슨 소켓 열기
listenfd = Open_listenfd(argv[1]); // argv[1] 포트 번호로 리슨 소켓 열기

while (1)   // 반복형 서버: 클라이언트가 연결 올 때마다 반복
{
    clientlen = sizeof(struct sockaddr_storage); // 클라이언트 주소 구조체 크기 초기화
    // 클라이언트 연결 요청을 수락하고 연결된 소켓 식별자(connfd) 반환
    connfd = Accept(listenfd, (SA *)&amp;clientaddr, &amp;clientlen);

    // 클라이언트 주소를 문자열로 변환하여 client_hostname과 client_port에 저장
    Getnameinfo((SA *)&amp;clientaddr, clientlen, client_hostname, MAXLINE,
                client_port, MAXLINE, 0);
    // 클라이언트의 호스트명과 포트 번호를 출력
    printf("Connected to (%s, %s)\n", client_hostname, client_port);
    // 클라이언트와 연결된 connfd를 인자로 하여 echo 함수 호출
    echo(connfd);
    // 클라이언트와의 연결 종료
    Close(connfd);
}
exit(0); // 프로그램 종료 } ~~~
</code></pre></div></div>

<p>한 번에 한 개씩의 client를 반복해서 실행하는 이런 종류의 서버를 반복서버(iterative server)라고 부른다.</p>

<ul>
  <li>echo.c
~~~c
#include “csapp.h”          // robust I/O 함수와 관련 구조체를 포함한 헤더 파일 포함</li>
</ul>

<p>// 클라이언트와 연결된 소켓 파일 디스크립터(connfd)를 인자로 받음
void echo(int connfd)
{
    size_t n;               // 읽은 바이트 수를 저장할 변수
    char buf[MAXLINE];      // 데이터를 읽어올 버퍼 (한 줄 최대 MAXLINE 크기)
    rio_t rio;              // robust I/O 버퍼 구조체</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// connfd(클라이언트와 연결된 소켓)를 기반으로 rio 구조체 초기화
Rio_readinitb(&amp;rio, connfd);

// 클라이언트로부터 한 줄씩 데이터를 계속 읽어들이는 반복문
while ((n = Rio_readlineb(&amp;rio, buf, MAXLINE)) != 0)
{
    // 읽은 바이트 수를 서버 로그로 출력
    printf("server received %zu bytes\n", n);

    // 읽은 데이터를 그대로 다시 클라이언트에게 돌려보냄 (Echo!)
    Rio_writen(connfd, buf, n);
} } ~~~
</code></pre></div></div>

<h2 id="웹-기초">웹 기초</h2>

<p>Web client와 server는 HTTP(Hypertext Transfer Protocol)라고 하는 텍스트 기반 응용수준 프로토콜을 사용해서 상호 연동한다.</p>

<p>무엇이 FTP 같은 전통적인 파일 전송 서비스를 web service와 구별하게 해주는가?</p>

<ul>
  <li>
    <p>주요 차이점은 web contents는 HTML(Hpertext Markup Language)이라는 언어로 작성될 수 있다는 것이다.</p>
  </li>
  <li>
    <p>HTML 프로그램(페이지)은 명령들(태그)을 포함하고 있어서 브라우제에게 여러 가지 텍스트와 그래픽 객체를 페이지에 어떻게 표시할지를 알려준다.</p>
  </li>
</ul>

<h3 id="웹-컨텐츠">웹 컨텐츠</h3>

<p>Web client와 server에게, contents는 연관된 MIME(Multipurpose Internet Mail Extensions) 타입을 갖는 바이트 배열이다. 아래는 많이 쓰이는 MIME 타입들이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">MIME type</th>
      <th style="text-align: center">Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">text/html</td>
      <td style="text-align: center">HTML page</td>
    </tr>
    <tr>
      <td style="text-align: center">text/plain</td>
      <td style="text-align: center">Unformatted text</td>
    </tr>
    <tr>
      <td style="text-align: center">application/postscript</td>
      <td style="text-align: center">Postscript document</td>
    </tr>
    <tr>
      <td style="text-align: center">image/gif</td>
      <td style="text-align: center">Binary image encoded in GIF format</td>
    </tr>
    <tr>
      <td style="text-align: center">image/png</td>
      <td style="text-align: center">Binary image encoded in PNG format</td>
    </tr>
    <tr>
      <td style="text-align: center">image/jpeg</td>
      <td style="text-align: center">Binary image encoded in JPEG format</td>
    </tr>
  </tbody>
</table>

<p>Web server는 두 가지 서로 다른 방법으로 client에게 contents를 제공한다.</p>

<ul>
  <li>
    <p>디스크 파일을 가져와서 그 내용을 client에게 보낸다. 디스크 파일은 정적 컨텐츠라고 하며, 파일을 client에게 돌려주는 작업은 정적 컨텐츠 처리한다고 말한다.</p>
  </li>
  <li>
    <p>실행파일을 돌리고, 그 출력을 client에게 보낸다. 실행파일이 런타임에 만든 출력을 동적 컨텐츠라고 하며, 프로그램을 실행하고 그 결과를 client에게 보내주는 과정을 동적 컨텐츠 처리한다고 말한다.</p>
  </li>
</ul>

<p>Web server가 return하는 모든 내용들은 server가 관리하는 file에 연관된다. 이 파일 각각은 URL(Universal Resource Locator)라고 하느 고유의 이름을 가진다. 예를 들어, 다음과 같은 URL은</p>

<pre><code class="language-url">https://www.google.com:80/index.html
</code></pre>

<p>포트 80에서 듣고있는 웹 서버가 관리하는 인터넷 호스트 www.google.com의 /index.html이라는 HTML 파일을 지정한다.</p>

<p>여기서 접두어는</p>

<pre><code class="language-url">https://www.google.com:80
</code></pre>

<p>이고, 접두어를 통해 어떤 종류의 서버에 접속해야 하는지 결정하고, 어디에 서버가 있는지, 서버가 무슨 포트를 듣고 있는지를 결정한다.</p>

<p>접미어는</p>

<pre><code class="language-url">/index.html
</code></pre>

<p>이며, 자신의 파일 시스템 상의 파일을 검색하고, 이 요청이 정적 또는 동적 컨텐츠에 대한 것인지 결정한다.</p>

<p>실행파일을 위한 URL은 파일 이름 뒤에 프로그램의 인자를 포함할 수 있다. ‘?’ 문자는 파일 이름과 인자를 구분하며, 각 인자는 ‘&amp;’로 구분된다. 예를 들어, 다음의 URL은</p>

<pre><code class="language-url">hppts://bluefish.ics.cs.cmu.edu:8000/cgi-bin/adder?15000&amp;213
</code></pre>

<p>/cgi-bin/adder라는 실행파일을 식별하고, 이 파일은 두 개의 인자(15000과 213)와 함께 호출된다.</p>

<h3 id="동적-컨텐츠의-처리">동적 컨텐츠의 처리</h3>

<p>여기는 다시 한번 공부해보자.</p>

<h2 id="소형-웹-서버tiny-web-server">소형 웹 서버(Tiny web server)</h2>

<p>작은 웹 서버를 C와 html로 구현해보자</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* $begin tinymain */</span>
<span class="cm">/*
 * tiny.c - A simple, iterative HTTP/1.0 Web server that uses the
 *     GET method to serve static and dynamic content.
 *
 * Updated 11/2019 droh
 *   - Fixed sprintf() aliasing issue in serve_static(), and clienterror().
 */</span>
<span class="cp">#include</span> <span class="cpf">"csapp.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">read_requesthdrs</span><span class="p">(</span><span class="n">rio_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cgiargs</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">serve_static</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">filesize</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">get_filetype</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filetype</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">serve_dynamic</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cgiargs</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">clienterror</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cause</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errnum</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">shortmsg</span><span class="p">,</span>
                 <span class="kt">char</span> <span class="o">*</span><span class="n">longmsg</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">hostname</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">port</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="n">socklen_t</span> <span class="n">clientlen</span><span class="p">;</span>
  <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">clientaddr</span><span class="p">;</span>

  <span class="cm">/* Check command line args */</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Open_listenfd</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">clientlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">);</span>
    <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span>
                    <span class="o">&amp;</span><span class="n">clientlen</span><span class="p">);</span> <span class="c1">// line:netp:tiny:accept</span>
    <span class="n">Getnameinfo</span><span class="p">((</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="n">clientlen</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span>
                <span class="mi">0</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Accepted connection from (%s, %s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
    <span class="n">doit</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>  <span class="c1">// line:netp:tiny:doit</span>
    <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span> <span class="c1">// line:netp:tiny:close</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span> <span class="c1">// fd : 클라이언트 소켓 파일 디스크립터(웹브라우저 연결)</span>
  <span class="c1">// 이 함수를 통해 요청을 읽고 응답을 보내는 한 사이클이 이루어짐.</span>

  <span class="c1">// 변수 선언</span>
  <span class="kt">int</span> <span class="n">is_static</span><span class="p">;</span>    <span class="c1">// 정적인 파일 요청인지 여부</span>
  <span class="k">struct</span> <span class="n">stat</span> <span class="n">sbuf</span><span class="p">;</span> <span class="c1">// stat()으로 얻는 파일 정보 구조체</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">method</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">uri</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">version</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="c1">// buf : 전체 요청 줄 저장</span>
  <span class="c1">//  method : GET, POST 같은 요청 방식</span>
  <span class="c1">//  uri : 요청된 자원경로 ex) index.html</span>
  <span class="kt">char</span> <span class="n">filename</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">cgiargs</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="c1">// filename : 실제 서버 상의 파일경로</span>
  <span class="c1">// cgiargs : CGI 프로그램에 넘길 인자</span>
  <span class="n">rio_t</span> <span class="n">rio</span><span class="p">;</span>

  <span class="c1">// 클라이언트 요청 한줄읽기</span>
  <span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
  <span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Request line: %s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"%s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="c1">// HTTP 요청의 첫줄은 이런 형태 : GET /index.html HTTP/1.1.</span>
  <span class="c1">// 이 줄을 buf에 저장한다.</span>

  <span class="c1">// 요청 파싱  파싱 : 어떤 문자열 데이터를 구조적으로 쪼개서 의미를 이해하는 과정</span>
  <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"%s %s %s"</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

  <span class="c1">// GET이외의 메서드는 거절한다</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">"GET"</span><span class="p">))</span>
  <span class="p">{</span>
    <span class="n">clienterror</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="s">"501"</span><span class="p">,</span> <span class="s">"Not inplemented"</span><span class="p">,</span> <span class="s">"Tiny does not implement this method"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span> <span class="c1">// 대소문자 구분 없이 "GET"인지 확인, POST,PUT 등이 오면 501 에러 반환</span>

  <span class="c1">// 요청 헤더 읽기</span>
  <span class="n">read_requesthdrs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio</span><span class="p">);</span> <span class="c1">// 나머지 요청 헤더들을 읽고 무시함</span>

  <span class="c1">// URI 파싱(정적VS동적)</span>
  <span class="n">is_static</span> <span class="o">=</span> <span class="n">parse_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">cgiargs</span><span class="p">);</span>
  <span class="c1">// ex) index,html -&gt; 정적 | cgi-bin/adder?arg1=1&amp;arg2=2 -&gt; 동적</span>
  <span class="c1">//  filename : 실제 서버 경로로 바뀜 | cgiargs : CGI 인자 저장</span>

  <span class="c1">// 파일 존재 확인</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">stat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbuf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">clienterror</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">"404"</span><span class="p">,</span> <span class="s">"Not found"</span><span class="p">,</span> <span class="s">"Tiny couldn't find this file"</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span> <span class="c1">// 파일이 없으면 404 Not Found</span>
  <span class="p">}</span>
  <span class="c1">// 정적 파일 제공</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">is_static</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">sbuf</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">S_IRUSR</span> <span class="o">&amp;</span> <span class="n">sbuf</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">clienterror</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">"403"</span><span class="p">,</span> <span class="s">"Forbidden"</span><span class="p">,</span> <span class="s">"Tiny couldn't read the file"</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// 정적 파일이 일반 파일인지, 읽을 수 있는지 확인</span>
    <span class="p">}</span>
    <span class="n">serve_static</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">sbuf</span><span class="p">.</span><span class="n">st_size</span><span class="p">);</span>
    <span class="c1">// serve_static()으로 파일 전송</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span> <span class="c1">// CGI 프로그램 실행</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">sbuf</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span> <span class="o">||</span> <span class="o">!</span><span class="p">(</span><span class="n">S_IXUSR</span> <span class="o">&amp;</span> <span class="n">sbuf</span><span class="p">.</span><span class="n">st_mode</span><span class="p">))</span>
    <span class="p">{</span>
      <span class="n">clienterror</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="s">"403"</span><span class="p">,</span> <span class="s">"Forbidden"</span><span class="p">,</span> <span class="s">"Tiny couldn't run the CGI program"</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// 실행 가능한 CGI 프로그램인지 확인</span>
    <span class="p">}</span>
    <span class="n">serve_dynamic</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">cgiargs</span><span class="p">);</span>
    <span class="c1">// serve_dynamic()으로 CGI 실행 후 결과 전송</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="c1">// 함수 헤더 ,이 함수는 에러 응답을 만드는 데 필요한 모든 정보를 받아서 사용한다.</span>
<span class="kt">void</span> <span class="nf">clienterror</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cause</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errnum</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">shortmsg</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">longmsg</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// fd:클라이언트와 연결된 소켓, cause:에러 원인 ex파일이름 , errnum : 상태코드 ex)404</span>
  <span class="c1">// shortmsg:짧은 설명 ex)Not Found , longmsg : 긴 설명 ex) Tiny couldn't find this file</span>
  <span class="c1">//  이 함수는 에러 응답을 만드는 데 필요한 모든 정보를 받아서 사용한다.</span>

  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">body</span><span class="p">[</span><span class="n">MAXBUF</span><span class="p">];</span>
  <span class="c1">// buf : HTTP 헤더를 담는 용도 | body : HTML 본문(에러 메세지 페이지)</span>

  <span class="c1">// HTML 본문(body) 작성</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s">"&lt;html&gt;&lt;title&gt;Tiny Error&lt;/title&gt;"</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s">"%s&lt;body bgcolor=</span><span class="se">\"</span><span class="s">ffffff</span><span class="se">\"</span><span class="s">&gt;</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s">"%s%s: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">errnum</span><span class="p">,</span> <span class="n">shortmsg</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s">"%s&lt;p&gt;%s: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">longmsg</span><span class="p">,</span> <span class="n">cause</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s">"%s&lt;hr&gt;&lt;em&gt;The Tiny Web server&lt;/em&gt;</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">body</span><span class="p">);</span>
  <span class="c1">// HTML 페이지를 한 줄씩 누적해서 작성</span>

  <span class="c1">// HTTP헤더와 본문을 출력</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"HTTP/1.0 %s %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">errnum</span><span class="p">,</span> <span class="n">shortmsg</span><span class="p">);</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
  <span class="c1">// HTTP/1.0 404 Not Found 같은 상태 줄 출력</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Content-type: text/html</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
  <span class="c1">// Content-type은 text/html(브라우저가 HTML로 렌더링 하도록)</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Content-length: %d</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">strlen</span><span class="p">(</span><span class="n">body</span><span class="p">));</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
  <span class="c1">// Content-length는 본문 길이</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">body</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">body</span><span class="p">));</span>
  <span class="c1">// 마지막에 실제 HTML 본물 출력</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">read_requesthdrs</span><span class="p">(</span><span class="n">rio_t</span> <span class="o">*</span><span class="n">rp</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//	•	rp: robust I/O 구조체 포인터 (Rio_readlineb 사용을 위한 스트림)</span>
  <span class="c1">//  •	역할: HTTP 요청 헤더를 한 줄씩 읽다가 빈 줄 "\r\n"이 나오면 멈춰.</span>
  <span class="c1">//  •	이유: HTTP 요청 헤더는 빈 줄로 끝난다는 규칙이 있기 때문.</span>

  <span class="c1">// 버퍼 선언</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

  <span class="c1">// 첫번째 줄 읽기</span>
  <span class="n">Rio_readlineb</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span>

  <span class="c1">// 빈 줄까지 반복해서 읽기</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span><span class="p">))</span>
  <span class="p">{</span>                                  <span class="c1">// 지금 읽은 줄이 빈 줄인지 확인</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Header: %s"</span><span class="p">,</span><span class="n">buf</span><span class="p">);</span>
    <span class="n">Rio_readlineb</span><span class="p">(</span><span class="n">rp</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">);</span> <span class="c1">// 빈줄(\r\n)이 나오기 전까지 계속 읽고 출력</span>
    <span class="c1">//printf("%s", buf);               // 헤더의 끝 줄은 빈 줄로 표시되므로 이 조건으로 반복 종료</span>
  <span class="p">}</span>
  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cgiargs</span><span class="p">)</span>
<span class="p">{</span> <span class="c1">// 요청된 URI가 정적인지(dynamic인지) 판단하고,해당하는 파일 이름과 CGI 인자를 추출</span>
  <span class="c1">//	•	uri: 클라이언트가 요청한 경로 (예: /index.html, /cgi-bin/adder?x=1&amp;y=2)</span>
  <span class="c1">//  •	filename: 실제 서버 파일 경로로 변환되어 담길 곳</span>
  <span class="c1">//  •	cgiargs: CGI 인자 문자열이 담길 곳</span>
  <span class="c1">//  •	리턴값:</span>
  <span class="c1">//    •	1이면 정적(static) 콘텐츠</span>
  <span class="c1">//    •	0이면 동적(dynamic) 콘텐츠</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strstr</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="s">"cgi-bin"</span><span class="p">))</span>
  <span class="p">{</span> <span class="c1">// 정적 콘텐츠라면</span>
    <span class="c1">//  •	strstr(uri, "cgi-bin")ㄹ이 NULL이면, "cgi-bin"이 없다는 뜻 → 정적 콘텐츠</span>
    <span class="c1">//  •	예: /index.html, /images/logo.png 등</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">cgiargs</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>             <span class="c1">// CGI 인자는 없음</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"."</span><span class="p">);</span>           <span class="c1">// 현재 디렉터리 기준 시작</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>           <span class="c1">// 파일 경로 완성</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uri</span><span class="p">[</span><span class="n">strlen</span><span class="p">(</span><span class="n">uri</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span> <span class="c1">// URI가 폴더로 끝나면</span>
      <span class="n">strcat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"home.html"</span><span class="p">);</span> <span class="c1">// 기본 파일로 home.html 사용</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>                        <span class="c1">// 정적 콘텐츠임을 반환</span>
  <span class="p">}</span>
  <span class="k">else</span>
  <span class="p">{</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">index</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="sc">'?'</span><span class="p">);</span> <span class="c1">// '?' 위치 찾기 (cgi 인자 구분자)</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
    <span class="p">{</span>                           <span class="c1">// 인자가 있는 경우</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">cgiargs</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// ? 뒤 내용 복사</span>
      <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>              <span class="c1">// ? 기준으로 문자열 자르기</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">cgiargs</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span> <span class="c1">// 인자 없음</span>
    <span class="p">}</span>

    <span class="n">strcpy</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">"."</span><span class="p">);</span> <span class="c1">// 경로 시작</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span> <span class="c1">// 파일 경로 완성</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>              <span class="c1">// 동적 콘텐츠임을 반환</span>
  <span class="p">}</span>
  <span class="cm">/*어떤 친구가 웹서버에 와서 무언가를 요청했어.
    •	요청 주소에 "cgi-bin"이 없으면 "파일 보여달라"는 거고,
    •	있으면 "계산 좀 해줘"라는 뜻이야.

  그래서 서버는 이렇게 판단해:
    •	"정적이면, 파일 경로만 만들어주고"
    •	"동적이면, 실행파일이랑 인자도 준비해!"*/</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">serve_static</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">int</span> <span class="n">filesize</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// 정적인 파일(HTML, 이미지 등)을 클라이언트에게 보내는 핵심 함수</span>
  <span class="cm">/*•	fd: 클라이언트와 연결된 소켓
    •	filename: 클라이언트가 요청한 파일 이름
    •	filesize: 파일 크기 (이미 stat으로 구했음)  */</span>

  <span class="c1">// 변수 선언</span>
  <span class="kt">int</span> <span class="n">srcfd</span><span class="p">;</span>                                  <span class="c1">// 파일 디스크립터</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">srcp</span><span class="p">,</span> <span class="n">filetype</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXBUF</span><span class="p">];</span> <span class="c1">// srcp:메모리에 매핑된 파일 주소</span>
  <span class="c1">// filetype : MIME 타입 저장할 버퍼 , buf : 응답 헤더 저장용</span>

  <span class="n">get_filetype</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">filetype</span><span class="p">);</span> <span class="c1">// MIME 타입 결정</span>
  <span class="c1">// •	filetype에 따라 브라우저가 어떻게 해석할지 결정됨 (text/html, image/jpeg 등)</span>

  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"HTTP/1.0 200 OK</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"Server: Tiny Web Server</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"Connection: close</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"Content-length: %d</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">filesize</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"Content-type: %s</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">filetype</span><span class="p">);</span>
  <span class="c1">//	마지막 줄에 빈 줄 \r\n\r\n은 본문 시작을 알리는 신호</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span> <span class="c1">// 클라이언트로 헤더 전송</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">"Response headers:</span><span class="se">\n</span><span class="s">%s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

  <span class="n">srcfd</span> <span class="o">=</span> <span class="n">Open</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>                        <span class="c1">// 파일 열기</span>
  <span class="n">srcp</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="n">filesize</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">srcp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Close</span><span class="p">(</span><span class="n">srcfd</span><span class="p">);</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error: malloc failed for file %s (size: %d)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">filesize</span><span class="p">);</span>

      <span class="c1">// 클라이언트에 HTTP 500 오류 응답 전송</span>
      <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"HTTP/1.0 500 Internal Server Error</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"Content-type: text/html</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span> <span class="s">"&lt;html&gt;&lt;body&gt;&lt;p&gt;Server error: memory allocation failed.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
      <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">//srcp = Mmap(0, filesize, PROT_READ, MAP_PRIVATE, srcfd, 0); // 파일을 메모리에 매핑</span>

  <span class="n">Rio_readn</span><span class="p">(</span><span class="n">srcfd</span><span class="p">,</span><span class="n">srcp</span><span class="p">,</span><span class="n">filesize</span><span class="p">);</span>
  <span class="c1">// Mmap : 파일을 메모리에 통째로 올림(성능 좋고 코드 간결함)</span>
  <span class="n">Close</span><span class="p">(</span><span class="n">srcfd</span><span class="p">);</span> <span class="c1">// 파일 디스크립터는 닫아도 메모리엔 살아있음</span>

  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">srcp</span><span class="p">,</span> <span class="n">filesize</span><span class="p">);</span> <span class="c1">// 파일 내용을 클라이언트로 전송</span>
  <span class="n">free</span><span class="p">(</span><span class="n">srcp</span><span class="p">);</span>
  <span class="c1">//Munmap(srcp, filesize);         // 메모리 해제, 매핑 해제</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">get_filetype</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filetype</span><span class="p">)</span>
<span class="c1">//  •	확장자를 보고 MIME 타입 결정</span>
<span class="c1">//  •	브라우저가 어떻게 렌더링할지를 결정하는 중요한 역할</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".html"</span><span class="p">))</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"text/html"</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".gif"</span><span class="p">))</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"image/gif"</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".mpg"</span><span class="p">))</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"video/mp4"</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".png"</span><span class="p">))</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"image/png"</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".jpg"</span><span class="p">))</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"image/jpeg"</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"text/plain"</span><span class="p">);</span>
<span class="p">}</span>
<span class="kt">void</span> <span class="nf">serve_dynamic</span><span class="p">(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filename</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">cgiargs</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">//  •	fd: 클라이언트와 연결된 소켓</span>
  <span class="c1">//  •	filename: 실행할 CGI 프로그램 경로 (예: ./cgi-bin/adder)</span>
  <span class="c1">//  •	cgiargs: CGI 프로그램에 넘겨줄 인자 (예: x=1&amp;y=2)</span>

  <span class="c1">// 버퍼와 exec 인자 준비</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="o">*</span><span class="n">emptylist</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="nb">NULL</span><span class="p">};</span>
  <span class="c1">// buf : HTTP 헤더를 담을 임시 버퍼 | emptylist:execve()함수에서 사용할 프로그램 인자 리스트(여기선없대)</span>

  <span class="c1">// HTTP 응답 헤더 전송</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"HTTP/1.0 200 OK</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
  <span class="c1">// CGI 프로그램을 실행하기 전에 최소한의 응답 헤더를 먼저 전송</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Server: Tiny Web Server</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span>
  <span class="c1">// 이후에 실제 프로그램의 출력 stdout이 이어짐</span>

  <span class="c1">// 자식 프로세스 생성 후 CGI 실행</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Fork</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">){</span>  <span class="c1">// 자식 프로세스 | fork()로 새 프로세스를 생성</span>
    <span class="n">setenv</span><span class="p">(</span><span class="s">"QUERY_STRING"</span><span class="p">,</span> <span class="n">cgiargs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>   <span class="c1">// 환경 변수 설정 (인자 전달) | adder.c에서 사용하는 getenv("QUERY_STRING")가능하게 설정</span>
    <span class="n">Dup2</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">STDOUT_FILENO</span><span class="p">);</span>              <span class="c1">// Dup2()를 통해 stdout을 클라이언트 소켓으로 리다이렉션</span>
    <span class="n">Execve</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">emptylist</span><span class="p">,</span> <span class="n">environ</span><span class="p">);</span> <span class="c1">// Execve()로 CGI 실행 (출력은 fd로 감) , 실행되면 그 아래 코드는 실행 안됨</span>
  <span class="p">}</span>
  <span class="n">Wait</span><span class="p">(</span><span class="nb">NULL</span><span class="p">);</span> <span class="c1">//부모 프로세스는 자식이 끝날 때 까지 기다림(좀비 프로세스 방지)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;</span>
<span class="nt">&lt;head&gt;&lt;title&gt;</span>test<span class="nt">&lt;/title&gt;&lt;/head&gt;</span>
<span class="nt">&lt;body&gt;</span> 
<span class="nt">&lt;img</span> <span class="na">align=</span><span class="s">"middle"</span> <span class="na">src=</span><span class="s">"godzilla.gif"</span><span class="nt">&gt;</span>
<span class="nt">&lt;br&gt;</span>
<span class="nt">&lt;br&gt;</span>
Dave O'Hallaron
<span class="nt">&lt;/body&gt;</span>
<span class="nt">&lt;/html&gt;</span>

</code></pre></div></div>

<p>이렇게 구현하라고 책에 나와 있었고 여기에 동영상 파일을 넣으라는 과제가 있어서 진행했다. 바뀐 부분은 아래와 같다.</p>

<p>tiny.c 파일에 아래와 같은 코드를 추가하고</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">strcpy</span><span class="p">(</span><span class="n">filetype</span><span class="p">,</span> <span class="s">"video/mp4"</span><span class="p">);</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strstr</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="s">".png"</span><span class="p">))</span>
</code></pre></div></div>

<p>html 파일에는 아래와 같은 코드와 videoplayback.mp4파일을 디렉토리에 저장했다.</p>
<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;video</span> <span class="na">width=</span><span class="s">"320"</span> <span class="na">height=</span><span class="s">"240"</span> <span class="na">controls</span><span class="nt">&gt;</span>
  <span class="nt">&lt;source</span> <span class="na">src=</span><span class="s">"videoplayback.mp4"</span> <span class="na">type=</span><span class="s">"video/mp4"</span><span class="nt">&gt;</span>
</code></pre></div></div>

<h2 id="소형-웹-서버tiny-web-server--프록시-서버">소형 웹 서버(Tiny web server) + 프록시 서버</h2>

<p>Tiny 서버 구현 후 프록시 서버도 구현하라는 과제가 주어졌어서, 프록시에 대한 개념을 먼저 알아보았다.</p>

<h3 id="웹-프록시란">웹 프록시란?</h3>

<p>웹 브라우저와 웹 서버 사이에 중간자 역할을 하는 프로그램이다. 브라우저는 직접 서버에 요청하지 않고, 프록시 서버에 요청을 보낸다. 프록시는 그 요청을 웹 서버로 전달하고, 받은 응답을 다시 브라우저에게 돌려주며 마무리.</p>

<h2 id="프록시-서버">프록시 서버</h2>

<p>프록시 서버에서 사용할 코드는 아래와 같이 나왔다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"csapp.h"</span><span class="cp">
</span>
<span class="cp">#define MAX_CACHE_SIZE 1049000
#define MAX_OBJECT_SIZE 102400
</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">user_agent_hdr</span> <span class="o">=</span>
    <span class="s">"User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 "</span>
    <span class="s">"Firefox/10.0.3</span><span class="se">\r\n</span><span class="s">"</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">connfd</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">build_http_header</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">http_header</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
    <span class="n">socklen_t</span> <span class="n">clientlen</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">clientaddr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">port</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">host</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Open_listenfd</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clientlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">);</span>
        <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clientlen</span><span class="p">);</span>
        <span class="n">Getnameinfo</span><span class="p">((</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="n">clientlen</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Accepted connection from (%s, %s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
        <span class="n">doit</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
        <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">connfd</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">method</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">uri</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">version</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">hostname</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">port</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
    <span class="kt">char</span> <span class="n">http_header</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
    <span class="n">rio_t</span> <span class="n">rio_client</span><span class="p">,</span> <span class="n">rio_server</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">serverfd</span><span class="p">;</span>

    <span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_client</span><span class="p">,</span> <span class="n">connfd</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"%s %s %s"</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

    <span class="c1">// URI 앞 '/' 제거 ("/http://..." → "http://...")</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">uri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span>
        <span class="n">memmove</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">uri</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">uri</span><span class="p">));</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Received URI: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">"GET"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Proxy does not implement the method %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">method</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">parse_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"URI parsing failed: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">build_http_header</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
    <span class="n">serverfd</span> <span class="o">=</span> <span class="n">Open_clientfd</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">serverfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Connection to server %s:%s failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_server</span><span class="p">,</span> <span class="n">serverfd</span><span class="p">);</span>
    <span class="n">Rio_writen</span><span class="p">(</span><span class="n">serverfd</span><span class="p">,</span> <span class="n">http_header</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">http_header</span><span class="p">));</span>

    <span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_server</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Rio_writen</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Close</span><span class="p">(</span><span class="n">serverfd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">hostbegin</span><span class="p">,</span> <span class="o">*</span><span class="n">pathbegin</span><span class="p">,</span> <span class="o">*</span><span class="n">portpos</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="s">"http://"</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="n">hostbegin</span> <span class="o">=</span> <span class="n">uri</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>
  <span class="n">pathbegin</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">hostbegin</span><span class="p">,</span> <span class="sc">'/'</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">pathbegin</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pathbegin</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"/"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 이제 host:port만 분리할 수 있게 별도로 복사해놓자</span>
  <span class="kt">char</span> <span class="n">hostcopy</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pathbegin</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">pathbegin</span> <span class="o">-</span> <span class="n">hostbegin</span><span class="p">;</span>
      <span class="n">strncpy</span><span class="p">(</span><span class="n">hostcopy</span><span class="p">,</span> <span class="n">hostbegin</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
      <span class="n">hostcopy</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">hostcopy</span><span class="p">,</span> <span class="n">hostbegin</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">portpos</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">hostcopy</span><span class="p">,</span> <span class="sc">':'</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">portpos</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">portpos</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">hostcopy</span><span class="p">);</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">portpos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">hostcopy</span><span class="p">);</span>
      <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="s">"80"</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">build_http_header</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">http_header</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"GET %s HTTP/1.0</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Host: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="n">user_agent_hdr</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"Connection: close</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"Proxy-Connection: close</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이거는 시행착오를 겪으며 나온 코드이다. 이거를 구현하기 위해서 AWS EC2 instance 2개를 만들었고, 하나는 tiny server 그리고 하나는 proxy server로 만들었다. 내 컴퓨터로는 client로 사용을 했다. 아래 사진으로 proxy server와 main server가 연결된것을 확인할 수 있다.</p>

<p><img src="/assets/img/blog/computerscience/proxytinyconnected.png" alt="프록시 서버와 메인 서버 연결" /></p>

<p>다만 아쉬웠던 점이 하나 있었다. 이렇게 구현을 하면 아래 사진과 같이 메인서버의 주소를 URI로써 넣어줘야 했다.</p>

<p><img src="/assets/img/blog/computerscience/mainserveruri.png" alt="메인 서버 URI" /></p>

<p>이렇게 되면, 프록시로써의 기능이 없는거 아닌가? 라는 생각을 했고 그걸 바꾸고 싶었다. 그래서 doit함수에서 아래부분을,</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">parse_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"URI parsing failed: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>아래와 같이 바꾸었다. 이미 AWS EC2 instance를 만들었기 때문에, IP 주소에 대한 정보는 있는 상태였다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="c1">// 고정된 최종 서버 정보</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="s">"15.164.219.65"</span><span class="p">);</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="s">"8080"</span><span class="p">);</span>
  <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>  <span class="c1">// 예: "/home.html", "/godzilla.jpg"</span>
</code></pre></div></div>

<p>이렇게 진행을 해서 아래 사진과 같이 프록시로써의 기능을 충분히 하는것을 확인하였다.</p>

<p><img src="/assets/img/blog/computerscience/afterdoitrevision.png" alt="doit함수 수정 후" /></p>

<h2 id="프록시-서버-쓰레딩과-캐싱-기능-추가">프록시 서버 쓰레딩과 캐싱 기능 추가</h2>

<p>팀원들과 같이 쓰레딩과 캐싱 기능도 추가하였는데, 완성 코드는 아래와 같다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"csapp.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;limits.h&gt;</span><span class="c1">  /* ULONG_MAX 정의를 위해 추가 */</span><span class="cp">
</span>
<span class="cp">#define MAX_CACHE_SIZE 1049000
#define MAX_OBJECT_SIZE 102400
</span>
<span class="cm">/* 캐시 구조체 및 관련 데이터 정의 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">;</span>          <span class="cm">/* 캐시된 URL */</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">content</span><span class="p">;</span>      <span class="cm">/* 캐시된 웹 객체 내용 */</span>
    <span class="kt">size_t</span> <span class="n">content_size</span><span class="p">;</span> <span class="cm">/* 객체 크기 */</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">timestamp</span><span class="p">;</span> <span class="cm">/* LRU를 위한 타임스탬프 */</span>
    <span class="kt">int</span> <span class="n">is_valid</span><span class="p">;</span>       <span class="cm">/* 유효한 캐시 항목인지 여부 */</span>
    <span class="kt">int</span> <span class="n">readers</span><span class="p">;</span>        <span class="cm">/* 현재 읽고 있는 스레드 수 */</span>
    <span class="n">pthread_rwlock_t</span> <span class="n">rwlock</span><span class="p">;</span> <span class="cm">/* 읽기/쓰기 락 */</span>
<span class="p">}</span> <span class="n">cache_entry_t</span><span class="p">;</span>

<span class="cm">/* 캐시 구조체 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">cache_entry_t</span> <span class="o">*</span><span class="n">entries</span><span class="p">;</span> <span class="cm">/* 캐시 항목 배열 */</span>
    <span class="kt">int</span> <span class="n">num_entries</span><span class="p">;</span>       <span class="cm">/* 총 항목 수 */</span>
    <span class="kt">int</span> <span class="n">max_entries</span><span class="p">;</span>       <span class="cm">/* 최대 허용 항목 수 */</span>
    <span class="kt">size_t</span> <span class="n">current_size</span><span class="p">;</span>   <span class="cm">/* 현재 캐시 크기 (바이트) */</span>
    <span class="n">pthread_mutex_t</span> <span class="n">mutex</span><span class="p">;</span> <span class="cm">/* 캐시 전체 락 */</span>
<span class="p">}</span> <span class="n">cache_t</span><span class="p">;</span>

<span class="cm">/* 전역 캐시 변수 */</span>
<span class="n">cache_t</span> <span class="n">cache</span><span class="p">;</span>

<span class="cm">/* 스레드 함수 인자를 위한 구조체 정의 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">connfd</span><span class="p">;</span>
<span class="p">}</span> <span class="n">thread_args</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">user_agent_hdr</span> <span class="o">=</span>
    <span class="s">"User-Agent: Mozilla/5.0 (X11; Linux x86_64; rv:10.0.3) Gecko/20120305 "</span>
    <span class="s">"Firefox/10.0.3</span><span class="se">\r\n</span><span class="s">"</span><span class="p">;</span>

<span class="cm">/* 함수 프로토타입 */</span>
<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">connfd</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">build_http_header</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">http_header</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">);</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vargp</span><span class="p">);</span>

<span class="cm">/* 캐시 관련 함수 프로토타입 */</span>
<span class="kt">void</span> <span class="nf">cache_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">max_entries</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">cache_free</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">cache_entry_t</span> <span class="o">*</span><span class="nf">cache_find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">cache_add</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">content</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">content_size</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">cache_evict_lru</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">required_size</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_timestamp</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">listenfd</span><span class="p">,</span> <span class="n">connfd</span><span class="p">;</span>
    <span class="n">socklen_t</span> <span class="n">clientlen</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">clientaddr</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">port</span><span class="p">[</span><span class="mi">10</span><span class="p">],</span> <span class="n">host</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
    <span class="n">pthread_t</span> <span class="n">tid</span><span class="p">;</span>
    <span class="n">thread_args</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">argc</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Usage: %s &lt;port&gt;</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// SIGPIPE 신호 무시 설정 (연결이 끊어진 소켓에 쓰기 시도할 때 발생)</span>
    <span class="n">Signal</span><span class="p">(</span><span class="n">SIGPIPE</span><span class="p">,</span> <span class="n">SIG_IGN</span><span class="p">);</span>
    
    <span class="c1">// 캐시 초기화 (MAX_CACHE_SIZE / MAX_OBJECT_SIZE 객체의 10배)</span>
    <span class="n">cache_init</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Cache initialized with max size %d bytes</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">MAX_CACHE_SIZE</span><span class="p">);</span>

    <span class="n">listenfd</span> <span class="o">=</span> <span class="n">Open_listenfd</span><span class="p">(</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">clientlen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">clientaddr</span><span class="p">);</span>
        <span class="n">connfd</span> <span class="o">=</span> <span class="n">Accept</span><span class="p">(</span><span class="n">listenfd</span><span class="p">,</span> <span class="p">(</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clientlen</span><span class="p">);</span>
        <span class="n">Getnameinfo</span><span class="p">((</span><span class="n">SA</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">clientaddr</span><span class="p">,</span> <span class="n">clientlen</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Accepted connection from (%s, %s)</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">host</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
        
        <span class="c1">// 스레드 인자 구조체 할당</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">thread_args</span> <span class="o">*</span><span class="p">)</span><span class="n">Malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">thread_args</span><span class="p">));</span>
        <span class="n">args</span><span class="o">-&gt;</span><span class="n">connfd</span> <span class="o">=</span> <span class="n">connfd</span><span class="p">;</span>
        
        <span class="c1">// 새 스레드 생성하여 클라이언트 요청 처리</span>
        <span class="n">Pthread_create</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
        <span class="c1">// 메인 스레드는 바로 다음 연결을 기다림 (connfd를 닫지 않음)</span>
    <span class="p">}</span>
    
    <span class="c1">// 여기에 도달하지 않지만 안전을 위해 추가</span>
    <span class="n">cache_free</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">doit</span><span class="p">(</span><span class="kt">int</span> <span class="n">connfd</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">method</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">uri</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">version</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">hostname</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">path</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">port</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
  <span class="n">rio_t</span> <span class="n">rio_client</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">serverfd</span><span class="p">;</span>

  <span class="c1">// 클라이언트 요청 라인 읽기</span>
  <span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_client</span><span class="p">,</span> <span class="n">connfd</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Request line: %s"</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

  <span class="c1">// 요청 라인 파싱</span>
  <span class="n">sscanf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"%s %s %s"</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">uri</span><span class="p">,</span> <span class="n">version</span><span class="p">);</span>

  <span class="c1">// GET 요청만 처리</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">strcasecmp</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="s">"GET"</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Proxy does not implement the method %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">method</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// URI 파싱하여 hostname, path, port 추출</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">parse_uri</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">port</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"URI parsing failed: %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// 전체 URL을 캐시 키로 사용</span>
  <span class="kt">char</span> <span class="n">url_key</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">url_key</span><span class="p">,</span> <span class="s">"http://%s:%s%s"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
  
  <span class="c1">// 캐시에서 URL 검색</span>
  <span class="n">cache_entry_t</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">cache_find</span><span class="p">(</span><span class="n">url_key</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 캐시 히트: 캐시된 내용을 클라이언트에게 전송</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Cache hit for %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">url_key</span><span class="p">);</span>
      <span class="n">Rio_writen</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">content</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">content_size</span><span class="p">);</span>
      <span class="n">cache_read_complete</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// 캐시 미스: 서버에 요청</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">"Cache miss for %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">url_key</span><span class="p">);</span>
  
  <span class="c1">// 서버 연결</span>
  <span class="n">serverfd</span> <span class="o">=</span> <span class="n">Open_clientfd</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">serverfd</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Connection to server %s:%s failed.</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// 서버에 보낼 HTTP 요청 헤더 작성</span>
  <span class="kt">char</span> <span class="n">request_hdrs</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">host_hdr</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">],</span> <span class="n">other_hdrs</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="s">"GET %s HTTP/1.0</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
  
  <span class="c1">// 클라이언트 헤더 읽기 및 필요한 헤더 수정 또는 추가</span>
  <span class="kt">int</span> <span class="n">is_host_hdr_seen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">other_hdrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
  
  <span class="k">while</span> <span class="p">(</span><span class="n">Rio_readlineb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_client</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 헤더의 끝 확인 (빈 줄)</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
      
      <span class="c1">// Host 헤더 확인</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Host:"</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">is_host_hdr_seen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">strcpy</span><span class="p">(</span><span class="n">host_hdr</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="c1">// Connection 또는 Proxy-Connection 헤더는 건너뜀</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Connection:"</span><span class="p">,</span> <span class="mi">11</span><span class="p">)</span> <span class="o">||</span> 
               <span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Proxy-Connection:"</span><span class="p">,</span> <span class="mi">17</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// User-Agent 헤더는 건너뜀 (나중에 추가됨)</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"User-Agent:"</span><span class="p">,</span> <span class="mi">11</span><span class="p">))</span> <span class="p">{</span>
          <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// 그 외 헤더는 그대로 전달</span>
      <span class="k">else</span> <span class="p">{</span>
          <span class="n">strcat</span><span class="p">(</span><span class="n">other_hdrs</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
      <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// HTTP 요청 헤더 완성</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_host_hdr_seen</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">sprintf</span><span class="p">(</span><span class="n">host_hdr</span><span class="p">,</span> <span class="s">"Host: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="c1">// 최종 HTTP 요청 헤더 조합</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="n">host_hdr</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="n">user_agent_hdr</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="s">"Connection: close</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="s">"Proxy-Connection: close</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="n">other_hdrs</span><span class="p">);</span>
  <span class="n">strcat</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">,</span> <span class="s">"</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>  <span class="c1">// 헤더의 끝</span>
  
  <span class="n">printf</span><span class="p">(</span><span class="s">"Forwarding request to server %s:%s</span><span class="se">\n</span><span class="s">%s"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">port</span><span class="p">,</span> <span class="n">request_hdrs</span><span class="p">);</span>
  
  <span class="c1">// 서버에 요청 전송</span>
  <span class="n">rio_t</span> <span class="n">rio_server</span><span class="p">;</span>
  <span class="n">Rio_readinitb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_server</span><span class="p">,</span> <span class="n">serverfd</span><span class="p">);</span>
  <span class="n">Rio_writen</span><span class="p">(</span><span class="n">serverfd</span><span class="p">,</span> <span class="n">request_hdrs</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">request_hdrs</span><span class="p">));</span>
  
  <span class="c1">// 서버로부터 응답을 받아 클라이언트에게 전달하고 캐싱</span>
  <span class="kt">size_t</span> <span class="n">n</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">cache_buf</span><span class="p">[</span><span class="n">MAX_OBJECT_SIZE</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">cacheable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>  <span class="c1">// 객체가 캐시 가능한지 여부</span>
  
  <span class="c1">// 응답을 버퍼 단위로 읽어 전달</span>
  <span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">Rio_readnb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rio_server</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">MAXLINE</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 클라이언트에게 전송</span>
      <span class="n">Rio_writen</span><span class="p">(</span><span class="n">connfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
      
      <span class="c1">// 캐시 가능한 크기이면 응답을 캐시 버퍼에 저장</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cacheable</span> <span class="o">&amp;&amp;</span> <span class="n">total_size</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">MAX_OBJECT_SIZE</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">memcpy</span><span class="p">(</span><span class="n">cache_buf</span> <span class="o">+</span> <span class="n">total_size</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
          <span class="n">total_size</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">total_size</span> <span class="o">+</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">MAX_OBJECT_SIZE</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">cacheable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// 최대 객체 크기를 초과하여 캐시 불가능</span>
      <span class="p">}</span>
  <span class="p">}</span>
  
  <span class="c1">// 모든 응답을 받았으면 캐시에 저장</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">cacheable</span> <span class="o">&amp;&amp;</span> <span class="n">total_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cache_add</span><span class="p">(</span><span class="n">url_key</span><span class="p">,</span> <span class="n">cache_buf</span><span class="p">,</span> <span class="n">total_size</span><span class="p">);</span>
      <span class="n">printf</span><span class="p">(</span><span class="s">"Cached %zu bytes for %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">total_size</span><span class="p">,</span> <span class="n">url_key</span><span class="p">);</span>
  <span class="p">}</span>
  
  <span class="n">Close</span><span class="p">(</span><span class="n">serverfd</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">parse_uri</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">uri</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">port</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">hostbegin</span><span class="p">,</span> <span class="o">*</span><span class="n">hostend</span><span class="p">,</span> <span class="o">*</span><span class="n">pathbegin</span><span class="p">;</span>
    
    <span class="c1">// URI에 http:// 접두사가 없는 경우 (driver.sh는 완전한 URL을 요구함)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strncasecmp</span><span class="p">(</span><span class="n">uri</span><span class="p">,</span> <span class="s">"http://"</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 이미 경로만 있는 경우 (예: /home.html)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">uri</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'/'</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// localhost로 간주하고 기본 경로 사용</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="s">"localhost"</span><span class="p">);</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>
            <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="s">"80"</span><span class="p">);</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">"Error: Invalid URI format (no http://): %s</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">uri</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// http:// 이후의 호스트 시작 위치</span>
    <span class="n">hostbegin</span> <span class="o">=</span> <span class="n">uri</span> <span class="o">+</span> <span class="mi">7</span><span class="p">;</span>
    
    <span class="c1">// 경로 부분 찾기 (첫 번째 '/')</span>
    <span class="n">pathbegin</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">hostbegin</span><span class="p">,</span> <span class="sc">'/'</span><span class="p">);</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">pathbegin</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 호스트 부분의 마지막 위치</span>
        <span class="n">hostend</span> <span class="o">=</span> <span class="n">pathbegin</span><span class="p">;</span>
        <span class="c1">// 경로 복사</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">pathbegin</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 경로가 없으면 루트 경로로 설정</span>
        <span class="n">hostend</span> <span class="o">=</span> <span class="n">hostbegin</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">hostbegin</span><span class="p">);</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">"/"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 임시 호스트 문자열 생성 및 복사</span>
    <span class="kt">char</span> <span class="n">hostcopy</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>
    <span class="n">strncpy</span><span class="p">(</span><span class="n">hostcopy</span><span class="p">,</span> <span class="n">hostbegin</span><span class="p">,</span> <span class="n">hostend</span> <span class="o">-</span> <span class="n">hostbegin</span><span class="p">);</span>
    <span class="n">hostcopy</span><span class="p">[</span><span class="n">hostend</span> <span class="o">-</span> <span class="n">hostbegin</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>

    <span class="c1">// 호스트에서 포트 번호 분리</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">portPos</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">hostcopy</span><span class="p">,</span> <span class="sc">':'</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">portPos</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">portPos</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">hostcopy</span><span class="p">);</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">portPos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">hostname</span><span class="p">,</span> <span class="n">hostcopy</span><span class="p">);</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="s">"80"</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"Parsed URI - Host: '%s', Path: '%s', Port: '%s'</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">port</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">build_http_header</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">http_header</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MAXLINE</span><span class="p">];</span>

    <span class="n">sprintf</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"GET %s HTTP/1.0</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
    <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">"Host: %s</span><span class="se">\r\n</span><span class="s">"</span><span class="p">,</span> <span class="n">hostname</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="n">user_agent_hdr</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"Connection: close</span><span class="se">\r\n</span><span class="s">"</span><span class="p">);</span>
    <span class="n">strcat</span><span class="p">(</span><span class="n">http_header</span><span class="p">,</span> <span class="s">"Proxy-Connection: close</span><span class="se">\r\n\r\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 스레드 함수 구현 */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">vargp</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">thread_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="p">(</span><span class="n">thread_args</span> <span class="o">*</span><span class="p">)</span><span class="n">vargp</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">connfd</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">connfd</span><span class="p">;</span>
    
    <span class="c1">// 스레드를 detach 상태로 만들어 자원을 자동으로 반환하도록 함</span>
    <span class="n">Pthread_detach</span><span class="p">(</span><span class="n">pthread_self</span><span class="p">());</span>
    
    <span class="c1">// 메모리 누수 방지를 위해 할당된 인자 구조체 해제</span>
    <span class="n">Free</span><span class="p">(</span><span class="n">vargp</span><span class="p">);</span>
    
    <span class="c1">// 클라이언트 요청 처리</span>
    <span class="n">doit</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
    
    <span class="c1">// 연결 종료</span>
    <span class="n">Close</span><span class="p">(</span><span class="n">connfd</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 캐시 초기화 함수 */</span>
<span class="kt">void</span> <span class="nf">cache_init</span><span class="p">(</span><span class="kt">int</span> <span class="n">max_entries</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span> <span class="o">=</span> <span class="p">(</span><span class="n">cache_entry_t</span> <span class="o">*</span><span class="p">)</span><span class="n">Calloc</span><span class="p">(</span><span class="n">max_entries</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cache_entry_t</span><span class="p">));</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">num_entries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span> <span class="o">=</span> <span class="n">max_entries</span><span class="p">;</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">current_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">pthread_mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">url</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">content</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">content_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">readers</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">pthread_rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rwlock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 캐시 해제 함수 */</span>
<span class="kt">void</span> <span class="nf">cache_free</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_valid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">Free</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">url</span><span class="p">);</span>
            <span class="n">Free</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">content</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">pthread_rwlock_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">Free</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="n">pthread_mutex_destroy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* 현재 시간 반환 */</span>
<span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_timestamp</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
    <span class="n">gettimeofday</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="mi">1000000</span> <span class="o">+</span> <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 캐시에서 URL에 해당하는 항목 찾기 */</span>
<span class="n">cache_entry_t</span> <span class="o">*</span><span class="nf">cache_find</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_valid</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">url</span><span class="p">,</span> <span class="n">url</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// 읽기 락 획득</span>
            <span class="n">pthread_rwlock_rdlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
            <span class="c1">// 타임스탬프 갱신</span>
            <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">get_timestamp</span><span class="p">();</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 캐시 항목 읽기 완료 */</span>
<span class="kt">void</span> <span class="nf">cache_read_complete</span><span class="p">(</span><span class="n">cache_entry_t</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rwlock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* LRU 정책에 따라 캐시에서 항목 제거 */</span>
<span class="kt">void</span> <span class="nf">cache_evict_lru</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">required_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">min_timestamp</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">lru_index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 가장 오래 사용되지 않은 항목 찾기</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_valid</span> <span class="o">&amp;&amp;</span> <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">&lt;</span> <span class="n">min_timestamp</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">min_timestamp</span> <span class="o">=</span> <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">timestamp</span><span class="p">;</span>
            <span class="n">lru_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">lru_index</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// 쓰기 락 획득</span>
        <span class="n">pthread_rwlock_wrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
        
        <span class="c1">// 해당 항목의 메모리 해제</span>
        <span class="n">Free</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">url</span><span class="p">);</span>
        <span class="n">Free</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">content</span><span class="p">);</span>
        
        <span class="c1">// 캐시 항목 무효화</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">url</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">content</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">is_valid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        
        <span class="c1">// 캐시 크기 갱신</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">current_size</span> <span class="o">-=</span> <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">content_size</span><span class="p">;</span>
        <span class="n">cache</span><span class="p">.</span><span class="n">num_entries</span><span class="o">--</span><span class="p">;</span>
        
        <span class="c1">// 쓰기 락 해제</span>
        <span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">lru_index</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* 캐시에 새로운 항목 추가 */</span>
<span class="kt">void</span> <span class="nf">cache_add</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">url</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">content</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">content_size</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">content_size</span> <span class="o">&gt;</span> <span class="n">MAX_OBJECT_SIZE</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span><span class="p">;</span> <span class="c1">// 최대 객체 크기 초과하면 캐시하지 않음</span>
    <span class="p">}</span>

    <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>

    <span class="c1">// 필요한 경우 공간 확보</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">current_size</span> <span class="o">+</span> <span class="n">content_size</span> <span class="o">&gt;</span> <span class="n">MAX_CACHE_SIZE</span> <span class="o">||</span> <span class="n">cache</span><span class="p">.</span><span class="n">num_entries</span> <span class="o">&gt;=</span> <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">cache_evict_lru</span><span class="p">(</span><span class="n">content_size</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 빈 슬롯 찾기</span>
    <span class="kt">int</span> <span class="n">empty_slot</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="p">.</span><span class="n">max_entries</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">is_valid</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">empty_slot</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">empty_slot</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span> <span class="c1">// 빈 슬롯이 없음</span>
    <span class="p">}</span>

    <span class="c1">// 쓰기 락 획득</span>
    <span class="n">pthread_rwlock_wrlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
    
    <span class="c1">// 새 항목 초기화</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">url</span> <span class="o">=</span> <span class="n">strdup</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">content</span> <span class="o">=</span> <span class="n">Malloc</span><span class="p">(</span><span class="n">content_size</span><span class="p">);</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">content</span><span class="p">,</span> <span class="n">content</span><span class="p">,</span> <span class="n">content_size</span><span class="p">);</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">content_size</span> <span class="o">=</span> <span class="n">content_size</span><span class="p">;</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">get_timestamp</span><span class="p">();</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">is_valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    
    <span class="c1">// 캐시 상태 갱신</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">current_size</span> <span class="o">+=</span> <span class="n">content_size</span><span class="p">;</span>
    <span class="n">cache</span><span class="p">.</span><span class="n">num_entries</span><span class="o">++</span><span class="p">;</span>
    
    <span class="c1">// 쓰기 락 해제</span>
    <span class="n">pthread_rwlock_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">entries</span><span class="p">[</span><span class="n">empty_slot</span><span class="p">].</span><span class="n">rwlock</span><span class="p">);</span>
    <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[우리가 웹을 검색하고, 이메일 메시지를 보내고, 온라인 게임을 하는 등의 모든 경우 우리는 네트워크 응용을 사용한다]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">8주차 퀴즈</title><link href="/blog/algorithm/8th-week/" rel="alternate" type="text/html" title="8주차 퀴즈" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>/blog/algorithm/8th-week</id><content type="html" xml:base="/blog/algorithm/8th-week/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#8주차-퀴즈" id="markdown-toc-8주차-퀴즈">8주차 퀴즈</a>    <ul>
      <li><a href="#1-http-get-요청과-post-요청의-가장-큰-차이점은-무엇이며-이것이-요청-헤더나-데이터-전송에-어떤-영향을-미칩니까-1점" id="markdown-toc-1-http-get-요청과-post-요청의-가장-큰-차이점은-무엇이며-이것이-요청-헤더나-데이터-전송에-어떤-영향을-미칩니까-1점">1. HTTP GET 요청과 POST 요청의 가장 큰 차이점은 무엇이며, 이것이 요청 헤더나 데이터 전송에 어떤 영향을 미칩니까? (1점)</a></li>
      <li><a href="#2-http-응답-코드-404의-의미는-무엇입니까-그리고-서버가-요청을-처리할-수-없을-때-반환하는-http-상태-코드는-무엇입니까-1점" id="markdown-toc-2-http-응답-코드-404의-의미는-무엇입니까-그리고-서버가-요청을-처리할-수-없을-때-반환하는-http-상태-코드는-무엇입니까-1점">2. HTTP 응답 코드 404의 의미는 무엇입니까? 그리고 서버가 요청을 처리할 수 없을 때 반환하는 HTTP 상태 코드는 무엇입니까? (1점)</a></li>
      <li><a href="#3-파일-디스크립터file-descriptor란-무엇인지-간단히-설명하고-unixlinux-시스템에서-표준-입출력에러의-파일-디스크립터-번호를-쓰세요-1점" id="markdown-toc-3-파일-디스크립터file-descriptor란-무엇인지-간단히-설명하고-unixlinux-시스템에서-표준-입출력에러의-파일-디스크립터-번호를-쓰세요-1점">3. 파일 디스크립터(File Descriptor)란 무엇인지 간단히 설명하고 UNIX/Linux 시스템에서 표준 입출력/에러의 파일 디스크립터 번호를 쓰세요. (1점)</a></li>
      <li><a href="#4-tcp에서의-3-way-handshake-절차를-설명하세요-1점" id="markdown-toc-4-tcp에서의-3-way-handshake-절차를-설명하세요-1점">4. TCP에서의 ‘3-way handshake’ 절차를 설명하세요. (1점)</a></li>
      <li><a href="#5-tcp와-udp에서-패킷-손실-시-대처-방법에는-어떤-차이가-있나요-1점" id="markdown-toc-5-tcp와-udp에서-패킷-손실-시-대처-방법에는-어떤-차이가-있나요-1점">5. TCP와 UDP에서 패킷 손실 시 대처 방법에는 어떤 차이가 있나요? (1점)</a>        <ul>
          <li><a href="#tcp" id="markdown-toc-tcp">TCP</a></li>
          <li><a href="#udp" id="markdown-toc-udp">UDP</a></li>
        </ul>
      </li>
      <li><a href="#6-다음-ansi-c-프로그램에서-출력되는-내용은-무엇인가요-1점" id="markdown-toc-6-다음-ansi-c-프로그램에서-출력되는-내용은-무엇인가요-1점">6. 다음 ANSI C 프로그램에서 출력되는 내용은 무엇인가요? (1점)</a></li>
    </ul>
  </li>
</ul>

<h2 id="8주차-퀴즈">8주차 퀴즈</h2>

<h3 id="1-http-get-요청과-post-요청의-가장-큰-차이점은-무엇이며-이것이-요청-헤더나-데이터-전송에-어떤-영향을-미칩니까-1점">1. HTTP GET 요청과 POST 요청의 가장 큰 차이점은 무엇이며, 이것이 요청 헤더나 데이터 전송에 어떤 영향을 미칩니까? (1점)</h3>

<p>GET 요청은 데이터를 URL의 일부(query string)로 전송하지만 POST 요청은 데이터를 요청 본문(body)에 포함합니다.
이 차이 때문에</p>

<p>1)  GET 요청의 URL 길이에는 브라우저나 서버에 따라 제한이 있습니다. 이로 인해 전송할 수 있는 데이터의 양이 제한됩니다.</p>

<p>2)  POST 요청은 ‘Content-Length’와 ‘Content-Type’ 같은 추가적인 헤더 정보를 필요로 합니다.</p>

<h3 id="2-http-응답-코드-404의-의미는-무엇입니까-그리고-서버가-요청을-처리할-수-없을-때-반환하는-http-상태-코드는-무엇입니까-1점">2. HTTP 응답 코드 404의 의미는 무엇입니까? 그리고 서버가 요청을 처리할 수 없을 때 반환하는 HTTP 상태 코드는 무엇입니까? (1점)</h3>

<p>HTTP 응답 코드 404는 “Not Found”를 의미합니다. 이 코드는 서버가 요청된 리소스를 찾을 수 없을 때 반환됩니다. 
서버가 요청을 처리할 수 없을 때 반환하는 HTTP 상태 코드는 500입니다. 이 코드는 “Internal Server Error”를 나타냅니다.</p>

<h3 id="3-파일-디스크립터file-descriptor란-무엇인지-간단히-설명하고-unixlinux-시스템에서-표준-입출력에러의-파일-디스크립터-번호를-쓰세요-1점">3. 파일 디스크립터(File Descriptor)란 무엇인지 간단히 설명하고 UNIX/Linux 시스템에서 표준 입출력/에러의 파일 디스크립터 번호를 쓰세요. (1점)</h3>

<p>파일 디스크립터는 운영 체제에서 파일이나 다른 입출력 리소스에 대한 접근을 추상화하는데 사용되는 정수입니다. 파일 디스크립터를 통해 운영 체제는 파일, 파이프, 소켓 등 다양한 입출력 리소스를 일관된 방식으로 관리할 수 있습니다. 예를 들어, 파일을 열면 운영 체제는 해당 파일을 가리키는 파일 디스크립터를 프로그램에 제공합니다. UNIX/Linux 시스템에서 표준 입력의 파일 디스크립터 번호는 0, 표준 출력은 1, 그리고 표준 에러는 2입니다.</p>

<h3 id="4-tcp에서의-3-way-handshake-절차를-설명하세요-1점">4. TCP에서의 ‘3-way handshake’ 절차를 설명하세요. (1점)</h3>

<p>TCP의 ‘3-way handshake’는 연결 설정 과정에서 사용되는 절차이다. 이 과정은 다음과 같이 세 단계로 이루어진다:</p>

<p>1)  클라이언트가 서버에 SYN(Synchronize) 패킷을 보내 연결 요청을 한다.</p>

<p>2)  서버는 SYN-ACK(Synchronize-Acknowledge) 패킷으로 응답하여 연결 요청을 받았음을 알리고, 자신도 연결 준비가 되었음을 나타낸다.</p>

<p>3)  클라이언트는 ACK(Acknowledge) 패킷을 서버에 보내 연결을 확정한다.</p>

<h3 id="5-tcp와-udp에서-패킷-손실-시-대처-방법에는-어떤-차이가-있나요-1점">5. TCP와 UDP에서 패킷 손실 시 대처 방법에는 어떤 차이가 있나요? (1점)</h3>

<h4 id="tcp">TCP</h4>

<ul>
  <li>
    <p>TCP는 패킷 손실이 발생하면 자동으로 재전송 시도</p>
  </li>
  <li>
    <p>수신자는 받은 패킷에 대해 확인 응답(ACK)을 보내고,</p>
  </li>
  <li>
    <p>송신자는 ACK를 받지 못한 패킷을 재전송</p>
  </li>
</ul>

<h4 id="udp">UDP</h4>

<ul>
  <li>
    <p>반면, UDP는 패킷 손실에 대해 자체적으로 대처하지 않음</p>
  </li>
  <li>
    <p>UDP는 확인 응답이나 재전송 기능이 없어, 패킷 손실이 발생하면 이를 어플리케이션 레벨에서 처리해야 함</p>
  </li>
</ul>

<h3 id="6-다음-ansi-c-프로그램에서-출력되는-내용은-무엇인가요-1점">6. 다음 ANSI C 프로그램에서 출력되는 내용은 무엇인가요? (1점)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="c1"> </span><span class="cp">
</span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span> 
<span class="p">{</span> 
   <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">};</span> 
   <span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> 
   <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">;</span> 
   <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span> 
   <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> 
   <span class="o">*</span><span class="p">(</span><span class="o">&amp;</span><span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span> 
   <span class="n">printf</span><span class="p">(</span><span class="s">"%d, %d, %d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">z</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span> 
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>출력값 : 10, 10, 14</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/Algorithm.png" /><media:content medium="image" url="/assets/img/blog/postimage/Algorithm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Datagram Socket과 Stream Socket</title><link href="/blog/computersystem/datagram-stream-socket/" rel="alternate" type="text/html" title="Datagram Socket과 Stream Socket" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>/blog/computersystem/datagram-stream-socket</id><content type="html" xml:base="/blog/computersystem/datagram-stream-socket/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#datagram-socket-udp-기반" id="markdown-toc-datagram-socket-udp-기반">Datagram Socket (UDP 기반)</a>    <ul>
      <li><a href="#datagram-socket-udp의-내부-동작" id="markdown-toc-datagram-socket-udp의-내부-동작">Datagram Socket (UDP)의 내부 동작</a></li>
    </ul>
  </li>
  <li><a href="#stream-socket-tcp-기반" id="markdown-toc-stream-socket-tcp-기반">Stream Socket (TCP 기반)</a>    <ul>
      <li><a href="#stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake" id="markdown-toc-stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake">Stream Socket (TCP)의 내부 동작 + TCP 연결 설정 : 3-way handshake</a></li>
    </ul>
  </li>
  <li><a href="#비교-요약" id="markdown-toc-비교-요약">비교 요약</a></li>
</ul>

<p>네트워크 통신 방식에 따라 소켓을 분류한 두 가지 종류 Datagram Socket과 Stream Socket을 알려줄게</p>

<h2 id="datagram-socket-udp-기반">Datagram Socket (UDP 기반)</h2>

<ul>
  <li>
    <p>기반 프로토콜 : UDP (User Datagram Protocol)</p>
  </li>
  <li>
    <p>연결 방식 : 비연결형 (Connectionless)</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p><strong>비연결형</strong> : 연결 없이 바로 데이터 전송</p>
      </li>
      <li>
        <p><strong>신뢰성 없음</strong> : 순서 보장 X, 재전송 X, 확인 응답 X</p>
      </li>
      <li>
        <p><strong>오버헤드 작음</strong> : 빠르고 단순</p>
      </li>
    </ul>
  </li>
  <li>
    <p>용도 예시 :</p>

    <ul>
      <li>
        <p>스트리밍 (비디오/오디오)</p>
      </li>
      <li>
        <p>실시간 게임</p>
      </li>
      <li>
        <p>DNS 요청</p>
      </li>
    </ul>
  </li>
</ul>

<p>예제 : C에서의 예시 (Datagram Socket)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// SOCK_DGRAM이 핵심</span>
</code></pre></div></div>

<h3 id="datagram-socket-udp의-내부-동작">Datagram Socket (UDP)의 내부 동작</h3>

<ul>
  <li>
    <p>Data를 전송하면, 해당 data는 Datagram(데이터그램)으로 만들어짐</p>
  </li>
  <li>
    <p>각 Datagram은 독립적으로 처리됨(순서/재전송 신경 안 씀)</p>
  </li>
  <li>
    <p>수신 측이 없어도 전송은 진행됨</p>
  </li>
</ul>

<blockquote>
  <p>전송 성공 여부는 알 수 없음</p>
</blockquote>

<p>예제 : Data 전송 예</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 송신자</span>
<span class="n">sendto</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

<span class="c1">// 수신자</span>
<span class="n">recvfrom</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFLEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fromlen</span><span class="p">);</span>
</code></pre></div></div>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">sendto</code>나 <code class="language-plaintext highlighter-rouge">recvfrom</code>에서 연결 상태를 유지하지 않고 주소를 직접 지정함</p>
</blockquote>

<h2 id="stream-socket-tcp-기반">Stream Socket (TCP 기반)</h2>

<ul>
  <li>
    <p>기반 프로토콜 : TCP (Transmission Control Protocol)</p>
  </li>
  <li>
    <p>연결 방식 : 연결형 (Connection-oriented)</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p><strong>연결지향형</strong> : 먼저 연결을 설정한 후 데이터를 주고받음, 통신 전에 연결(3-way handshake) 필요</p>
      </li>
      <li>
        <p><strong>신뢰성</strong> : 순서 보장, 오류 검출, 재전송</p>
      </li>
      <li>
        <p><strong>흐름 제어</strong> : 수신자가 감당할 수 있을 만큼만 전송</p>
      </li>
      <li>
        <p><strong>혼잡 제어</strong> : 네트워크 상황에 따라 전송 속도 조절</p>
      </li>
      <li>
        <p>속도는 느릴 수 있지만 신뢰성 높음</p>
      </li>
    </ul>
  </li>
  <li>
    <p>용도 예시 :</p>

    <ul>
      <li>
        <p>웹 서비스 (HTTP)</p>
      </li>
      <li>
        <p>이메일 (SMTP)</p>
      </li>
      <li>
        <p>파일 전송 (FTP)</p>
      </li>
    </ul>
  </li>
</ul>

<p>예제 : C에서의 예시 (Stream Socket)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// SOCK_STREAM이 핵심</span>
</code></pre></div></div>

<h3 id="stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake">Stream Socket (TCP)의 내부 동작 + TCP 연결 설정 : 3-way handshake</h3>

<p><strong>3way handshake</strong>는 양쪽 통신자가 연결을 동기화하고 준비됐는지 확인하는 과정</p>

<p><strong>과정 요약</strong></p>

<ol>
  <li>
    <p>client → server : <code class="language-plaintext highlighter-rouge">SYN</code> 플래그 세팅된 패킷 전송 (연결 요청)</p>
  </li>
  <li>
    <p>server → client : <code class="language-plaintext highlighter-rouge">SYN + ACK</code> 패킷 전송 (요청 수락 + 서버도 연결 요청)</p>
  </li>
  <li>
    <p>client → server : <code class="language-plaintext highlighter-rouge">ACK</code> 전송 (서버의 연결 수락)</p>
  </li>
</ol>

<blockquote>
  <p>이 과정을 거친 뒤 양쪽 모두 연결이 되었고, 데이터를 주고받을 수 있어</p>
</blockquote>

<p><strong>예시 흐름</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">송신자</th>
      <th style="text-align: center">수신자</th>
      <th style="text-align: center">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">SYN, seq = x</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">SYN + ACK, seq = y, ack = x+1</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">ACK, seq = x+1, ack = y+1</td>
    </tr>
  </tbody>
</table>

<p><strong>TCP 데이터 전송</strong></p>

<ol>
  <li>
    <p>데이터는 스트림(stream)으로 보내짐. 내부적으로 작은 단위로 나뉘어 전송됨.</p>
  </li>
  <li>
    <p>각 패킷은 시퀸스 번호(sequence number)를 가짐</p>
  </li>
  <li>
    <p>수신자는 받은 순서대로 조립하고, ACK로 확인 메시지 보냄</p>
  </li>
  <li>
    <p>손실되면 재전송함</p>
  </li>
</ol>

<p><strong>TCP 연결 종료 : 4-way handshake</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">전송</th>
      <th style="text-align: center">인자</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">A → B</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">FIN</code></td>
      <td style="text-align: center">A가 종료 요청</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">B → A</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">ACK</code></td>
      <td style="text-align: center">B가 확인</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">B → A</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">FIN</code></td>
      <td style="text-align: center">B도 종료 요청</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">A → B</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">ACK</code></td>
      <td style="text-align: center">A가 확인하고 종료</td>
    </tr>
  </tbody>
</table>

<h2 id="비교-요약">비교 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">Datagram Socket (UDP)</th>
      <th style="text-align: center">Stream Socket (TCP)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">연결 여부</td>
      <td style="text-align: center">비연결 (Connectionless)</td>
      <td style="text-align: center">연결 (Connection-oriented)</td>
    </tr>
    <tr>
      <td style="text-align: center">연결 과정</td>
      <td style="text-align: center">없음</td>
      <td style="text-align: center">3-way handshake 필요</td>
    </tr>
    <tr>
      <td style="text-align: center">오류 처리</td>
      <td style="text-align: center">없음</td>
      <td style="text-align: center">ACK + 재전송</td>
    </tr>
    <tr>
      <td style="text-align: center">신뢰성</td>
      <td style="text-align: center">낮음</td>
      <td style="text-align: center">높음</td>
    </tr>
    <tr>
      <td style="text-align: center">Data 순서 보장</td>
      <td style="text-align: center">안됨</td>
      <td style="text-align: center">됨(시퀸스 번호로 순서 보장)</td>
    </tr>
    <tr>
      <td style="text-align: center">속도</td>
      <td style="text-align: center">빠름</td>
      <td style="text-align: center">상대적으로 느림</td>
    </tr>
    <tr>
      <td style="text-align: center">오버헤드</td>
      <td style="text-align: center">작음</td>
      <td style="text-align: center">큼</td>
    </tr>
    <tr>
      <td style="text-align: center">사용 예시</td>
      <td style="text-align: center">실시간 전송, DNS 등</td>
      <td style="text-align: center">웹, 이메일, 파일 전송 등</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[Datagram Socket과 Stream Socket은 네트워크 통신 방식에 따라 소켓을 분류한 두 가지 종류이며, 각각은 UDP와 TCP를 기반으로 두고 있음]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">HTTP, TCP, UDP</title><link href="/blog/computersystem/http-tcp-udp/" rel="alternate" type="text/html" title="HTTP, TCP, UDP" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>/blog/computersystem/http-tcp-udp</id><content type="html" xml:base="/blog/computersystem/http-tcp-udp/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#개념-요약" id="markdown-toc-개념-요약">개념 요약</a></li>
  <li><a href="#각-프로토콜-상세-비교" id="markdown-toc-각-프로토콜-상세-비교">각 프로토콜 상세 비교</a>    <ul>
      <li><a href="#1-http" id="markdown-toc-1-http">1. HTTP</a></li>
      <li><a href="#2-tcp" id="markdown-toc-2-tcp">2. TCP</a></li>
      <li><a href="#3-udp" id="markdown-toc-3-udp">3. UDP</a></li>
    </ul>
  </li>
  <li><a href="#계층별-차이-예시로-이해하기" id="markdown-toc-계층별-차이-예시로-이해하기">계층별 차이 예시로 이해하기</a></li>
  <li><a href="#정리-요약" id="markdown-toc-정리-요약">정리 요약</a></li>
</ul>

<h2 id="개념-요약">개념 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">프로토콜</th>
      <th style="text-align: center">설명</th>
      <th style="text-align: center">위치하는 계층 (TCP/IP 기준)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">HTTP (HyperText Transfer Protocol)</td>
      <td style="text-align: center">웹 브라우저와 서버 간의 데이터 전송 (ex. HTML, 이미지 요청 등)</td>
      <td style="text-align: center">애플리케이션 계층</td>
    </tr>
    <tr>
      <td style="text-align: center">TCP (Transmission Control Protocol)</td>
      <td style="text-align: center">신뢰성 있는 연결 지향형 데이터 전송 (패킷 손실 검사 및 재전송)</td>
      <td style="text-align: center">전송 계층</td>
    </tr>
    <tr>
      <td style="text-align: center">UDP (User Datagram Protocol)</td>
      <td style="text-align: center">빠르지만 신뢰성 없는 연결less형 데이터 전송</td>
      <td style="text-align: center">전송 계층</td>
    </tr>
  </tbody>
</table>

<p>TCP/ IP 게층 모델에 관하여서는 <a href="../../computersystem/osi-7-layer" class="heading flip-title">OSI 7 계층(OSI7 Layer)</a>의 하단에 잠깐 다루니 참고하도록 하자</p>

<h2 id="각-프로토콜-상세-비교">각 프로토콜 상세 비교</h2>

<h3 id="1-http">1. HTTP</h3>

<ul>
  <li>
    <p>계층 : application 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>client-server 구조 (browser가 server에 요청)</p>
      </li>
      <li>
        <p>요청/응답 방식(GET, POST 등)</p>
      </li>
      <li>
        <p>TCP 위에서 동작함 (즉, HTTP는 TCP를 기반으로 함)</p>
      </li>
      <li>
        <p>예 : 웹사이트 접속, API 호출</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="2-tcp">2. TCP</h3>

<ul>
  <li>
    <p>계층 : 전송 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>연결 지향 (3-way handshake로 연결 수립)</p>
      </li>
      <li>
        <p>데이터 순서 보장</p>
      </li>
      <li>
        <p>손실된 패킷 재전송</p>
      </li>
      <li>
        <p>속도는 상대적으로 느림</p>
      </li>
      <li>
        <p>예 : 웹서핑, 이메일, 파일 다운로드</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="3-udp">3. UDP</h3>

<ul>
  <li>
    <p>계층 : 전송 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>비연결형 (handshake 없이 즉시 전송)</p>
      </li>
      <li>
        <p>데이터 순서/전송 보장 없음</p>
      </li>
      <li>
        <p>빠름, 지연 최소화</p>
      </li>
      <li>
        <p>예 : 실시간 스트리밍, VoIP, 게임</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="계층별-차이-예시로-이해하기">계층별 차이 예시로 이해하기</h2>

<p>웹 브라우저로 웹 페이지 접속 시 흐름 :</p>

<ol>
  <li>
    <p>HTTP 요청 생성 → (애플리케이션 계층)</p>
  </li>
  <li>
    <p>TCP 연결 수립 후 데이터 전송 → (전송 계층)</p>
  </li>
  <li>
    <p>IP 주소 기반으로 목적지 라우팅 → (인터넷 계층)</p>
  </li>
  <li>
    <p>Ethernet/Wi-Fi를 통해 실제 전송 → (네트워크 인터페이스 계층)</p>
  </li>
</ol>

<h2 id="정리-요약">정리 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">HTTP</th>
      <th style="text-align: center">TCP</th>
      <th style="text-align: center">UDP</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">계층</td>
      <td style="text-align: center">application</td>
      <td style="text-align: center">전송</td>
      <td style="text-align: center">전송</td>
    </tr>
    <tr>
      <td style="text-align: center">연결 방식</td>
      <td style="text-align: center">연결 필요 (TCP 기반)</td>
      <td style="text-align: center">연결 지향</td>
      <td style="text-align: center">비연결형</td>
    </tr>
    <tr>
      <td style="text-align: center">신뢰성</td>
      <td style="text-align: center">TCP에 의존</td>
      <td style="text-align: center">높음 (재전송, 순서 보장)</td>
      <td style="text-align: center">낮음 (손실 허용)</td>
    </tr>
    <tr>
      <td style="text-align: center">속도</td>
      <td style="text-align: center">중간</td>
      <td style="text-align: center">느림</td>
      <td style="text-align: center">빠름</td>
    </tr>
    <tr>
      <td style="text-align: center">용도</td>
      <td style="text-align: center">웹, API</td>
      <td style="text-align: center">웹, 이메일</td>
      <td style="text-align: center">스트리밍, 게임, DNS</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[HTTP, TCP, UDP는 네트워크 통신에서 자주 등장하는 개념들이고, 이들은 OSI 7계층 모델 또는 TCP/IP 4계층 모델의 서로 다른 계층에 위치해 있어. 아래에 각 개념과 계층별 차이점을 정리해줄게]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>