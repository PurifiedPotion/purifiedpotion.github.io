<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-05-06T04:37:45+00:00</updated><id>/feed.xml</id><title type="html">PurifiedPotion’s Blog</title><subtitle>A blog for computer science
</subtitle><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><entry><title type="html">Datagram Socket과 Stream Socket</title><link href="/blog/computersystem/datagram-stream-socket/" rel="alternate" type="text/html" title="Datagram Socket과 Stream Socket" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>/blog/computersystem/datagram-stream-socket</id><content type="html" xml:base="/blog/computersystem/datagram-stream-socket/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#datagram-socket-udp-기반" id="markdown-toc-datagram-socket-udp-기반">Datagram Socket (UDP 기반)</a>    <ul>
      <li><a href="#datagram-socket-udp의-내부-동작" id="markdown-toc-datagram-socket-udp의-내부-동작">Datagram Socket (UDP)의 내부 동작</a></li>
    </ul>
  </li>
  <li><a href="#stream-socket-tcp-기반" id="markdown-toc-stream-socket-tcp-기반">Stream Socket (TCP 기반)</a>    <ul>
      <li><a href="#stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake" id="markdown-toc-stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake">Stream Socket (TCP)의 내부 동작 + TCP 연결 설정 : 3-way handshake</a></li>
    </ul>
  </li>
  <li><a href="#비교-요약" id="markdown-toc-비교-요약">비교 요약</a></li>
</ul>

<p>네트워크 통신 방식에 따라 소켓을 분류한 두 가지 종류 Datagram Socket과 Stream Socket을 알려줄게</p>

<h2 id="datagram-socket-udp-기반">Datagram Socket (UDP 기반)</h2>

<ul>
  <li>
    <p>기반 프로토콜 : UDP (User Datagram Protocol)</p>
  </li>
  <li>
    <p>연결 방식 : 비연결형 (Connectionless)</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p><strong>비연결형</strong> : 연결 없이 바로 데이터 전송</p>
      </li>
      <li>
        <p><strong>신뢰성 없음</strong> : 순서 보장 X, 재전송 X, 확인 응답 X</p>
      </li>
      <li>
        <p><strong>오버헤드 작음</strong> : 빠르고 단순</p>
      </li>
    </ul>
  </li>
  <li>
    <p>용도 예시 :</p>

    <ul>
      <li>
        <p>스트리밍 (비디오/오디오)</p>
      </li>
      <li>
        <p>실시간 게임</p>
      </li>
      <li>
        <p>DNS 요청</p>
      </li>
    </ul>
  </li>
</ul>

<p>예제 : C에서의 예시 (Datagram Socket)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_DGRAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// SOCK_DGRAM이 핵심</span>
</code></pre></div></div>

<h3 id="datagram-socket-udp의-내부-동작">Datagram Socket (UDP)의 내부 동작</h3>

<ul>
  <li>
    <p>Data를 전송하면, 해당 data는 Datagram(데이터그램)으로 만들어짐</p>
  </li>
  <li>
    <p>각 Datagram은 독립적으로 처리됨(순서/재전송 신경 안 씀)</p>
  </li>
  <li>
    <p>수신 측이 없어도 전송은 진행됨</p>
  </li>
</ul>

<blockquote>
  <p>전송 성공 여부는 알 수 없음</p>
</blockquote>

<p>예제 : Data 전송 예</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 송신자</span>
<span class="n">sendto</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">addr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">addr</span><span class="p">));</span>

<span class="c1">// 수신자</span>
<span class="n">recvfrom</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">BUFLEN</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fromlen</span><span class="p">);</span>
</code></pre></div></div>
<blockquote>
  <p><code class="language-plaintext highlighter-rouge">sendto</code>나 <code class="language-plaintext highlighter-rouge">recvfrom</code>에서 연결 상태를 유지하지 않고 주소를 직접 지정함</p>
</blockquote>

<h2 id="stream-socket-tcp-기반">Stream Socket (TCP 기반)</h2>

<ul>
  <li>
    <p>기반 프로토콜 : TCP (Transmission Control Protocol)</p>
  </li>
  <li>
    <p>연결 방식 : 연결형 (Connection-oriented)</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p><strong>연결지향형</strong> : 먼저 연결을 설정한 후 데이터를 주고받음, 통신 전에 연결(3-way handshake) 필요</p>
      </li>
      <li>
        <p><strong>신뢰성</strong> : 순서 보장, 오류 검출, 재전송</p>
      </li>
      <li>
        <p><strong>흐름 제어</strong> : 수신자가 감당할 수 있을 만큼만 전송</p>
      </li>
      <li>
        <p><strong>혼잡 제어</strong> : 네트워크 상황에 따라 전송 속도 조절</p>
      </li>
      <li>
        <p>속도는 느릴 수 있지만 신뢰성 높음</p>
      </li>
    </ul>
  </li>
  <li>
    <p>용도 예시 :</p>

    <ul>
      <li>
        <p>웹 서비스 (HTTP)</p>
      </li>
      <li>
        <p>이메일 (SMTP)</p>
      </li>
      <li>
        <p>파일 전송 (FTP)</p>
      </li>
    </ul>
  </li>
</ul>

<p>예제 : C에서의 예시 (Stream Socket)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="n">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>  <span class="c1">// SOCK_STREAM이 핵심</span>
</code></pre></div></div>

<h3 id="stream-socket-tcp의-내부-동작--tcp-연결-설정--3-way-handshake">Stream Socket (TCP)의 내부 동작 + TCP 연결 설정 : 3-way handshake</h3>

<p><strong>3way handshake</strong>는 양쪽 통신자가 연결을 동기화하고 준비됐는지 확인하는 과정</p>

<p><strong>과정 요약</strong></p>

<ol>
  <li>
    <p>client → server : <code class="language-plaintext highlighter-rouge">SYN</code> 플래그 세팅된 패킷 전송 (연결 요청)</p>
  </li>
  <li>
    <p>server → client : <code class="language-plaintext highlighter-rouge">SYN + ACK</code> 패킷 전송 (요청 수락 + 서버도 연결 요청)</p>
  </li>
  <li>
    <p>client → server : <code class="language-plaintext highlighter-rouge">ACK</code> 전송 (서버의 연결 수락)</p>
  </li>
</ol>

<blockquote>
  <p>이 과정을 거친 뒤 양쪽 모두 연결이 되었고, 데이터를 주고받을 수 있어</p>
</blockquote>

<p><strong>예시 흐름</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">송신자</th>
      <th style="text-align: center">수신자</th>
      <th style="text-align: center">내용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">SYN, seq = x</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">SYN + ACK, seq = y, ack = x+1</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">Client</td>
      <td style="text-align: center">Server</td>
      <td style="text-align: center">ACK, seq = x+1, ack = y+1</td>
    </tr>
  </tbody>
</table>

<p><strong>TCP 데이터 전송</strong></p>

<ol>
  <li>
    <p>데이터는 스트림(stream)으로 보내짐. 내부적으로 작은 단위로 나뉘어 전송됨.</p>
  </li>
  <li>
    <p>각 패킷은 시퀸스 번호(sequence number)를 가짐</p>
  </li>
  <li>
    <p>수신자는 받은 순서대로 조립하고, ACK로 확인 메시지 보냄</p>
  </li>
  <li>
    <p>손실되면 재전송함</p>
  </li>
</ol>

<p><strong>TCP 연결 종료 : 4-way handshake</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">전송</th>
      <th style="text-align: center">인자</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">A → B</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">FIN</code></td>
      <td style="text-align: center">A가 종료 요청</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">B → A</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">ACK</code></td>
      <td style="text-align: center">B가 확인</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">B → A</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">FIN</code></td>
      <td style="text-align: center">B도 종료 요청</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">A → B</td>
      <td style="text-align: center"><code class="language-plaintext highlighter-rouge">ACK</code></td>
      <td style="text-align: center">A가 확인하고 종료</td>
    </tr>
  </tbody>
</table>

<h2 id="비교-요약">비교 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">Datagram Socket (UDP)</th>
      <th style="text-align: center">Stream Socket (TCP)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">연결 여부</td>
      <td style="text-align: center">비연결 (Connectionless)</td>
      <td style="text-align: center">연결 (Connection-oriented)</td>
    </tr>
    <tr>
      <td style="text-align: center">연결 과정</td>
      <td style="text-align: center">없음</td>
      <td style="text-align: center">3-way handshake 필요</td>
    </tr>
    <tr>
      <td style="text-align: center">오류 처리</td>
      <td style="text-align: center">없음</td>
      <td style="text-align: center">ACK + 재전송</td>
    </tr>
    <tr>
      <td style="text-align: center">신뢰성</td>
      <td style="text-align: center">낮음</td>
      <td style="text-align: center">높음</td>
    </tr>
    <tr>
      <td style="text-align: center">Data 순서 보장</td>
      <td style="text-align: center">안됨</td>
      <td style="text-align: center">됨(시퀸스 번호로 순서 보장)</td>
    </tr>
    <tr>
      <td style="text-align: center">속도</td>
      <td style="text-align: center">빠름</td>
      <td style="text-align: center">상대적으로 느림</td>
    </tr>
    <tr>
      <td style="text-align: center">오버헤드</td>
      <td style="text-align: center">작음</td>
      <td style="text-align: center">큼</td>
    </tr>
    <tr>
      <td style="text-align: center">사용 예시</td>
      <td style="text-align: center">실시간 전송, DNS 등</td>
      <td style="text-align: center">웹, 이메일, 파일 전송 등</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[Datagram Socket과 Stream Socket은 네트워크 통신 방식에 따라 소켓을 분류한 두 가지 종류이며, 각각은 UDP와 TCP를 기반으로 두고 있음]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">HTTP, TCP, UDP</title><link href="/blog/computersystem/http-tcp-udp/" rel="alternate" type="text/html" title="HTTP, TCP, UDP" /><published>2025-05-06T00:00:00+00:00</published><updated>2025-05-06T00:00:00+00:00</updated><id>/blog/computersystem/http-tcp-udp</id><content type="html" xml:base="/blog/computersystem/http-tcp-udp/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#개념-요약" id="markdown-toc-개념-요약">개념 요약</a></li>
  <li><a href="#각-프로토콜-상세-비교" id="markdown-toc-각-프로토콜-상세-비교">각 프로토콜 상세 비교</a>    <ul>
      <li><a href="#1-http" id="markdown-toc-1-http">1. HTTP</a></li>
      <li><a href="#2-tcp" id="markdown-toc-2-tcp">2. TCP</a></li>
      <li><a href="#3-udp" id="markdown-toc-3-udp">3. UDP</a></li>
    </ul>
  </li>
  <li><a href="#계층별-차이-예시로-이해하기" id="markdown-toc-계층별-차이-예시로-이해하기">계층별 차이 예시로 이해하기</a></li>
  <li><a href="#정리-요약" id="markdown-toc-정리-요약">정리 요약</a></li>
</ul>

<h2 id="개념-요약">개념 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">프로토콜</th>
      <th style="text-align: center">설명</th>
      <th style="text-align: center">위치하는 계층 (TCP/IP 기준)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">HTTP (HyperText Transfer Protocol)</td>
      <td style="text-align: center">웹 브라우저와 서버 간의 데이터 전송 (ex. HTML, 이미지 요청 등)</td>
      <td style="text-align: center">애플리케이션 계층</td>
    </tr>
    <tr>
      <td style="text-align: center">TCP (Transmission Control Protocol)</td>
      <td style="text-align: center">신뢰성 있는 연결 지향형 데이터 전송 (패킷 손실 검사 및 재전송)</td>
      <td style="text-align: center">전송 계층</td>
    </tr>
    <tr>
      <td style="text-align: center">UDP (User Datagram Protocol)</td>
      <td style="text-align: center">빠르지만 신뢰성 없는 연결less형 데이터 전송</td>
      <td style="text-align: center">전송 계층</td>
    </tr>
  </tbody>
</table>

<p>TCP/ IP 게층 모델에 관하여서는 <a href="../../computersystem/osi-7-layer" class="heading flip-title">OSI 7 계층(OSI7 Layer)</a>의 하단에 잠깐 다루니 참고하도록 하자</p>

<h2 id="각-프로토콜-상세-비교">각 프로토콜 상세 비교</h2>

<h3 id="1-http">1. HTTP</h3>

<ul>
  <li>
    <p>계층 : application 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>client-server 구조 (browser가 server에 요청)</p>
      </li>
      <li>
        <p>요청/응답 방식(GET, POST 등)</p>
      </li>
      <li>
        <p>TCP 위에서 동작함 (즉, HTTP는 TCP를 기반으로 함)</p>
      </li>
      <li>
        <p>예 : 웹사이트 접속, API 호출</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="2-tcp">2. TCP</h3>

<ul>
  <li>
    <p>계층 : 전송 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>연결 지향 (3-way handshake로 연결 수립)</p>
      </li>
      <li>
        <p>데이터 순서 보장</p>
      </li>
      <li>
        <p>손실된 패킷 재전송</p>
      </li>
      <li>
        <p>속도는 상대적으로 느림</p>
      </li>
      <li>
        <p>예 : 웹서핑, 이메일, 파일 다운로드</p>
      </li>
    </ul>
  </li>
</ul>

<h3 id="3-udp">3. UDP</h3>

<ul>
  <li>
    <p>계층 : 전송 계층</p>
  </li>
  <li>
    <p>특징 :</p>

    <ul>
      <li>
        <p>비연결형 (handshake 없이 즉시 전송)</p>
      </li>
      <li>
        <p>데이터 순서/전송 보장 없음</p>
      </li>
      <li>
        <p>빠름, 지연 최소화</p>
      </li>
      <li>
        <p>예 : 실시간 스트리밍, VoIP, 게임</p>
      </li>
    </ul>
  </li>
</ul>

<h2 id="계층별-차이-예시로-이해하기">계층별 차이 예시로 이해하기</h2>

<p>웹 브라우저로 웹 페이지 접속 시 흐름 :</p>

<ol>
  <li>
    <p>HTTP 요청 생성 → (애플리케이션 계층)</p>
  </li>
  <li>
    <p>TCP 연결 수립 후 데이터 전송 → (전송 계층)</p>
  </li>
  <li>
    <p>IP 주소 기반으로 목적지 라우팅 → (인터넷 계층)</p>
  </li>
  <li>
    <p>Ethernet/Wi-Fi를 통해 실제 전송 → (네트워크 인터페이스 계층)</p>
  </li>
</ol>

<h2 id="정리-요약">정리 요약</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">HTTP</th>
      <th style="text-align: center">TCP</th>
      <th style="text-align: center">UDP</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">계층</td>
      <td style="text-align: center">application</td>
      <td style="text-align: center">전송</td>
      <td style="text-align: center">전송</td>
    </tr>
    <tr>
      <td style="text-align: center">연결 방식</td>
      <td style="text-align: center">연결 필요 (TCP 기반)</td>
      <td style="text-align: center">연결 지향</td>
      <td style="text-align: center">비연결형</td>
    </tr>
    <tr>
      <td style="text-align: center">신뢰성</td>
      <td style="text-align: center">TCP에 의존</td>
      <td style="text-align: center">높음 (재전송, 순서 보장)</td>
      <td style="text-align: center">낮음 (손실 허용)</td>
    </tr>
    <tr>
      <td style="text-align: center">속도</td>
      <td style="text-align: center">중간</td>
      <td style="text-align: center">느림</td>
      <td style="text-align: center">빠름</td>
    </tr>
    <tr>
      <td style="text-align: center">용도</td>
      <td style="text-align: center">웹, API</td>
      <td style="text-align: center">웹, 이메일</td>
      <td style="text-align: center">스트리밍, 게임, DNS</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[HTTP, TCP, UDP는 네트워크 통신에서 자주 등장하는 개념들이고, 이들은 OSI 7계층 모델 또는 TCP/IP 4계층 모델의 서로 다른 계층에 위치해 있어. 아래에 각 개념과 계층별 차이점을 정리해줄게]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">IP Layer</title><link href="/blog/computersystem/ip-layer/" rel="alternate" type="text/html" title="IP Layer" /><published>2025-05-05T00:00:00+00:00</published><updated>2025-05-05T00:00:00+00:00</updated><id>/blog/computersystem/ip-layer</id><content type="html" xml:base="/blog/computersystem/ip-layer/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#ip-layer란" id="markdown-toc-ip-layer란">IP Layer란?</a></li>
  <li><a href="#왜-필요한가" id="markdown-toc-왜-필요한가">왜 필요한가?</a></li>
  <li><a href="#핵심-기능-상세" id="markdown-toc-핵심-기능-상세">핵심 기능 상세</a></li>
  <li><a href="#ipv4-헤더-구조-한눈에-보기" id="markdown-toc-ipv4-헤더-구조-한눈에-보기">IPv4 헤더 구조 한눈에 보기</a></li>
  <li><a href="#흐름-예시-간단-시나리오" id="markdown-toc-흐름-예시-간단-시나리오">흐름 예시 (간단 시나리오)</a></li>
  <li><a href="#개발자-관점--유용한-cli" id="markdown-toc-개발자-관점--유용한-cli">개발자 관점 : 유용한 CLI</a></li>
  <li><a href="#자주-헷갈리는-점-정리" id="markdown-toc-자주-헷갈리는-점-정리">자주 헷갈리는 점 정리</a></li>
  <li><a href="#마무리" id="markdown-toc-마무리">마무리</a></li>
</ul>

<h2 id="ip-layer란">IP Layer란?</h2>

<p>IP (Internet Protocol) Layer는 <strong>TCP/IP 4계층 모델</strong>에서 네트워크 계층(Network Layer)에 해당하며, OSI 7계층으로 치면 <strong>3계층</strong>임
가장 핵심적인 역할은 “<strong>패킷을 한 네트워크에서 다른 네트워크로 최적의 경로를 따라 전달</strong>”하는 것—즉 <strong>논리적 주소(=IP 주소)</strong> 기반의 <strong>라우팅</strong></p>

<h2 id="왜-필요한가">왜 필요한가?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">문제</th>
      <th style="text-align: center">IP Layer가 제공하는 해결책</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">물리적으로 떨어져 있는 수많은 LAN·WAN을 하나의 ‘인터넷’으로 묶어야 함</td>
      <td style="text-align: center">전 세계적으로 유일한 주소 체계(IPv4/IPv6)와 계층적 라우팅</td>
    </tr>
    <tr>
      <td style="text-align: center">이기종 네트워크(이더넷, Wi-Fi, 5G, 광망 …)간 데이터 전달</td>
      <td style="text-align: center">서로 다른 링크 계층을 통일된 패킷 형식(IP Datagram)으로 캡슐화</td>
    </tr>
    <tr>
      <td style="text-align: center">큰 데이터그램이 링크 MTU보다 클 때</td>
      <td style="text-align: center">Fragmentation &amp; Reassembly(IPv4만 IPv6은 PMTU 디스커버리 사용)</td>
    </tr>
    <tr>
      <td style="text-align: center">전송 중 오류·혼잡·노드 고장 감지</td>
      <td style="text-align: center">ICMP로 오류·제어 메시지 전달</td>
    </tr>
  </tbody>
</table>

<h2 id="핵심-기능-상세">핵심 기능 상세</h2>

<ol>
  <li>
    <p>논리적 주소 지정 (Addressing)</p>

    <ul>
      <li>
        <p>IPv4 : 32-bit, dotted-decimal(192.0.2.4)</p>
      </li>
      <li>
        <p>IPv6 : 128-bit, hexadecimal 콜론 표기(2001:db8::1)</p>
      </li>
      <li>
        <p>네트워크/호스트 부분을 사용해 계층적(aggregation) 라우팅을 가능케 함</p>
      </li>
    </ul>
  </li>
  <li>
    <p>패킷화 (Encapsulation)</p>

    <ul>
      <li>상위 계층(TCP, UDP, ICMP 등) 세그먼트를 IP Header + Payload 형태로 감싼 뒤 하위 링크 계층(이더넷 프레임 등)에 다시 캡슐화</li>
    </ul>
  </li>
  <li>
    <p>라우팅 (Routing &amp; Forwarding)</p>

    <ul>
      <li>
        <p>Forwarding : 라우터가 목적지 주소를 보고 다음 홉(next-hop) 인터페이스로 패킷을 넘김</p>
      </li>
      <li>
        <p>Routing : 라우터들이 RIP, OSPF, BGP 같은 라우팅 프로토콜로 테이블을 동적으로 구축</p>
      </li>
    </ul>
  </li>
  <li>
    <p>분할 및 재조합 (Fragmentation/Reassembly)</p>

    <ul>
      <li>
        <p>IPv4 헤더의 Identification, Flags, Fragment Offset 필드로 조각화 추적</p>
      </li>
      <li>
        <p>IPv6은 기본적으로 조각화를 금지, 발신 호스트가 Path MTU Discovery로 크기를 조정</p>
      </li>
    </ul>
  </li>
  <li>
    <p>품질과 오류 제어</p>

    <ul>
      <li>
        <p>IPv4 Header Checksum으로 1-hop 오류 검출(IPv6에는 없음 : 링크 계층/전송 계층에 맡김)</p>
      </li>
      <li>
        <p>ICMP를 통해 “Destination Unreachable”, “Time Exceeded” 등 메시지 반환</p>
      </li>
    </ul>
  </li>
</ol>

<h2 id="ipv4-헤더-구조-한눈에-보기">IPv4 헤더 구조 한눈에 보기</h2>

<div class="language-diff highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">0                   1                   2                   3
0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
</span><span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|Ver|</span> IHL|DSCP|ECN|         Total Length                        |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>        Identification         |Flags|      Fragment Offset    |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>  TTL  | Protocol |    Header Checksum                         |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>                       Source Address                          |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>                    Destination Address                        |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span><span class="err">|</span>                    Options      (0 ~ 40 bytes)                |
<span class="gi">+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></code></pre></div></div>

<ul>
  <li>
    <p>Ver/IHL : 버전(4)과 헤더 길이(32비트 word 수)</p>
  </li>
  <li>
    <p>Total Length : 헤더 + 데이터 전체 길이</p>
  </li>
  <li>
    <p>TTL : 홉 수 제한(루프 방지)</p>
  </li>
  <li>
    <p>Protocol : 상위 프로토콜 번호(TCP = 6, UDP = 17…)</p>
  </li>
  <li>
    <p>Options : Timestamp, Record Route 등 거의 사용 안함</p>
  </li>
</ul>

<p>IPv6는 고정 40바이트 헤더에 별도 확장 헤더 체인을 사용해 단순화/고속화함</p>

<h2 id="흐름-예시-간단-시나리오">흐름 예시 (간단 시나리오)</h2>

<ol>
  <li>
    <p>192.168.1.10:5000 → 142.250.78.14:443(TCP)</p>
  </li>
  <li>
    <p>TCP 세그먼트가 IP Datagram으로 캡슐화</p>
  </li>
  <li>
    <p>로컬 라우터가 목적지 네트워크(AS15169)를 향한 default route 선택</p>
  </li>
  <li>
    <p>중간 BGP 라우터들이 TTL을 1씩 감소시키며 패킷 포워딩</p>
  </li>
  <li>
    <p>Google 프런트엔드 서버에서 TCP ACK, HTTP/2 응답 → 역방향 경로로 전송</p>
  </li>
</ol>

<h2 id="개발자-관점--유용한-cli">개발자 관점 : 유용한 CLI</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">작업</th>
      <th style="text-align: center">IPv4</th>
      <th style="text-align: center">IPv6</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">라우팅 테이블 확인</td>
      <td style="text-align: center">ip route show</td>
      <td style="text-align: center">ip -6 route show</td>
    </tr>
    <tr>
      <td style="text-align: center">패킷 흐름 추적</td>
      <td style="text-align: center">traceroute 8.8.8.8</td>
      <td style="text-align: center">traceroute -6 2001:4860:4860::8888</td>
    </tr>
    <tr>
      <td style="text-align: center">ICMP Echo</td>
      <td style="text-align: center">ping -c 4 host</td>
      <td style="text-align: center">ping6 -c 4 host</td>
    </tr>
  </tbody>
</table>

<h2 id="자주-헷갈리는-점-정리">자주 헷갈리는 점 정리</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">오해</th>
      <th style="text-align: center">실제</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">“IP = 인터넷 전체 프로토콜 스택”</td>
      <td style="text-align: center">IP는 한 계층일 뿐, 아래(링크)/위(전송)/위의 위(애플리케이션) 계층이 따로 있다</td>
    </tr>
    <tr>
      <td style="text-align: center">“IP가 연결 지향”</td>
      <td style="text-align: center">IP는 비연결형, 비신뢰성∙Best-Effort. 신뢰성은 TCP가 따로 보장</td>
    </tr>
    <tr>
      <td style="text-align: center">“IPv6는 단순히 주소 길이만 4배”</td>
      <td style="text-align: center">헤더 단순화, Neighbour Discovery, 확장 헤더, IPsec 의무 지원 등 근본적 개선 포함</td>
    </tr>
  </tbody>
</table>

<h2 id="마무리">마무리</h2>

<p>IP Layer는 <strong>인터넷을 ‘한 덩어리’로 보이게 해 주는 추상화</strong>입니다. 여기서 다룬 주소 지정, 라우팅, 조각화, ICMP 등의 기초가 잡혀 있으면 TCP, UDP, TLS 같은 상위 계층을 배울 때 훨씬 수월해짐</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[IP (Internet Protocol) Layer는 TCP/IP 4계층 모델에서 네트워크 계층(Network Layer)에 해당하며, OSI 7계층으로 치면 3계층입니다. 가장 핵심적인 역할은 “패킷을 한 네트워크에서 다른 네트워크로 최적의 경로를 따라 전달”하는 것—즉 논리적 주소(=IP 주소) 기반의 라우팅입니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">OSI 7 계층(OSI7 Layer)</title><link href="/blog/computersystem/osi-7-layer/" rel="alternate" type="text/html" title="OSI 7 계층(OSI7 Layer)" /><published>2025-05-05T00:00:00+00:00</published><updated>2025-05-05T00:00:00+00:00</updated><id>/blog/computersystem/osi-7-layer</id><content type="html" xml:base="/blog/computersystem/osi-7-layer/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#한눈에-보는-osi-7계층" id="markdown-toc-한눈에-보는-osi-7계층">한눈에 보는 OSI 7계층</a></li>
  <li><a href="#계층별-세부사항" id="markdown-toc-계층별-세부사항">계층별 세부사항</a></li>
  <li><a href="#왜-tcpip-4계층-모델을-더-많이-쓸까" id="markdown-toc-왜-tcpip-4계층-모델을-더-많이-쓸까">왜 TCP/IP 4계층 모델을 더 많이 쓸까?</a></li>
  <li><a href="#osi-7계층을-배우는-이유" id="markdown-toc-osi-7계층을-배우는-이유">OSI 7계층을 배우는 이유</a></li>
</ul>

<p><strong>OSI 7 계층</strong>은 <strong>물리 신호부터 user application</strong>까지 <strong>네트워크 기능을 일곱 단계로 나눈 개념적 설계도</strong>이다. 실무에선 TCP/IP 4계층으로 단순화해 쓰지만, 문제 분석과 개념 정리에 여전히 유용함</p>

<h2 id="한눈에-보는-osi-7계층">한눈에 보는 OSI 7계층</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">번호</th>
      <th style="text-align: center">계층 이름</th>
      <th style="text-align: center">주요 기능</th>
      <th style="text-align: center">예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">7</td>
      <td style="text-align: center">응용 계층 (Application)</td>
      <td style="text-align: center">사용자와 직접 상호작용, 네트워크 서비스 제공</td>
      <td style="text-align: center">HTTPS/HTTPS, FTP, SMTP, DNS, SSH</td>
    </tr>
    <tr>
      <td style="text-align: center">6</td>
      <td style="text-align: center">표현 계층 (Presentation)</td>
      <td style="text-align: center">데이터 형식 변환, 암호화/복호화, 압축</td>
      <td style="text-align: center">JPEG, MP3, SSL</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: center">세션 계층 (Session)</td>
      <td style="text-align: center">연결 설정/유지/종료, 세션 관리</td>
      <td style="text-align: center">NetBIOS, RPC, PPTP</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">전송 계층 (Transport)</td>
      <td style="text-align: center">데이터 전송 보장(신뢰성), 오류 제어</td>
      <td style="text-align: center">TCP, UDP, QUIC, SCTP</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">네트워크 계층 (Network)</td>
      <td style="text-align: center">주소 지정/경로 선택(라우팅)</td>
      <td style="text-align: center">IP, ICMP, ARP, OSPF, BGP</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: center">데이터링크 계층 (Data-Link)</td>
      <td style="text-align: center">프레임 생성, MAC 주소 기반 전달, 에러 감지</td>
      <td style="text-align: center">Ethernet, Wi-Fi 802.11, PPP, VLAN, 스위치</td>
    </tr>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: center">물리 계층 (Physical)</td>
      <td style="text-align: center">0/1 신호를 실제 매체로 전송</td>
      <td style="text-align: center">UTP 케이블, 광섬유, 전파, 허브, 리피터</td>
    </tr>
  </tbody>
</table>

<h2 id="계층별-세부사항">계층별 세부사항</h2>

<ol>
  <li>물리 계층</li>
</ol>

<p>“전길줄에 0과 1을 어떻게 흘려보낼까?”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 전압 크기, 광펄스 세기, 라디오 주파수 등 **신호**의 물리적 특성을 정의함

- 허브/리피터처럼 "증폭만 하고 아무 판단도 못 하는" 장비가 여기에 속함
</code></pre></div></div>

<ol>
  <li>데이터링크 계층</li>
</ol>

<p>“같은 네트워크(브로드캐스트 도메인) 안에서 누가 누구인지 구분하려면?”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **MAC 주소**를 붙여 프레임 단위로 전송하며, CRC로 프레임 오류를 검출함

- 스위치/브리지·VLAN·ARP 캐시 같은 개념이 등장함
</code></pre></div></div>

<ol>
  <li>네트워크 계층</li>
</ol>

<p>“지구 반대편 호스트까지 가려면 중간길(라우팅)을 어떻게 잡지?”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- **IP 주소**를 붙이고, 라우터가 최적 경로를 찾아 포워딩함

- ICMP '목적지 도달 불가', OSPF/BGP 등 라우팅 프로토콜이 여기에 있음
</code></pre></div></div>

<ol>
  <li>전송 계층</li>
</ol>

<p>“프로세스 간에 패킷이 유실돼도 재전송하고, 순서도 맞춰야지”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- TCP : 3-Way Handshake, 흐름/혼잡 제어, 세그먼트 재전송

- UDP : 최소한의 헤더로 "빠르지만 책임 안 진다"

- QUIC : HTTP/3가 쓰는 신흥 강자, UDP 위에 신뢰성·TLS 포함
</code></pre></div></div>

<ol>
  <li>세션 계층</li>
</ol>

<p>“논리적인 대화방(세션)을 열고 닫는 관리를 맡자”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 체크포인트·재동기화·다중 스트림 제어 가능

- 실무에선 애매함, OSI만의 전통적인 구분이며, 실제 구현은 주로 응용/전송이 흡수
</code></pre></div></div>

<ol>
  <li>표현 계층</li>
</ol>

<p>“바이트를 사람이 읽을 수 있게/암호화된 형태로 변환하자”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 문자 집합 변환(UTF-8↔EUC-KR), 압축(GZIP), 암복호(TLS) 담당

- 응용계층과 합쳐서 다루는 경우가 많지만, 보안·멀티미디어 코덱 설명 때 유용
</code></pre></div></div>

<ol>
  <li>응용 계층</li>
</ol>

<p>“사용자 프로그램이 원하는 서비스 그 자체”</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 웹브라우저-HTTP, 메일-SMTP/IMAP, 파일전송-FTP/SFTP 처럼 **실제 앱 프로토콜**이 자리함

- API 호출(REST/GraphQL)·메신저 프로토콜도 여기서 논의됨
</code></pre></div></div>

<h2 id="왜-tcpip-4계층-모델을-더-많이-쓸까">왜 TCP/IP 4계층 모델을 더 많이 쓸까?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">OSI</th>
      <th style="text-align: center">TCP/IP(실무)</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">7-5</td>
      <td style="text-align: center">응용 계층</td>
      <td style="text-align: center">HTTP·TLS·RPC 등 모두 한 덩어리</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: center">전송 계층</td>
      <td style="text-align: center">TCP·UDP·QUIC</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: center">인터넷 계층</td>
      <td style="text-align: center">IP, ICMP 등</td>
    </tr>
    <tr>
      <td style="text-align: center">2-1</td>
      <td style="text-align: center">네트워크 접근 계층</td>
      <td style="text-align: center">Ethernet·Wi-Fi·물리 매체</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p><strong>간소화</strong> : 실제 구현에서는 세션/표현 계층이 따로 분리돼 작동하지 않는 경우가 많아 4단계로 줄임</p>
  </li>
  <li>
    <p><strong>표준화 주체</strong>도 다름. OSI는 ISO(국제표준화기구) 주도, TCP/IP는 IETF(인터넷 엔지니어링 태스크포스)가 주도함</p>
  </li>
</ul>

<h2 id="osi-7계층을-배우는-이유">OSI 7계층을 배우는 이유</h2>

<ol>
  <li>
    <p>문제 진단 : “이건 3계층 문제인가 4계층 문제인가?”를 구분해야 디버깅이 쉬움</p>
  </li>
  <li>
    <p>역할 분리 : “ 새 프로토콜 설계 시 “이 기능은 어느 계층 책임인가?”를 결정하는 기준 세우기가 가능해짐</p>
  </li>
  <li>
    <p>학습 프레임 : 물리 → 응용으로 올라가며 추상화·책임 범위를 체계적으로 이해할 수 있음</p>
  </li>
</ol>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[OSI 7계층(Open Systems Interconnection 7 Layers)은 네트워크 통신 과정을 7단계로 나눈 모델이며, 이 모델은 각 계층마다 맡은 역할이 정해져 있어서, 복잡한 통신 과정을 구조화하고 표준화하는 데 도움이 됩니다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Demand-zero memory</title><link href="/blog/computersystem/demand-zero-memory/" rel="alternate" type="text/html" title="Demand-zero memory" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>/blog/computersystem/demand-zero-memory</id><content type="html" xml:base="/blog/computersystem/demand-zero-memory/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#동작-흐름" id="markdown-toc-동작-흐름">동작 흐름</a></li>
  <li><a href="#왜-쓰일까" id="markdown-toc-왜-쓰일까">왜 쓰일까?</a></li>
  <li><a href="#언제-볼-수-있을까" id="markdown-toc-언제-볼-수-있을까">언제 볼 수 있을까?</a></li>
  <li><a href="#요약" id="markdown-toc-요약">요약</a>    <ul>
      <li><a href="#나만의-요약" id="markdown-toc-나만의-요약">나만의 요약</a></li>
    </ul>
  </li>
</ul>

<p><strong>Demand-zero memory(또는 zero-filled-on-demand page)</strong>는 운영체제가 <strong>“필요해질 때(demand)”</strong> 처음 접근되는 순간에만 물리 페이지를 연결하고, 그 페이지의 모든 바이트를 0으로 채워서(zero-fill) 사용자 프로세스에 넘겨주는 메모리 할당 기법</p>

<h2 id="동작-흐름">동작 흐름</h2>

<ol>
  <li>가상 주소 공간만 잡아 두기</li>
</ol>

<ul>
  <li>
    <p>프로그램이 malloc, VirtualAlloc(…, MEM_RESERVE), 스택 확대, BSS(전역/정적 0-초기화 변수) 등으로 “새 메모리를” 요구하면,</p>
  </li>
  <li>
    <p>커널은 대응되는 물리 페이지 없이 가상 주소 범위를 예약해 두고, PTE(Page-Table Entry)에 “아직 물리 페이지 없음, demand-zero”라는 플래그를 세워 둠</p>
  </li>
</ul>

<ol>
  <li>첫 접근 → 페이지 폴트(page fault)</li>
</ol>

<ul>
  <li>CPU가 그 주소를 읽거나 쓰려고 하면 PTE에 실제 프레임이 없으므로 페이지 폴트가 발생</li>
</ul>

<ol>
  <li>커널이 물리 페이지 할당 &amp; 0으로 초기화</li>
</ol>

<ul>
  <li>
    <p>커널의 Zero Page List에서 이미 0으로 클리어돼 있는 여유 페이지를 하나 꺼내오거나,</p>
  </li>
  <li>
    <p>여유 페이지가 없다면 새 페이지를 확보한 뒤 memset(page, 0, PAGE_SIZE)로 0-필(fill) 한다</p>
  </li>
</ul>

<ol>
  <li>PTE 갱신 후 재시도</li>
</ol>

<ul>
  <li>PTE를 “valid + 해당 물리 프레임”으로 고쳐 놓고, fault 된 명령을 재실행하면 이제 정상적으로 0값이 보임</li>
</ul>

<h2 id="왜-쓰일까">왜 쓰일까?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">장점</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">메모리 절약</td>
      <td style="text-align: center">큰 배열/구조체를 “0으로 초기화”해 예약만 해 놓고, 실제로 접근한 부분만 물리 메모리를 소비함</td>
    </tr>
    <tr>
      <td style="text-align: center">보안 &amp; 안정성</td>
      <td style="text-align: center">항상 0으로 채워 주므로, 이전 프로세스의 잔류 데이터가 노출되지 않음</td>
    </tr>
    <tr>
      <td style="text-align: center">속도(평균)</td>
      <td style="text-align: center">초기화 루프를 사용자 코드에서 돌릴 필요가 없고, 커널은 미리 0-클리어 해 둔 zero-page 풀을 재사용해 페이지 폴트 처리 시간을 최소화함</td>
    </tr>
  </tbody>
</table>

<h2 id="언제-볼-수-있을까">언제 볼 수 있을까?</h2>

<ul>
  <li>
    <p>Windows - MEM_COMMIT 없이 VirtualAlloc으로 예약만 한 뒤 접근할 때, 또는 일반 HeapAlloc/new 내부적으로</p>
  </li>
  <li>
    <p>Linux/Unix - 익명 매핑 mmap(…, MAP_ANONYMOUS)·스택·BSS·brk/sbrk 등</p>
  </li>
  <li>
    <p>하이퍼바이저/가상머신 - 게스트가 처음 쓰는 시점까지 진짜 호스트 RAM을 배정하지 않는 ballooning 기법과 결합되기도 함</p>
  </li>
</ul>

<h2 id="요약">요약</h2>

<p>Demand-zero memory = “필요할 때 0으로 초기화된 물리 페이지를 뒤늦게 붙이는 가상 메모리 기술”</p>

<p>→ 프로그램 입장에서는 ‘이미 0으로 초기화돼 있는 새 메모리’를 즉시 얻은 것처럼 보이지만, 실제 RAM은 첫 사용 시점까지 쓰이지 않아 메모리를 아끼고 보안을 높여 줌</p>

<h3 id="나만의-요약">나만의 요약</h3>

<ol>
  <li>
    <p>물리 메모리 같은 경우 첫 사용 전까지는 메모리 할당이 되지 않음</p>
  </li>
  <li>
    <p>하지만 가상 메모리에서는 공간이 확보된 상태</p>
  </li>
  <li>
    <p>실제 사용시에는 page fault 되면서 물리 메모리 할당이 이루어짐, PTE의 Not-present → Present로 갱신</p>
  </li>
</ol>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[Demand-zero memory(또는 zero-filled-on-demand page)는 운영체제가 “필요해질 때(demand)” 처음 접근되는 순간에만 물리 페이지를 연결하고, 그 페이지의 모든 바이트를 0으로 채워서(zero-fill) 사용자 프로세스에 넘겨주는 메모리 할당 기법이다]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Direct Memory Access</title><link href="/blog/computersystem/dma/" rel="alternate" type="text/html" title="Direct Memory Access" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>/blog/computersystem/dma</id><content type="html" xml:base="/blog/computersystem/dma/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#dmadirect-memory-access란" id="markdown-toc-dmadirect-memory-access란">DMA(Direct Memory Access)란?</a></li>
  <li><a href="#왜-dma가-필요한가" id="markdown-toc-왜-dma가-필요한가">왜 DMA가 필요한가?</a></li>
  <li><a href="#기본-구성-요소" id="markdown-toc-기본-구성-요소">기본 구성 요소</a>    <ul>
      <li><a href="#dma-레지스터-src-dst-len" id="markdown-toc-dma-레지스터-src-dst-len">DMA 레지스터 SRC, DST, LEN</a></li>
    </ul>
  </li>
  <li><a href="#동작-흐름-x86-pc-예시" id="markdown-toc-동작-흐름-x86-pc-예시">동작 흐름 (x86 PC 예시)</a>    <ul>
      <li><a href="#동작-흐름-더-자세히" id="markdown-toc-동작-흐름-더-자세히">동작 흐름 더 자세히</a>        <ul>
          <li><a href="#1-단계---cpu까-준비만-하고-손을-뗀다" id="markdown-toc-1-단계---cpu까-준비만-하고-손을-뗀다">1 단계 - CPU까 준비만 하고 손을 뗀다</a></li>
          <li><a href="#2-단계---버스-소유권-교환" id="markdown-toc-2-단계---버스-소유권-교환">2 단계 - 버스 소유권 교환</a></li>
          <li><a href="#3-단계---실제-데이터-이동" id="markdown-toc-3-단계---실제-데이터-이동">3 단계 - 실제 데이터 이동</a></li>
          <li><a href="#4-단계---전송-완료-알림" id="markdown-toc-4-단계---전송-완료-알림">4 단계 - 전송 완료 알림</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#전송-모드" id="markdown-toc-전송-모드">전송 모드</a></li>
  <li><a href="#현대-시스템에서의-dma-변화" id="markdown-toc-현대-시스템에서의-dma-변화">현대 시스템에서의 DMA 변화</a></li>
  <li><a href="#장점과-단점-요약" id="markdown-toc-장점과-단점-요약">장점과 단점 요약</a></li>
  <li><a href="#실무-예시" id="markdown-toc-실무-예시">실무 예시</a></li>
  <li><a href="#운영체제-관점" id="markdown-toc-운영체제-관점">운영체제 관점</a></li>
</ul>

<h2 id="dmadirect-memory-access란">DMA(Direct Memory Access)란?</h2>

<p>DMA는 CPU를 거치지 않고 I/O 장치가 주 메모리(RAM)에 직접 읽기·쓰기 할 수 있도록 시스템 버스를 “잠깐” 빌려서 데이터 블록을 전송하는 하드웨어 메커니즘</p>

<h2 id="왜-dma가-필요한가">왜 DMA가 필요한가?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">문제점(전통적 PIO)</th>
      <th style="text-align: center">DMA가 주는 이점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">CPU가 I/O 레지스터를 통해 바이트 단위로 데이터를 옮기면 레이턴시·오버헤드가 큼</td>
      <td style="text-align: center">한 번에 수십~수천 바이트 블록을 메모리로 직행 ⇒ CPU cycles 절약</td>
    </tr>
    <tr>
      <td style="text-align: center">빠른 장치(SSD, 10 GbE NIC 등)는 CPU 속도보다 I/O 대역폭이 큼 → CPU가 “목”이 됨</td>
      <td style="text-align: center">DMA 엔진이 버스 마스터로 동작해 메모리 버스를 직접 차단·사용</td>
    </tr>
    <tr>
      <td style="text-align: center">멀티코어 시대에 CPU는 계산에 집중하고 싶음</td>
      <td style="text-align: center">CPU는 전송 시작/종료만 관리 → I/O wait 시간 줄고, 캐시 miss도 감소</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>덕분에 대역폭·지연시간 모두 절감, 특히 디스크 I/O, 네트워크 카드, 오디오 스트리밍처럼 폭이 넓고 반복적인 전송에 필수적이다</li>
</ul>

<h2 id="기본-구성-요소">기본 구성 요소</h2>

<ol>
  <li>
    <p>DMA 컨트롤러(DMAC)</p>

    <ul>
      <li>
        <p>전용 칩(고전 ISA-DMA) 또는 주변장치 내부 DMA 엔진(PCIe, NVMe 컨트롤러)</p>
      </li>
      <li>
        <p>소스/목적지 물리 주소, 전송 길이, 모드, 제어 플래그 등을 저장하는 레지스터(메모리 맵 레지스터) 보유</p>
      </li>
      <li>
        <p>여러 채널이 있으면 동시에 여러 장치 지원</p>
      </li>
    </ul>
  </li>
  <li>
    <p>시스템 버스</p>

    <ul>
      <li>
        <p>CPU ↔ 메모리 ↔ DMA 컨트롤러가 공유</p>
      </li>
      <li>
        <p>CPU와 DMAC가 동시에 쓰지 않도록 <strong>버스 중재(bus arbitration)</strong> 를 수행</p>
      </li>
    </ul>
  </li>
  <li>
    <p>메모리 버스</p>

    <ul>
      <li>DMAC가 버스 마스터(master) 권한을 요청(Bus Request, BR) → 메모리와 직접 주고받음</li>
    </ul>
  </li>
  <li>
    <p>주변장치(Device)</p>

    <ul>
      <li>디스크, NIC, GPU, 오디오 코드 … 데이터가 실제로 존재/필요한 곳</li>
    </ul>
  </li>
  <li>
    <p>CPU &amp; OS</p>

    <ul>
      <li>전송 파라미터를 DMAC 레지스터에 써 주고, 완료 인터럽트(DMA done)를 처리</li>
    </ul>
  </li>
  <li>
    <p>I/O 장치(버스 마스터 가능 장치)</p>

    <ul>
      <li>PCIe NIC, NVMe SSD, GPU 등은 자체 DMA 엔진을 내장해 버스 마스터 가 되기도 한다</li>
    </ul>
  </li>
</ol>

<h3 id="dma-레지스터-src-dst-len">DMA 레지스터 SRC, DST, LEN</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">레지스터</th>
      <th style="text-align: center">역할</th>
      <th style="text-align: center">일반적 크기</th>
      <th style="text-align: center">세부 사항</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">SRC (Source Address)</td>
      <td style="text-align: center">읽어 올 원본 주소. 장치 → RAM 전송이면 장치 쪽 FIFO 주소, RAM → 장치 전송이면 RAM의 시작 주소</td>
      <td style="text-align: center">32 bit(SoC) 또는 64 bit(서버)</td>
      <td style="text-align: center">* 버스트·비버스트 여부, 버스트 길이에 따라 자동 증가(inc) 여부 선택 플래그 존재<br />* Scatter-Gather 모드에선 “다음 표(list) 항목” 주소로 해석되기도 함</td>
    </tr>
    <tr>
      <td style="text-align: center">DST (Destination Address)</td>
      <td style="text-align: center">쓰기 대상 주소</td>
      <td style="text-align: center">32/64 bit</td>
      <td style="text-align: center">* 자동 증가/고정 선택 가능 (예: 오디오 DAC 같은 스트리밍 장치는 고정 주소, 메모리 버퍼는 증가)</td>
    </tr>
    <tr>
      <td style="text-align: center">LEN (Length / Count)</td>
      <td style="text-align: center">총 바이트(혹은 워드) 수</td>
      <td style="text-align: center">16 bit(65 kB) ~ 32 bit(4 GB) 이상</td>
      <td style="text-align: center">* 전송이 끝날 때마다 LEN–; 0 → 인터럽트 발생<br />* 어떤 컨트롤러는 LEN 대신 COUNT×DATA_WIDTH 형태 사용</td>
    </tr>
  </tbody>
</table>

<p><strong>요약</strong> : SRC·DST는 “어디서 → 어디로”를, LEN은 “얼마나”를 알려주는 좌표 + 거리 정보라고 생각하면 된다</p>

<h2 id="동작-흐름-x86-pc-예시">동작 흐름 (x86 PC 예시)</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">신호선 &amp; 동작</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">① CPU 설정</td>
      <td style="text-align: center">DMAC 레지스터에 &lt;소스, 목적지, 길이, 모드&gt; 기록 후 Bus Request(BR) 활성화</td>
    </tr>
    <tr>
      <td style="text-align: center">② 버스 획득</td>
      <td style="text-align: center">CPU가 <em>Bus Grant(BG)</em>로 응답 → CPU 파이프라인이 버스를 놓고 다른 연산(레지스터 계산 등) 수행</td>
    </tr>
    <tr>
      <td style="text-align: center">③ 데이터 전송</td>
      <td style="text-align: center">DMAC가 메모리 ↔ 장치 간 버스 싸이클 생성</td>
    </tr>
    <tr>
      <td style="text-align: center">④ 완료 인터럽트</td>
      <td style="text-align: center">전송 길이가 0이 되면 DMAC가 CPU에 DMA 완료 인터럽트. CPU는 이후 버스 재획득</td>
    </tr>
  </tbody>
</table>

<p><strong>중요</strong> : DMAC가 버스를 잡은 동안 메모리 전체 버스 주도권을 갖기 때문에 CPU는 RAM을 전혀 접근하지 못한다. 개별 “주소 권한”이 아닌 “버스 소유권”의 문제다. 이 때문에 짝수 클럭마다 한 워드만 빼앗고 바로 돌려주는 Cycle Stealing 모드가 등장했다</p>

<h3 id="동작-흐름-더-자세히">동작 흐름 더 자세히</h3>

<p><img src="/assets/img/blog/computerscience/dma.png" alt="DMA" /></p>

<h4 id="1-단계---cpu까-준비만-하고-손을-뗀다">1 단계 - CPU까 준비만 하고 손을 뗀다</h4>

<ol>
  <li>
    <p>전송 파라미터 설정</p>

    <ul>
      <li>
        <p>SRC, DST, LEN, MODE을 레지스터에 값을 써 넣습니다</p>
      </li>
      <li>
        <p>마지막으로 Enable 플래그를 1로 두면 DMAC가 “이제 내가 처리할게!”하고 대기</p>
      </li>
    </ul>
  </li>
  <li>
    <p>버스 요청(BR 신호)</p>

    <ul>
      <li>DMAC는 버스 중재기(arbiter)에게 “버스 좀 빌려주세요” 라고 손을 듦</li>
    </ul>
  </li>
</ol>

<h4 id="2-단계---버스-소유권-교환">2 단계 - 버스 소유권 교환</h4>

<ol>
  <li>
    <p>CPU → DMAC ‘Bus Grant(BG)’</p>

    <ul>
      <li>
        <p>CPU가 진행 중인 버스 싸이클을 마치면 주소·데이터 라인을 tristate해 두고 계산 같은 비-버스 작업에 집중함</p>

        <ul>
          <li>
            <p>tristate란, 여러개의 마스터(CPU, DMAC, GPU…)가 하나의 전선을 공유하고, 한 쪽이 0V, 다른쪽이 동시에 Vcc를 내보내면 단락(short) 위험을 방지하고자 버스를 넘겨받은 쪽만 드라이버를 켜고 나머지는 Hi-Z로 물러나야 함</p>
          </li>
          <li>
            <p>버스가 필요 없는 작업이란, 파이프라인이 레지스터와 내부 캐시 만으로 실행 가능한 명령들</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>DMAC가 버스 장악</p>

    <ul>
      <li>
        <p>이 순간부터 RAM과 I/O 장치 사이를 오가는 모든 신호는 DMAC가 생성</p>
      </li>
      <li>
        <p>CPU는 RAM을 못 만지기 때문에 캐시 miss가 나도 대기해야 함</p>
      </li>
    </ul>
  </li>
</ol>

<h4 id="3-단계---실제-데이터-이동">3 단계 - 실제 데이터 이동</h4>

<ol>
  <li>
    <p>전송 모드에 따른 사이클</p>

    <ul>
      <li>
        <p>Burst/Block : LEN만큼 연속으로 → 최고속, 대신 CPU 길게 정지</p>
      </li>
      <li>
        <p>Cycle-Stealing : 한 사이클씩 “훔치고” 바로 돌려줌 → 실시간 오디어/비디오</p>
      </li>
      <li>
        <p>Scatter-Gather : 메모리 리스트 따라 다중 블록 자동 전송 → NVMe·NIC</p>
      </li>
    </ul>
  </li>
  <li>
    <p>주소·카운터 자동 증가</p>

    <ul>
      <li>DMAC 내부 카운터가 0이 될 때까지 SRC++, DST++, LEN–</li>
    </ul>
  </li>
</ol>

<h4 id="4-단계---전송-완료-알림">4 단계 - 전송 완료 알림</h4>

<ol>
  <li>
    <p>DMA 완료 인터럽트</p>

    <ul>
      <li>
        <p>LEN==0 → DMAC가 IRQ를 날리고 버스 요청을 내림</p>
      </li>
      <li>
        <p>CPU는 인터럽트 핸들러에서 데이터 후처리(예: 패킷 파싱, 디스크 블록 체크섬) 수행</p>
      </li>
    </ul>
  </li>
  <li>
    <p>버스 복귀</p>

    <ul>
      <li>Arbiter가 다시 CPU에 ‘Bus Grant’ → 평상시 메모리 접근 재개</li>
    </ul>
  </li>
</ol>

<h2 id="전송-모드">전송 모드</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">모드</th>
      <th style="text-align: center">특징</th>
      <th style="text-align: center">사용 예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Cycle-Stealing</td>
      <td style="text-align: center">버스 싸이클 1 개만 “훔친” 뒤 즉시 CPU에 반환 → CPU 지연 최소</td>
      <td style="text-align: center">실시간 오디오, 비디오 스트림</td>
    </tr>
    <tr>
      <td style="text-align: center">Block/Burst</td>
      <td style="text-align: center">전체 블록(혹은 버스트) 한 번에 전송 → 가장 빠르지만 CPU 길게 정지</td>
      <td style="text-align: center">SATA, SDIO, 대부분의 PCIe 장치</td>
    </tr>
    <tr>
      <td style="text-align: center">Demand/Scatter-Gather</td>
      <td style="text-align: center">장치가 필요할 때마다, 혹은 메모리 리스트 기반 다중 블록 이동</td>
      <td style="text-align: center">고성능 NIC, NVMe SSD, GPU VRAM 업로드</td>
    </tr>
  </tbody>
</table>

<h2 id="현대-시스템에서의-dma-변화">현대 시스템에서의 DMA 변화</h2>

<ol>
  <li>
    <p>PCIe Bus mastering - 주변장치가 메인 메모리를 완전히 “빌려” 직접 읽고/쓴다</p>
  </li>
  <li>
    <p>IOMMU(DMA-Remapping) - 가상화·보안 목적. 장치가 접근 가능한 주소를 OS가 테이블로 전환 → 버퍼 오염·DMA 공격 방어</p>
  </li>
  <li>
    <p>Cache coherency 문제 - CPU 캐시에 남은 더러운(line dirty) 데이터 vs DMA가 본 메모리 불일치. 해결 : dma_sync_*() - (Linux)·Cache flush, non-cacheable region, snoopint 버스.</p>
  </li>
  <li>
    <p>Zero-copy - 네트워크 스택이나 GPU ↔ CPU 사이에서 “복사 없는” 파이프라인 구축 (DPDK, RDMA, CUDA cudaMemcpyAsync 등)</p>

    <ul>
      <li>운영체제 버퍼를 추가로 “복사(copy)”하지 않고, 장치 ↔ 응용이 같은 메모리 페이지를 공유하도록 하는 기법. CPU가 불필요한 memcpy()를 안 하므로 지연과 캐시오염↓</li>
    </ul>
  </li>
  <li>
    <p>RDMA(Remode DMA) - NIC가 원격 호스트의 메모리에까지 DMA 쓰기/읽기를 수행. 커널 네트워크 스택을 우회하여 μs 단위 지연시간을 제공한다. 고속 HPC, 데이터베이스 복제에서 필수</p>
  </li>
</ol>

<h2 id="장점과-단점-요약">장점과 단점 요약</h2>

<p><strong>장점</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- CPU 사용률 감소, 전력 효율 ↑

- 대역폭 활용 극대화(PCIe Gen4 x4 ≈ 8 GB/s 급)

- 실시간 스트리밍 지원(오디오 스터터링 방지 등)
</code></pre></div></div>

<p><strong>단점</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 하드웨어·드라이버 복잡도 증가

- 버스 우선순위 조정 실패 시 CPU 지연 가능

- 캐시 일관성, 보안("DMA 공격") 이슈 처리 필요

    - IOMMU로 보완
</code></pre></div></div>

<h2 id="실무-예시">실무 예시</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">장치</th>
      <th style="text-align: center">DMA 활용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">SSD/NVMe</td>
      <td style="text-align: center">플래시 컨트롤러가 OS 버퍼를 읽어 와 NAND로 쓰기, 반대 방향 읽기</td>
    </tr>
    <tr>
      <td style="text-align: center">10 GbE NIC</td>
      <td style="text-align: center">패킷을 커널 버퍼나 XSP ring으로 직접 놓고, 완료 시 인터럽트</td>
    </tr>
    <tr>
      <td style="text-align: center">GPU</td>
      <td style="text-align: center">대용량 텍스처/버퍼를 PCIe로 복사하거나, VRAM↔CPU RAM pinned transfer</td>
    </tr>
    <tr>
      <td style="text-align: center">Audio Codec</td>
      <td style="text-align: center">PCM 버퍼를 주기적으로 DMA → DAC, 실시간 재생</td>
    </tr>
    <tr>
      <td style="text-align: center">USB 컨트롤러</td>
      <td style="text-align: center">호스트 메모리의 전송 링(Transfer Ring)을 DMA 로 순회</td>
    </tr>
  </tbody>
</table>

<h2 id="운영체제-관점">운영체제 관점</h2>

<ul>
  <li>
    <p>Linux : dma_map_single(), dma_alloc_coherent(), struct dma_async_tx_descriptor, DMAengine 프레임워크</p>
  </li>
  <li>
    <p>Windows : WdfDmaTransaction*, KeFlushIoBuffers(), Scatter/Gather 목록 지원</p>
  </li>
  <li>
    <p>RTOS(FreeRTOS, Zephyr) : MCU마다 별도의 DMAMUX &amp; HAP API 제공</p>
  </li>
</ul>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[여태까지 컴퓨터는 직접 메모리에 대해 접근하지 않고 가상 메모리를 사용하는 것으로 배웠는데, 만약 직접 메모리 접근이 있다면?]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">System Call</title><link href="/blog/computersystem/system-call/" rel="alternate" type="text/html" title="System Call" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>/blog/computersystem/system-call</id><content type="html" xml:base="/blog/computersystem/system-call/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#호출-흐름리눅스-x86-64-예" id="markdown-toc-호출-흐름리눅스-x86-64-예">호출 흐름(리눅스 x86-64 예)</a></li>
  <li><a href="#대표-범주" id="markdown-toc-대표-범주">대표 범주</a></li>
  <li><a href="#언제-볼-수-있을까" id="markdown-toc-언제-볼-수-있을까">언제 볼 수 있을까?</a></li>
  <li><a href="#요약" id="markdown-toc-요약">요약</a>    <ul>
      <li><a href="#나만의-요약" id="markdown-toc-나만의-요약">나만의 요약</a></li>
    </ul>
  </li>
</ul>

<p>응용 프로그램(유저 레벨 코드)이 직접 하드웨어를 만지면 안 되므로, 운영체제(OS)가 대신 해준다. 프로세스가 커널에게 무언가를 “요청”하는 공식 통로가 바로 <strong>System Call</strong>이다.</p>

<ul>
  <li>
    <p>“파일을 열어 줘(open)”, “데이터를 읽어 줘(read)”, “새 프로세스를 만들어 줘(fork)” … 같은 요구 사항을 전달한다</p>
  </li>
  <li>
    <p>커널은 트랩(trap)을 통해 특권 모드(커널 모드)로 올라가 작업을 수행한 뒤, 결과(보통 레지스터 값 또는 errno)를 돌려주고 사용자 모드로 복귀한다</p>
  </li>
</ul>

<h2 id="호출-흐름리눅스-x86-64-예">호출 흐름(리눅스 x86-64 예)</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: left">사용자 공간</th>
      <th style="text-align: left">커널 공간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: left">라이브러리 wrapper 함수 (read(int fd, void *buf, size_t n))</td>
      <td style="text-align: left">-</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: left">시스템 콜 번호와 인수들을 레지스터에 적재하고 syscall(또는 int 0x80) 실행</td>
      <td style="text-align: left">트랩 발생→권한 레벨 전환, 커널 스택 진입</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: left">시스템 콜 디스패처가 번호를 해석해 해당 핸들러(sys_read) 호출</td>
      <td style="text-align: left">핸들러가 실제 I/O 수행, 파일 테이블 등 갱신</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: left">반환값을 레지스터에 넣고 sysret</td>
      <td style="text-align: left">-</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: left">라이브러리 wrapper가 음수면 errno 설정 후 반환</td>
      <td style="text-align: left">-</td>
    </tr>
  </tbody>
</table>

<p>여기서 <strong>컨텍스트 스위치(레지스터·프로그램 카운터·스택 교체)</strong>는 수십 ~ 수백 나노초가 소요되므로, 시스템 콜은 함수 호출보다 느리다</p>

<h2 id="대표-범주">대표 범주</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">범주</th>
      <th style="text-align: left">대표 시스템 콜</th>
      <th style="text-align: left">설명·용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">프로세스 제어</td>
      <td style="text-align: left">fork, execve, waitpid, exit</td>
      <td style="text-align: left">프로세스 생성·변경·종료</td>
    </tr>
    <tr>
      <td style="text-align: center">파일 I/O</td>
      <td style="text-align: left">open/close, read/write, lseek, stat</td>
      <td style="text-align: left">모든 디스크·파이프·소켓 I/O 통일 인터페이스(“Everything is a file”)</td>
    </tr>
    <tr>
      <td style="text-align: center">장치 제어</td>
      <td style="text-align: left">ioctl, mmap, munmap</td>
      <td style="text-align: left">특수 장치 제어, 파일 매핑 등</td>
    </tr>
    <tr>
      <td style="text-align: center">메모리 관리</td>
      <td style="text-align: left">brk, mmap</td>
      <td style="text-align: left">힙 확장(malloc 내부)</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: left">라이브러리 wrapper가 음수면 errno 설정 후 반환</td>
      <td style="text-align: left">-</td>
    </tr>
  </tbody>
</table>

<h2 id="언제-볼-수-있을까">언제 볼 수 있을까?</h2>

<ul>
  <li>
    <p>Windows - MEM_COMMIT 없이 VirtualAlloc으로 예약만 한 뒤 접근할 때, 또는 일반 HeapAlloc/new 내부적으로</p>
  </li>
  <li>
    <p>Linux/Unix - 익명 매핑 mmap(…, MAP_ANONYMOUS)·스택·BSS·brk/sbrk 등</p>
  </li>
  <li>
    <p>하이퍼바이저/가상머신 - 게스트가 처음 쓰는 시점까지 진짜 호스트 RAM을 배정하지 않는 ballooning 기법과 결합되기도 함</p>
  </li>
</ul>

<h2 id="요약">요약</h2>

<p>Demand-zero memory = “필요할 때 0으로 초기화된 물리 페이지를 뒤늦게 붙이는 가상 메모리 기술”</p>

<p>→ 프로그램 입장에서는 ‘이미 0으로 초기화돼 있는 새 메모리’를 즉시 얻은 것처럼 보이지만, 실제 RAM은 첫 사용 시점까지 쓰이지 않아 메모리를 아끼고 보안을 높여 줌</p>

<h3 id="나만의-요약">나만의 요약</h3>

<ol>
  <li>
    <p>물리 메모리 같은 경우 첫 사용 전까지는 메모리 할당이 되지 않음</p>
  </li>
  <li>
    <p>하지만 가상 메모리에서는 공간이 확보된 상태</p>
  </li>
  <li>
    <p>실제 사용시에는 page fault 되면서 물리 메모리 할당이 이루어짐, PTE의 Not-present → Present로 갱신</p>
  </li>
</ol>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[응용프로그램(User level code)이 Hardware를 조작하고 싶을때, 무엇을 할까?]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">수작업으로 Malloc 구현(9.9장)</title><link href="/blog/computersystem/dynamic-memory-allocation/" rel="alternate" type="text/html" title="수작업으로 Malloc 구현(9.9장)" /><published>2025-04-27T00:00:00+00:00</published><updated>2025-04-27T00:00:00+00:00</updated><id>/blog/computersystem/dynamic-memory-allocation</id><content type="html" xml:base="/blog/computersystem/dynamic-memory-allocation/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#malloc-할당" id="markdown-toc-malloc-할당">Malloc 할당</a>    <ul>
      <li><a href="#응용-프로그램" id="markdown-toc-응용-프로그램">응용 프로그램</a></li>
      <li><a href="#allocator" id="markdown-toc-allocator">Allocator</a></li>
      <li><a href="#용어-정리" id="markdown-toc-용어-정리">용어 정리</a></li>
    </ul>
  </li>
  <li><a href="#malloc-할당-기초" id="markdown-toc-malloc-할당-기초">Malloc 할당 기초</a>    <ul>
      <li><a href="#header-탄생" id="markdown-toc-header-탄생">Header 탄생</a></li>
      <li><a href="#footer-탄생" id="markdown-toc-footer-탄생">Footer 탄생</a></li>
      <li><a href="#c-언어로-구현된-malloc" id="markdown-toc-c-언어로-구현된-malloc">C 언어로 구현된 Malloc</a></li>
    </ul>
  </li>
  <li><a href="#명시적-리스트explicit-list에서의-refactoring" id="markdown-toc-명시적-리스트explicit-list에서의-refactoring">명시적 리스트(Explicit list)에서의 refactoring</a>    <ul>
      <li><a href="#refactoring-함수" id="markdown-toc-refactoring-함수">Refactoring 함수</a></li>
      <li><a href="#개선된-case-4" id="markdown-toc-개선된-case-4">개선된 Case 4</a></li>
    </ul>
  </li>
</ul>

<p>말록 구현에 앞서, <strong>명시적 할당자(Explicit allocator)</strong>와 <strong>묵시적 할당자(Implicit allocator)</strong>에 대해 알아 보자</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Explicit allocator</th>
      <th style="text-align: center">Implicit allocator</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">사용 예</td>
      <td style="text-align: center">C언어에서 malloc 할당과 free</td>
      <td style="text-align: center">Java의 garbage collection, ML, and Lisp</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>free 수행에 관해서 직접적인지 또는 간접적인지에 따라서 달라진다</li>
</ul>

<p><strong>Malloc</strong>에 관하여서는 이전에 포스팅한 <a href="../../c/malloc-calloc-realloc" class="heading flip-title">동적 메모리 할당(Dynamic memory allocation)</a> 을 참조하면 된다</p>

<p>여기서 다룰 내용은 <strong>Explicit allocator</strong>인 malloc 할당을 직접 구현할 예정이다</p>

<h2 id="malloc-할당">Malloc 할당</h2>

<p><img src="/assets/img/blog/computerscience/mallocallocation.png" alt="말록 할당" /></p>

<p>위 사진의 순서 같은 경우 아래와 같다</p>

<ol>
  <li>
    <p>p1(int사이즈X4) 할당</p>
  </li>
  <li>
    <p>p2(int사이즈X5) 할당</p>
  </li>
  <li>
    <p>p3(int사이즈X6) 할당</p>
  </li>
  <li>
    <p>p2 free</p>
  </li>
  <li>
    <p>p4(int사이즈X2) 할당</p>
  </li>
</ol>

<h3 id="응용-프로그램">응용 프로그램</h3>

<ul>
  <li>
    <p>응용프로그램 같은 경우 마음대로 malloc 할당과 free 요청이 가능하다</p>
  </li>
  <li>
    <p>free 할 시에는 malloc된 block이어야 한다</p>
  </li>
</ul>

<h3 id="allocator">Allocator</h3>

<p>명시적 할당기들은 아래와 같은 엄격한 제한사항 내에서 동작해야 함</p>

<ul>
  <li>
    <p>할당된 블럭의 갯수와 크기에 대한 관리 권한이 없다</p>
  </li>
  <li>
    <p>malloc 요청에 즉각 반응해야 함</p>

    <ul>
      <li>이 뜻은 추후 할당에 대해 대기가 불가능하다는 것이다</li>
    </ul>
  </li>
  <li>
    <p>free된 메모리에서만 할당이 가능하다</p>
  </li>
  <li>
    <p>block의 크기에 대해서 정렬 요구사항에 맞추어야 한다</p>

    <ul>
      <li>
        <p>리눅스 기준 아래와 같다</p>
      </li>
      <li>
        <p>x86 : 8byte, x86-64 : 16byte</p>
      </li>
    </ul>
  </li>
  <li>
    <p>free블록에 관해서만 조작이 가능하다</p>
  </li>
  <li>
    <p>일단 malloc할당 되었으면, 움직일 수 없다</p>

    <ul>
      <li>이 말은 압축이 불가능하다는 이야기</li>
    </ul>
  </li>
</ul>

<h3 id="용어-정리">용어 정리</h3>

<p><img src="/assets/img/blog/computerscience/blockdefinition.png" alt="블록 용어 정리" /></p>

<ul>
  <li>
    <p>Throughput : 시간당 완료된 요청의 갯수 (5000의 malloc할당과 5000의 free요청을 10초 안에 완수하면, 1000operations/second)</p>
  </li>
  <li>
    <p>Payload : 블럭 안에서 실제로 사용할 Data</p>
  </li>
  <li>
    <p>Overhead : 블럭 안에서 payload 제외한 나머지(header, footer, padding)</p>
  </li>
  <li>
    <p>Aggregate payload : 할당된 블럭들의 Data들의 총합</p>
  </li>
  <li>
    <p>최고 이용도(Peak utilization) : 할당기가 힙을 얼마나 효율적으로 사용하는지를 규정하는 많은 방법들 중 하나</p>

    <ul>
      <li>
        <p>Pk는 현재 할당된 블록들의 데이터들의 합, Hk는 현재 힙의 크기</p>
      </li>
      <li>
        <p>수식(높은것이 좋다) :
\(U_k = \frac{\max_{i \le k} P_i}{H_k}\)</p>
      </li>
    </ul>
  </li>
  <li>
    <p>내부 단편화(Internal fragmentation) : Overhead나 padding에 의해서 발생되는데, 블록 내부에서 메모리를 효율적으로 관리하지 못하는 것</p>
  </li>
</ul>

<p><img src="/assets/img/blog/computerscience/externalfragmentation.png" alt="외부 단편화" /></p>

<ul>
  <li>외부 단편화(External fragmentation) : 가용 블록의 합들은 충분하지만, 가용 블록에 할당할 적당한 크기가 없게 관리가 된것</li>
</ul>

<h2 id="malloc-할당-기초">Malloc 할당 기초</h2>

<h3 id="header-탄생">Header 탄생</h3>

<p>우리가 포인터를 사용해서 블럭과 블럭을 건너뛰기 위해서는 어떻게 해야 할까? payload가 어디서부터 시작하지? 어디까지 읽어야 하지?</p>

<p>라는 의문에서 탄생한 개념이 ‘<strong>header라는 overhead를 만들어서 거기에 block의 사이즈를 넣으면 어떨까?</strong>’ 이다</p>

<ol>
  <li>
    <p>header를 사용해서 각 블럭의 처음으로 순차적으로 탐색이 가능해 졌다</p>

    <ul>
      <li>
        <p>그러면 header를 어디에 할당을 할까?</p>

        <ul>
          <li>
            <p>규칙이야 만들면 그만이지만, 책에서는 특정 주소를 받으면 payload 시작 주소를 받기로 했다</p>
          </li>
          <li>
            <p>payload 주소를 먼저 받게 되면, 그 앞에 overhead를 추가하기로 했다</p>
          </li>
        </ul>
      </li>
      <li>
        <p>그러면 태초의 주소를 받게 되면, 앞이 없기 때문에 overhead를 못 넣지 않은가?</p>

        <ul>
          <li>그렇기 때문에 우리는 첫 주소에 항상 overhead용 padding을 해줘야 한다</li>
        </ul>
      </li>
    </ul>
  </li>
</ol>

<p><img src="/assets/img/blog/computerscience/header.png" alt="헤더" /></p>

<p>여기서 추가적으로 우리는 가용 블록 or 비가용 블록인지 확인이 필요하다. 
그 이유는 할당 블럭에 다른 용도로 또 할당을 하면 안되기 때문.</p>

<p>32bit 기준으로 8byte기준, 64bit system으로는 16byte 정렬이 됨(여기서 정렬이라 하는것은 정렬만큼 최소크기로 블럭을 관리하겠다는 얘기이다)
그렇게 되면 3bit 또는 4bit는 항상 0으로 남게 된다.</p>

<ol>
  <li>
    <p>남게 되는 bit들을 이용해 다른 정보들을 저장하자</p>

    <ul>
      <li>
        <p>overhead를 읽을 때 첫 3bit or 4bit를 제외하고 읽고 3bit or 4bit를 따로 읽는것이다. 그렇게 되면 block size와 다른 정보들이 나오게 된다.</p>
      </li>
      <li>
        <p>책에서는 32bit system을 사용해서 3bit가 남고 가장 첫번째 bit에 가용/비가용(1/0)으로 구분하기로 했다</p>
      </li>
    </ul>
  </li>
</ol>

<p><img src="/assets/img/blog/computerscience/headerwithalloc.png" alt="헤더" /></p>

<h3 id="footer-탄생">Footer 탄생</h3>

<p>할당을 하면서 Free도 하게 될텐데, 그렇게 되면 Free블록이 연속될 수 있다.
아래와 같은 사진을 보면 4사이즈 가용 블럭과 2사이즈 가용 블럭이 연속된다
이 상황에서 5사이즈 블럭을 할당하고자 할 때, 할당이 되지 않는 상황(외부 단편화)이 발생한다.</p>

<p><img src="/assets/img/blog/computerscience/sequentialfreeblock.png" alt="연속된 가용 블럭" /></p>

<p>할당이 되지 않는 이유는 코드상 ‘할당하려는 크기보다 같거나 큰 블럭을 찾게 되어 있어서’이다. 
여기서 다른 방법을 생각할 수도 있지만, 코드를 유지하면서 방법을 생각해보자.</p>

<ol>
  <li>
    <p>연속된 가용 블럭이 나오지 않게 하자</p>

    <ul>
      <li>
        <p>만약 연속된 가용 블럭이 없으면 아쉽지도 않을 것이다</p>
      </li>
      <li>
        <p>그렇다면 어떻게 가용 블럭이 연속되지 않게 할까?</p>
      </li>
    </ul>
  </li>
  <li>
    <p>할당된 블럭을 free 할때 앞과 뒤에 가용 블럭이 있다면 병합을 하자</p>

    <ul>
      <li>
        <p>뒤에 블록 같은 경우 현재 header에서 사이즈를 더해 확인이 가능</p>
      </li>
      <li>
        <p>앞 블록 같은 경우 사이즈를 모름 → <strong>footer 도입</strong>해서 블럭뒤에 블럭의 크기와 가용/비가용 정보를 저장</p>
      </li>
      <li>
        <p>병합같은 경우 free하고 병합(coalesce)진행</p>
      </li>
    </ul>
  </li>
  <li>
    <p>(extra) Footer같은 경우 overhead이기 때문에 없는게 좋다. 그렇다면 모든 블럭에 footer가 필요할까?</p>

    <ul>
      <li>
        <p>아까 정렬에 따라 3 ~ 4bit가 남는다고 했다. 여기에는 현재 블록의 가용/비가용 정보가 들어가는데, 앞블럭의 가용/비가용 정보를 넣자</p>
      </li>
      <li>
        <p>앞블럭의 가용/비가용 정보가 있으면, 가용 블럭에만 footer가 필요하고 할당된 블럭에는 footer가 필요 없게 된다</p>
      </li>
    </ul>
  </li>
</ol>

<h3 id="c-언어로-구현된-malloc">C 언어로 구현된 Malloc</h3>

<p>내가 직접 구현하지 않고 CS:APP 교제를 통해 구할 수 있게 되었다. 묵시적 list에 first-fit 할당이다</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * mm-naive.c - The fastest, least memory-efficient malloc package.
 *
 * In this naive approach, a block is allocated by simply incrementing
 * the brk pointer.  A block is pure payload. There are no headers or
 * footers.  Blocks are never coalesced or reused. Realloc is
 * implemented directly using mm_malloc and mm_free.
 *
 * NOTE TO STUDENTS: Replace this header comment with your own header
 * comment that gives a high level description of your solution.
 */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"mm.h"</span><span class="cp">
#include</span> <span class="cpf">"memlib.h"</span><span class="cp">
</span>
<span class="cm">/*********************************************************
 * NOTE TO STUDENTS: Before you do anything else, please
 * provide your team information in the following struct.
 ********************************************************/</span>
<span class="n">team_t</span> <span class="n">team</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* Team name */</span>
    <span class="s">"ateam"</span><span class="p">,</span>
    <span class="cm">/* First member's full name */</span>
    <span class="s">"Harry Bovik"</span><span class="p">,</span>
    <span class="cm">/* First member's email address */</span>
    <span class="s">"bovik@cs.cmu.edu"</span><span class="p">,</span>
    <span class="cm">/* Second member's full name (leave blank if none) */</span>
    <span class="s">""</span><span class="p">,</span>
    <span class="cm">/* Second member's email address (leave blank if none) */</span>
    <span class="s">""</span><span class="p">};</span>

<span class="cm">/* single word (4) or double word (8) alignment */</span>
<span class="cp">#define ALIGNMENT 8
#define WSIZE 4 </span><span class="cm">/* header/footer size */</span><span class="cp">
#define DSIZE 8 </span><span class="cm">/* double word size */</span><span class="cp">
#define CHUNKSIZE (1 &lt;&lt; 12) </span><span class="cm">/* Extend heap by this amount (bytes) */</span><span class="cp">
</span>
<span class="cp">#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))
</span>
<span class="cm">/* Pack a size and allocated bit into a word */</span>
<span class="cp">#define PACK(size, alloc) ((size) | (alloc))
</span>
<span class="cm">/* Read and write a word at address p */</span>
<span class="cp">#define GET(p) (*(unsigned int *)(p))
#define PUT(p, val) (*(unsigned int *)(p) = (val))
</span>
<span class="cm">/* Read the size and allocated fields from address p */</span>
<span class="cp">#define GET_SIZE(p) (GET(p) &amp; ~0x7)
#define GET_ALLOC(p) (GET(p) &amp; 0x1)
</span>
<span class="cm">/* Given block ptr bp, compute address of its header and footer */</span>
<span class="cp">#define HDRP(bp) ((char *)(bp) - WSIZE)
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - DSIZE)
</span>
<span class="cm">/* Given block ptr bp, compute address of next and previous blocks */</span>
<span class="cp">#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp)-WSIZE)))
#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp)-DSIZE)))
</span>
<span class="cm">/* rounds up to the nearest multiple of ALIGNMENT */</span>
<span class="cp">#define ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0x7)
</span>
<span class="cp">#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))
</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">heap_listp</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">mm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">extend_heap</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">words</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">find_fit</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">asize</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">place</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">asize</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">coalesce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>


<span class="cm">/*
 * mm_init - initialize the malloc package.
 */</span>
<span class="kt">int</span> <span class="nf">mm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Create the initial empty heap */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">heap_listp</span> <span class="o">=</span> <span class="n">mem_sbrk</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">WSIZE</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">heap_listp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">heap_listp</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">WSIZE</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">DSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">heap_listp</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">WSIZE</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">DSIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">heap_listp</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">WSIZE</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">heap_listp</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">WSIZE</span><span class="p">);</span>
    <span class="c1">// next_ptr = heap_listp; /* Reset next_ptr to NULL */</span>

    <span class="cm">/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">extend_heap</span><span class="p">(</span><span class="n">CHUNKSIZE</span><span class="o">/</span><span class="n">WSIZE</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">extend_heap</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

    <span class="cm">/* Allocate an even number of words to maintain alignment */</span>
    <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">words</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">words</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">WSIZE</span> <span class="o">:</span> <span class="n">words</span> <span class="o">*</span> <span class="n">WSIZE</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="n">bp</span> <span class="o">=</span> <span class="n">mem_sbrk</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* Initialize free block header/footer and the epilogue header */</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="cm">/* Free block header */</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="cm">/* Free block footer */</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span> <span class="cm">/* New epilogue header */</span>


    <span class="cm">/* Coalesce if the previous block was free */</span>
    <span class="k">return</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
 * mm_malloc - Allocate a block by incrementing the brk pointer.
 *     Always allocate a block whose size is a multiple of the alignment.
 */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">mm_malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">asize</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">extendsize</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">bp</span><span class="p">;</span>

    <span class="cm">/* Ignore spurious requests */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    
    <span class="cm">/* Adjust block size to include overhead and alignment reqs. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">DSIZE</span><span class="p">)</span>
        <span class="n">asize</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">DSIZE</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">asize</span> <span class="o">=</span> <span class="n">DSIZE</span> <span class="o">*</span> <span class="p">((</span><span class="n">size</span> <span class="o">+</span> <span class="n">DSIZE</span> <span class="o">+</span> <span class="p">(</span><span class="n">DSIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">/</span> <span class="n">DSIZE</span><span class="p">);</span>

    <span class="cm">/* Search the free list for a fit */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">bp</span> <span class="o">=</span> <span class="n">find_fit</span><span class="p">(</span><span class="n">asize</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">place</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">asize</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* No fit found. Get more memory and place the block */</span>
    <span class="n">extendsize</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">asize</span><span class="p">,</span> <span class="n">CHUNKSIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">bp</span> <span class="o">=</span> <span class="n">extend_heap</span><span class="p">(</span><span class="n">extendsize</span><span class="o">/</span><span class="n">WSIZE</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">place</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">asize</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">find_fit</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">asize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* First-fit search */</span>

    <span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="n">heap_listp</span><span class="p">;</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bp</span> <span class="o">=</span> <span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">asize</span> <span class="o">&lt;=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">))))</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">place</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">asize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">csize</span> <span class="o">=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">csize</span> <span class="o">-</span> <span class="n">asize</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">DSIZE</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">asize</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">asize</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">csize</span><span class="o">-</span><span class="n">asize</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">csize</span><span class="o">-</span><span class="n">asize</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">csize</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">csize</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
 * mm_free - Freeing a block does nothing.
 */</span>
<span class="kt">void</span> <span class="nf">mm_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>

    <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="cm">/* 헤더에 동일한 사이즈와 할당되지 않은 정보로 update */</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="cm">/* 푸터에 동일한 사이즈와 할당되지 않은 정보로 update */</span>
    <span class="n">coalesce</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="cm">/* free 끼리 병합 */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">coalesce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">prev_alloc</span> <span class="o">=</span> <span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
    <span class="kt">size_t</span> <span class="n">next_alloc</span> <span class="o">=</span> <span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="n">next_alloc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>

    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">next_alloc</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="n">next_alloc</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)))</span> <span class="o">+</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
 * mm_realloc - Implemented simply in terms of mm_malloc and mm_free
 */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">mm_realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">oldptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">newptr</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">copySize</span><span class="p">;</span>

    <span class="n">newptr</span> <span class="o">=</span> <span class="n">mm_malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">newptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">copySize</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">size_t</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">oldptr</span> <span class="o">-</span> <span class="n">SIZE_T_SIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">copySize</span><span class="p">)</span>
        <span class="n">copySize</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">newptr</span><span class="p">,</span> <span class="n">oldptr</span><span class="p">,</span> <span class="n">copySize</span><span class="p">);</span>
    <span class="n">mm_free</span><span class="p">(</span><span class="n">oldptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">newptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이 코드로 돌려보니 아래와 같은 결과가 나왔다
<img src="/assets/img/blog/computerscience/implicitfirst.png" alt="묵시적 first-fit 결과" /></p>

<p>그 다음으로는 묵시적에서 제일 빠르다는 next-fit을 구현해 보았다</p>

<p>바뀐 부분은 아래에 정리했다</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">next_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// 전역변수로 선언</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">extend_heap</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

    <span class="cm">/* Allocate an even number of words to maintain alignment */</span>
    <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">words</span> <span class="o">%</span> <span class="mi">2</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">words</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">WSIZE</span> <span class="o">:</span> <span class="n">words</span> <span class="o">*</span> <span class="n">WSIZE</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="n">bp</span> <span class="o">=</span> <span class="n">mem_sbrk</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* Initialize free block header/footer and the epilogue header */</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="cm">/* Free block header */</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="cm">/* Free block footer */</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span> <span class="cm">/* New epilogue header */</span>
    <span class="n">next_ptr</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span> <span class="cm">/* Set next_ptr to the new block */</span>

    <span class="cm">/* Coalesce if the previous block was free */</span>
    <span class="k">return</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">find_fit</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">asize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="n">next_ptr</span><span class="p">;</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">bp</span> <span class="o">=</span> <span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">asize</span> <span class="o">&lt;=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">))))</span>
        <span class="p">{</span>
            <span class="n">next_ptr</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
            <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">coalesce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">prev_alloc</span> <span class="o">=</span> <span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
    <span class="kt">size_t</span> <span class="n">next_alloc</span> <span class="o">=</span> <span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="n">next_alloc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>

    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">next_alloc</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="n">next_alloc</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)))</span> <span class="o">+</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">next_ptr</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>바뀐 코드중에 보면 사실 coalesce에 next_ptr을 free한 블럭에 넣는것은 next-fit 개념에 어긋난다. 하지만, test case가 조금 많은 편이어서 이렇게 진행을 했다.</p>

<p>결과는 아래와 같이 21점이 올라간것을 확인할 수 있다</p>

<p><img src="/assets/img/blog/computerscience/implicitnext.png" alt="묵시적 next-fit 결과" /></p>

<p>마지막으로 명시적을 구현해 보았다 코드는 아래와 같다</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * mm-naive.c - The fastest, least memory-efficient malloc package.
 *
 * In this naive approach, a block is allocated by simply incrementing
 * the brk pointer.  A block is pure payload. There are no headers or
 * footers.  Blocks are never coalesced or reused. Realloc is
 * implemented directly using mm_malloc and mm_free.
 *
 * NOTE TO STUDENTS: Replace this header comment with your own header
 * comment that gives a high level description of your solution.
 */</span>
<span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"mm.h"</span><span class="cp">
#include</span> <span class="cpf">"memlib.h"</span><span class="cp">
</span>
<span class="cm">/*********************************************************
 * NOTE TO STUDENTS: Before you do anything else, please
 * provide your team information in the following struct.
 ********************************************************/</span>
<span class="n">team_t</span> <span class="n">team</span> <span class="o">=</span> <span class="p">{</span>
    <span class="cm">/* Team name */</span>
    <span class="s">"ateam"</span><span class="p">,</span>
    <span class="cm">/* First member's full name */</span>
    <span class="s">"Harry Bovik"</span><span class="p">,</span>
    <span class="cm">/* First member's email address */</span>
    <span class="s">"bovik@cs.cmu.edu"</span><span class="p">,</span>
    <span class="cm">/* Second member's full name (leave blank if none) */</span>
    <span class="s">""</span><span class="p">,</span>
    <span class="cm">/* Second member's email address (leave blank if none) */</span>
    <span class="s">""</span><span class="p">};</span>

<span class="cm">/* single word (4) or double word (8) alignment */</span>
<span class="cp">#define ALIGNMENT 16
#define WSIZE 4 </span><span class="cm">/* header/footer size */</span><span class="cp">
#define PTR_SIZE sizeof(void *) </span><span class="cm">/* pointer size */</span><span class="cp">
#define MIN_FREE_BLOCK_SIZE (WSIZE + PTR_SIZE + PTR_SIZE + WSIZE)
#define CHUNKSIZE (1 &lt;&lt; 12) </span><span class="cm">/* Extend heap by this amount (bytes) */</span><span class="cp">
</span>
<span class="cp">#define MAX(x, y) ((x) &gt; (y) ? (x) : (y))
</span>
<span class="cm">/* Pack a size and allocated bit into a word */</span>
<span class="cp">#define PACK(size, alloc) ((size) | (alloc))
</span>
<span class="cm">/* Read and write a word at address p */</span>
<span class="cp">#define GET(p) (*(unsigned int *)(p))
#define PUT(p, val) (*(unsigned int *)(p) = (val))
</span>
<span class="cm">/* Read the size and allocated fields from address p */</span>
<span class="cp">#define GET_SIZE(p) (GET(p) &amp; ~0x7)
#define GET_ALLOC(p) (GET(p) &amp; 0x1)
</span>
<span class="cm">/* Given block ptr bp, compute address of its header and footer */</span>
<span class="cp">#define HDRP(bp) ((char *)(bp) - WSIZE)
#define FTRP(bp) ((char *)(bp) + GET_SIZE(HDRP(bp)) - (WSIZE*2))
</span>
<span class="cm">/* Given block ptr bp, compute address of next and previous blocks */</span>
<span class="cp">#define NEXT_BLKP(bp) ((char *)(bp) + GET_SIZE(((char *)(bp)-WSIZE)))
#define PREV_BLKP(bp) ((char *)(bp) - GET_SIZE(((char *)(bp)-(WSIZE*2))))
</span>
<span class="cp">#define NEXT_FREE(bp) (*(void **)(bp)) // bp를 형변환 한거야 이중연결리스트로 그래서 bp가 가르키는 메모리공간에 다른블록을 가르키는 포인터가 생겨버리는거지 그걸 역참조해서 NEXT_FREE(bp)는 bp안에 다른블록을 가르키는 포인터의 값을 나타 내는 아이가 된거야.
#define PREV_FREE(bp) (*(void **)((char *)(bp) + PTR_SIZE)) // 그럼이것도 NEXT_FREE와 비슷하지만 한가지 다른게 bp의 시작주소 payload가 가르키는 메모리공간이 아니라 payload에다 4를 더한 주소에 prev_free를 저장하거나 읽는거야
</span>
<span class="cp">#define SET_NEXT_FREE(bp, ptr) (NEXT_FREE(bp) = (ptr)) // 그럼 이건 위에는 포인터주소에 역참조한 상황이니까 거기에다가 ptr이라는 주소값을 넣은거지 즉 next인 주소를 넣은거지
#define SET_PREV_FREE(bp, ptr) (PREV_FREE(bp) = (ptr)) // 현재 가르키는 블록의 payload+wsize 위치에 이전 free블록의 주소를 저장하는거지
</span>
<span class="c1">// #define NEXT_FRPTR(bp) (bp)</span>
<span class="cp">#define PREV_FRPTR(bp) ((char *)(bp) + GET_SIZE(((char *)(bp)+(WSIZE*2))))
</span>
<span class="cm">/* rounds up to the nearest multiple of ALIGNMENT */</span>
<span class="cp">#define ALIGN(size) (((size) + (ALIGNMENT - 1)) &amp; ~0xf)
</span>
<span class="cp">#define SIZE_T_SIZE (ALIGN(sizeof(size_t)))
</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="n">free_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* Pointer to the first free block */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="n">heap_listp</span><span class="p">;</span>

<span class="c1">// Helper functions for free list manipulation</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_to_free_list</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_from_free_list</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">mm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">extend_heap</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">words</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">find_fit</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">asize</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">place</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">asize</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">coalesce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">);</span>


<span class="cm">/*
 * mm_init - initialize the malloc package.
 */</span>
<span class="kt">int</span> <span class="nf">mm_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* Create the initial empty heap */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">heap_listp</span> <span class="o">=</span> <span class="n">mem_sbrk</span><span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="n">WSIZE</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">heap_listp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">heap_listp</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span><span class="o">*</span><span class="n">WSIZE</span><span class="p">),</span> <span class="n">PACK</span><span class="p">((</span><span class="n">WSIZE</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">heap_listp</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">WSIZE</span><span class="p">),</span> <span class="n">PACK</span><span class="p">((</span><span class="n">WSIZE</span><span class="o">*</span><span class="mi">2</span><span class="p">),</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">heap_listp</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span><span class="o">*</span><span class="n">WSIZE</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
    <span class="n">heap_listp</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">WSIZE</span><span class="p">);</span>
    <span class="n">free_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="c1">// next_ptr = heap_listp; /* Reset next_ptr to NULL */</span>

    <span class="cm">/* Extend the empty heap with a free block of CHUNKSIZE bytes */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">extend_heap</span><span class="p">(</span><span class="n">CHUNKSIZE</span><span class="o">/</span><span class="n">WSIZE</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">extend_heap</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">words</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>

    <span class="cm">/* Allocate an even number of words to maintain alignment */</span>
    <span class="c1">// size 계산은 바이트 단위로, ALIGNMENT(16)의 배수로 맞춤</span>
    <span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">words</span> <span class="o">*</span> <span class="n">WSIZE</span><span class="p">);</span> <span class="c1">// words는 WSIZE 단위이므로 총 바이트 계산</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>     <span class="c1">// 최종 크기를 16의 배수로 올림 (이게 더 안전)</span>
    <span class="c1">// size = (words % 2) ? (words + 1) * WSIZE : words * WSIZE; // 원래 로직도 가능은 함</span>

    <span class="k">if</span> <span class="p">((</span><span class="kt">long</span><span class="p">)(</span><span class="n">bp</span> <span class="o">=</span> <span class="n">mem_sbrk</span><span class="p">(</span><span class="n">size</span><span class="p">))</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="cm">/* Initialize free block header/footer and the epilogue header */</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>           <span class="cm">/* Free block header */</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>           <span class="cm">/* Free block footer */</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span> <span class="cm">/* New epilogue header */</span>

    <span class="cm">/* Coalesce if the previous block was free and add block to free list */</span>
    <span class="c1">// free_root 설정 및 포인터 초기화는 coalesce에서 처리</span>
    <span class="k">return</span> <span class="n">coalesce</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
 * mm_malloc - Allocate a block by incrementing the brk pointer.
 *     Always allocate a block whose size is a multiple of the alignment.
 */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">mm_malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">asize</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">extendsize</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span> <span class="n">bp</span><span class="p">;</span>

    <span class="cm">/* Ignore spurious requests */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="kt">size_t</span> <span class="n">needed</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="p">(</span><span class="n">WSIZE</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    
    <span class="cm">/* Adjust block size to include overhead and alignment reqs. */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">needed</span> <span class="o">&lt;=</span> <span class="n">MIN_FREE_BLOCK_SIZE</span><span class="p">)</span>
        <span class="n">asize</span> <span class="o">=</span> <span class="n">MIN_FREE_BLOCK_SIZE</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="n">asize</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">needed</span><span class="p">);</span>

    <span class="cm">/* Search the free list for a fit */</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">bp</span> <span class="o">=</span> <span class="n">find_fit</span><span class="p">(</span><span class="n">asize</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">place</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">asize</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* No fit found. Get more memory and place the block */</span>
    <span class="n">extendsize</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="n">asize</span><span class="p">,</span> <span class="n">CHUNKSIZE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">bp</span> <span class="o">=</span> <span class="n">extend_heap</span><span class="p">(</span><span class="n">extendsize</span><span class="o">/</span><span class="n">WSIZE</span><span class="p">))</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">place</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">asize</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">find_fit</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">asize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* First-fit search */</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">;</span>

    <span class="c1">// free_root (리스트 헤드) 부터 시작해서 NULL 만날 때까지 순회</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">bp</span> <span class="o">=</span> <span class="n">free_root</span><span class="p">;</span> <span class="n">bp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">bp</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="c1">// GET_ALLOC은 필요 없을 수 있음 (free list에는 free 블록만 있어야 함)</span>
        <span class="c1">// 하지만 안전을 위해 남겨둘 수 있음</span>
        <span class="c1">// if (!GET_ALLOC(HDRP(bp)) &amp;&amp; (asize &lt;= GET_SIZE(HDRP(bp))))</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">asize</span> <span class="o">&lt;=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">)))</span> <span class="c1">// 크기만 비교</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">bp</span><span class="p">;</span> <span class="c1">// 적합한 블록 찾음</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* No fit */</span>
<span class="p">}</span>

<span class="c1">// place 함수 수정</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">place</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">asize</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">csize</span> <span class="o">=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
    <span class="c1">// void *cur_free_next = NEXT_FREE(bp); // Helper 사용 시 필요 없어짐</span>
    <span class="c1">// void *cur_free_prev = PREV_FREE(bp); // Helper 사용 시 필요 없어짐</span>

    <span class="c1">// 먼저 free list에서 현재 블록(bp)을 제거</span>
    <span class="n">remove_from_free_list</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">csize</span> <span class="o">-</span> <span class="n">asize</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">MIN_FREE_BLOCK_SIZE</span><span class="p">))</span> <span class="c1">// 분할 가능한 경우</span>
    <span class="p">{</span>
        <span class="c1">// 할당될 부분 설정</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">asize</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">asize</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

        <span class="c1">// 남은 free 부분 설정</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">next_bp</span> <span class="o">=</span> <span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span> <span class="c1">// 남은 블록 포인터</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">next_bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">csize</span> <span class="o">-</span> <span class="n">asize</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">next_bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">csize</span> <span class="o">-</span> <span class="n">asize</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

        <span class="c1">// 남은 free 블록을 free list에 다시 추가</span>
        <span class="n">add_to_free_list</span><span class="p">(</span><span class="n">next_bp</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="c1">// 분할 불가능한 경우 (전체 블록 사용)</span>
    <span class="p">{</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">csize</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">csize</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>
        <span class="c1">// free list에서 이미 제거했으므로 추가 작업 필요 없음</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
 * mm_free - Freeing a block does nothing.
 */</span>
<span class="kt">void</span> <span class="nf">mm_free</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">ptr</span><span class="p">));</span>

    <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="cm">/* 헤더에 동일한 사이즈와 할당되지 않은 정보로 update */</span>
    <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">ptr</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="cm">/* 푸터에 동일한 사이즈와 할당되지 않은 정보로 update */</span>
    <span class="n">coalesce</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span> <span class="cm">/* free 끼리 병합 */</span>
<span class="p">}</span>

<span class="c1">// coalesce 함수 수정 (Helper 함수 사용)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">coalesce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 프롤로그 블록 바로 뒤 또는 에필로그 블록 바로 앞인지 확인하여 FTRP/HDRP 접근 보호</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_blk</span> <span class="o">=</span> <span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">next_blk</span> <span class="o">=</span> <span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

    <span class="c1">// GET_ALLOC은 헤더/푸터에서 읽으므로 주소 유효성 먼저 체크</span>
    <span class="c1">// Prologue block's footer is always allocated.</span>
    <span class="c1">// Epilogue block's header is always allocated.</span>
    <span class="kt">size_t</span> <span class="n">prev_alloc</span> <span class="o">=</span> <span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">prev_blk</span><span class="p">));</span> <span class="c1">// Can read footer unless bp is first block</span>
    <span class="kt">size_t</span> <span class="n">next_alloc</span> <span class="o">=</span> <span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">next_blk</span><span class="p">));</span> <span class="c1">// Can read header unless bp is last block</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>

    <span class="c1">// Case 1: No merge needed</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="n">next_alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">add_to_free_list</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span> <span class="c1">// Add the newly freed block to the list</span>
        <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Case 2: Merge with next block</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">next_alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">remove_from_free_list</span><span class="p">(</span><span class="n">next_blk</span><span class="p">);</span> <span class="c1">// Remove next block from list</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">next_blk</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// Footer position is now FTRP(next_blk), but FTRP uses HDRP size, so this works</span>
        <span class="n">add_to_free_list</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span> <span class="c1">// Add the merged block to the list</span>
        <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Case 3: Merge with previous block</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="n">next_alloc</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">remove_from_free_list</span><span class="p">(</span><span class="n">prev_blk</span><span class="p">);</span> <span class="c1">// Remove previous block from list</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">prev_blk</span><span class="p">));</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">prev_blk</span><span class="p">;</span> <span class="c1">// Move bp to the beginning of the merged block</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// Footer position is original FTRP(bp)</span>
        <span class="n">add_to_free_list</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span> <span class="c1">// Add the merged block to the list</span>
        <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Case 4: Merge with both previous and next blocks</span>
    <span class="k">else</span> <span class="p">{</span> <span class="c1">// (!prev_alloc &amp;&amp; !next_alloc)</span>
        <span class="n">remove_from_free_list</span><span class="p">(</span><span class="n">prev_blk</span><span class="p">);</span> <span class="c1">// Remove previous block</span>
        <span class="n">remove_from_free_list</span><span class="p">(</span><span class="n">next_blk</span><span class="p">);</span> <span class="c1">// Remove next block</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">prev_blk</span><span class="p">))</span> <span class="o">+</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">next_blk</span><span class="p">));</span> <span class="c1">// Use HDRP for next block size</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">prev_blk</span><span class="p">;</span> <span class="c1">// Move bp to the beginning of the merged block</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// Footer position is FTRP(next_blk)</span>
        <span class="n">add_to_free_list</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span> <span class="c1">// Add the final merged block to the list</span>
        <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 마지막 free_root = bp; 제거</span>
<span class="p">}</span>

<span class="cm">/*
 * mm_realloc - Implemented simply in terms of mm_malloc and mm_free
 */</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">mm_realloc</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">oldptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">newptr</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">copySize</span><span class="p">;</span>

    <span class="n">newptr</span> <span class="o">=</span> <span class="n">mm_malloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">newptr</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="n">copySize</span> <span class="o">=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">oldptr</span><span class="p">))</span> <span class="o">-</span> <span class="p">(</span><span class="n">WSIZE</span><span class="o">*</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">copySize</span><span class="p">)</span>
        <span class="n">copySize</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">newptr</span><span class="p">,</span> <span class="n">oldptr</span><span class="p">,</span> <span class="n">copySize</span><span class="p">);</span>
    <span class="n">mm_free</span><span class="p">(</span><span class="n">oldptr</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">newptr</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// --- Helper 함수 (place, coalesce 에서 사용) ---</span>
<span class="c1">// Free list 맨 앞에 블록 추가 (LIFO)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_to_free_list</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">free_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 리스트가 비어있을 때</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 리스트에 블록이 있을 때</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">free_root</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">free_root</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span> <span class="c1">// 기존 루트의 PREV를 새 블록으로</span>
        <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span> <span class="c1">// 루트를 새 블록으로 업데이트</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Free list에서 블록 제거</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_from_free_list</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_free</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">next_free</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">prev_free</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// bp가 리스트의 첫 번째 블록일 때</span>
        <span class="n">free_root</span> <span class="o">=</span> <span class="n">next_free</span><span class="p">;</span> <span class="c1">// 다음 블록을 루트로 설정</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// bp가 중간 또는 마지막 블록일 때</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">prev_free</span><span class="p">,</span> <span class="n">next_free</span><span class="p">);</span> <span class="c1">// 이전 블록의 NEXT를 다음 블록으로</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">next_free</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// bp가 마지막 블록이 아닐 때</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">next_free</span><span class="p">,</span> <span class="n">prev_free</span><span class="p">);</span> <span class="c1">// 다음 블록의 PREV를 이전 블록으로</span>
    <span class="p">}</span>
    <span class="c1">// bp의 포인터는 초기화할 필요 없음 (어차피 할당되거나 병합될 것임)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>결과는 아래와 같다. 1점이 오른걸 확인할 수 있다. 명시적 list로는 best-fit이 메모리 효율이 제일 좋다. best-fit까지 구현을 할까 생각했는데, 주 마지막날이어서 다음날 발표를 준비해야 했다. 그래서 포기했다..</p>

<p><img src="/assets/img/blog/computerscience/implicitnext.png" alt="명시적 first-fit 결과" /></p>

<h2 id="명시적-리스트explicit-list에서의-refactoring">명시적 리스트(Explicit list)에서의 refactoring</h2>

<p>명시적 리스트를 구현하기 위해서 조금 복잡하게 구현했던 내용 개선에 대해서 얘기하려고 해</p>

<p>명시적 리스트를 구현하기 위해서는 가용 블록의 포인터 생성/변경 고려가 필요, 포인터 생성/변경 같은 경우 아래 사진과 같이 구현해야 함</p>

<p><img src="/assets/img/blog/computerscience/case4.png" alt="Case 4" /></p>

<p>Case 4 같은 경우에 포인터 8개의 생성/변경이 필요하기 때문에 아래와 같은 코드가 나옴</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">coalesce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">prev_alloc</span> <span class="o">=</span> <span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
    <span class="kt">size_t</span> <span class="n">next_alloc</span> <span class="o">=</span> <span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_free_root</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_free_root_prev</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">next_free_blk_next</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">next_free_blk_prev</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_free_blk_next</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_free_blk_prev</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="n">next_alloc</span><span class="p">)</span>               <span class="c1">// Case 1</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">free_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">prev_free_root</span> <span class="o">=</span> <span class="n">free_root</span><span class="p">;</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_root</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">prev_free_root</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">next_alloc</span><span class="p">)</span>         <span class="c1">// Case 2</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">free_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">prev_free_root</span> <span class="o">=</span> <span class="n">free_root</span><span class="p">;</span>
            <span class="n">prev_free_root_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">free_root</span><span class="p">);</span>
            <span class="n">next_free_blk_next</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
            <span class="n">next_free_blk_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">next_free_blk_prev</span><span class="p">,</span> <span class="n">next_free_blk_next</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">next_free_blk_next</span><span class="p">,</span> <span class="n">next_free_blk_prev</span><span class="p">);</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">prev_free_root</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_root_prev</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="n">next_alloc</span><span class="p">)</span>         <span class="c1">// Case 3</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">free_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">prev_free_root</span> <span class="o">=</span> <span class="n">free_root</span><span class="p">;</span>
            <span class="n">prev_free_root_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">free_root</span><span class="p">);</span>
            <span class="n">prev_free_blk_next</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
            <span class="n">prev_free_blk_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">prev_free_blk_prev</span><span class="p">,</span> <span class="n">prev_free_blk_next</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_blk_next</span><span class="p">,</span> <span class="n">prev_free_blk_prev</span><span class="p">);</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">prev_free_root</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_root_prev</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>
    <span class="k">else</span>                                        <span class="c1">// Case 4</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)))</span> <span class="o">+</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

        <span class="n">prev_free_root</span> <span class="o">=</span> <span class="n">free_root</span><span class="p">;</span>
        <span class="n">prev_free_root_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">free_root</span><span class="p">);</span>
        <span class="n">prev_free_blk_next</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
        <span class="n">prev_free_blk_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
        <span class="n">next_free_blk_next</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
        <span class="n">next_free_blk_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">prev_free_blk_prev</span><span class="p">,</span> <span class="n">prev_free_blk_next</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_blk_next</span><span class="p">,</span> <span class="n">prev_free_blk_prev</span><span class="p">);</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">next_free_blk_prev</span><span class="p">,</span> <span class="n">next_free_blk_next</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">next_free_blk_next</span><span class="p">,</span> <span class="n">next_free_blk_prev</span><span class="p">);</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">prev_free_root</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_root_prev</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
        <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>동료의 의견도 있었고 Google AI Studio의 의견에 따라서 함수 구현함</p>

<p><img src="/assets/img/blog/computerscience/googleaistudio.png" alt="Google AI Studio" /></p>

<h3 id="refactoring-함수">Refactoring 함수</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- Helper 함수 (place, coalesce 에서 사용) ---</span>
<span class="c1">// Free list 맨 앞에 블록 추가 (LIFO)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_to_free_list</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">free_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 리스트가 비어있을 때</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 리스트에 블록이 있을 때</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">free_root</span><span class="p">);</span>   <span class="c1">// 현재 위치의 next를 기존 첫번째 free block</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>        <span class="c1">// 현재 위치의 prev를 NULL</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">free_root</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>   <span class="c1">// 기존 첫번째 free block의 PREV를 현재 블록으로</span>
        <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span> <span class="c1">// 루트를 새 블록으로 업데이트</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Free list에서 블록 제거</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_from_free_list</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_free</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">next_free</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">prev_free</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// bp가 리스트의 첫 번째 블록일 때</span>
        <span class="n">free_root</span> <span class="o">=</span> <span class="n">next_free</span><span class="p">;</span> <span class="c1">// 다음 블록을 루트로 설정</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// bp가 중간 또는 마지막 블록일 때</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">prev_free</span><span class="p">,</span> <span class="n">next_free</span><span class="p">);</span> <span class="c1">// 이전 블록의 NEXT를 다음 블록으로</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">next_free</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// bp가 마지막 블록이 아닐 때</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">next_free</span><span class="p">,</span> <span class="n">prev_free</span><span class="p">);</span> <span class="c1">// 다음 블록의 PREV를 이전 블록으로</span>
    <span class="p">}</span>
    <span class="c1">// bp의 포인터는 초기화할 필요 없음 (어차피 할당되거나 병합될 것임)</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>
    <p>add_to_free_list : 아래 사진의 ①, ②, ③, ④ 포인터의 변경/생성에 관여</p>
  </li>
  <li>
    <p>remove_from_free_list : 아래 사진의 ⑤, ⑥, ⑦, ⑧ 포인터의 변경/생성에 관여</p>
  </li>
</ul>

<p><img src="/assets/img/blog/computerscience/case4pointers.png" alt="Case4 함수별 포인터" /></p>

<h3 id="개선된-case-4">개선된 Case 4</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Case 4: Merge with both previous and next blocks</span>
    <span class="k">else</span> <span class="p">{</span> <span class="c1">// (!prev_alloc &amp;&amp; !next_alloc)</span>
        <span class="n">remove_from_free_list</span><span class="p">(</span><span class="n">prev_blk</span><span class="p">);</span> <span class="c1">// Remove previous block</span>
        <span class="n">remove_from_free_list</span><span class="p">(</span><span class="n">next_blk</span><span class="p">);</span> <span class="c1">// Remove next block</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">prev_blk</span><span class="p">))</span> <span class="o">+</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">next_blk</span><span class="p">));</span> <span class="c1">// Use HDRP for next block size</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">prev_blk</span><span class="p">;</span> <span class="c1">// Move bp to the beginning of the merged block</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// Footer position is FTRP(next_blk)</span>
        <span class="n">add_to_free_list</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span> <span class="c1">// Add the final merged block to the list</span>
        <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[C언어로 직접 Malloc을 구현해보자]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">링커(Linking)</title><link href="/blog/computersystem/linking/" rel="alternate" type="text/html" title="링커(Linking)" /><published>2025-04-21T00:00:00+00:00</published><updated>2025-04-21T00:00:00+00:00</updated><id>/blog/computersystem/linking</id><content type="html" xml:base="/blog/computersystem/linking/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#링커의-역할" id="markdown-toc-링커의-역할">링커의 역할</a>    <ul>
      <li><a href="#링킹을-왜-배워야-할까" id="markdown-toc-링킹을-왜-배워야-할까">링킹을 왜 배워야 할까?</a></li>
    </ul>
  </li>
  <li><a href="#정적-연결" id="markdown-toc-정적-연결">정적 연결</a></li>
  <li><a href="#목적파일" id="markdown-toc-목적파일">목적파일</a></li>
  <li><a href="#재배치-가능-목적파일with-elf--executable-and-linkable-format" id="markdown-toc-재배치-가능-목적파일with-elf--executable-and-linkable-format">재배치 가능 목적파일(with ELF : Executable and Linkable Format)</a></li>
  <li><a href="#실행-가능-목적파일의-로딩" id="markdown-toc-실행-가능-목적파일의-로딩">실행 가능 목적파일의 로딩</a>    <ul>
      <li><a href="#로더-실행" id="markdown-toc-로더-실행">로더 실행</a></li>
    </ul>
  </li>
</ul>

<p><strong>링킹(linking)</strong>은 여러 개의 코드와 데이터를 모아서 연결하여 메모리에 로드될 수 있고 실행될 수 있는 한 개의 파일로 만드는 작업이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">로더에 의해서 실행</th>
      <th style="text-align: center">응용프로그램에 의해서 실행</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">링커 수행 시기</td>
      <td style="text-align: center">로드 타임</td>
      <td style="text-align: center">실행 시</td>
    </tr>
  </tbody>
</table>

<h2 id="링커의-역할">링커의 역할</h2>

<p>링커는 독립적인 컴파일을 가능하게 한다. 이 뜻이 뭐냐하면, 큰 규모의 응용프로그램을 한 개의 소스 파일로 구성하는 대신에 컴파일할 수 있는 보다 관리할 만한 규모의 더 작은 모듈들로 나눌 수 있다. 그리고 이거를 별도로 수정할 수 있게 된다.</p>

<ul>
  <li>모듈 중에 한 개를 변경할 때, 이 파일만을 간단히 재컴파일하고 다른 파일들을 재컴파일할 필요 없이 이 응용을 다시 링크한다.</li>
</ul>

<h3 id="링킹을-왜-배워야-할까">링킹을 왜 배워야 할까?</h3>

<ul>
  <li>
    <p><strong>큰 규모의 프로그램을 개발</strong>할 때, 링킹을 사용하게 될 텐데, <strong>어떻게 링커가 참조를 핵결해 나가는지, 라이브러리가 무엇인지를 배워서 링커 에러를 해결할 수 있다.</strong></p>
  </li>
  <li>
    <p>언어의 <strong>변수 영역 규칙이 구현되었는지 이해</strong>하는데 도움이 된다. 예를 들어, <strong>전역변수와 지역변수의 차이</strong>는 무엇인가?</p>
  </li>
  <li>
    <p><strong>공유 라이브러리에 대해 이해</strong>할 수 있다.</p>
  </li>
</ul>

<p>더 여러가지가 있지만, 내 기준에서 중요할 것 같은 내용들만 뽑아왔다.</p>

<h2 id="정적-연결">정적 연결</h2>

<p><strong>재배치 가능한 목적파일(.o)들</strong>과 <strong>명령줄 인자들을 입력</strong>으로 받아들여서 로드될 수 있고 실행될 수 있는 완전히 링크된 실행 가능 목적파일을 출력으로 생성한다.</p>

<p>실행파일을 만들기 위해서 링커는 두 가지 주요 작업을 수행해야 함</p>

<ol>
  <li><strong>심볼 해석(symbol resolution)</strong> : 목적파일들은 심볼들을 정의하고 참조하며 여기서 각 심볼은 함수, 전역변수 또는 정적변수(즉, C언어에서 static으로 선언된 모든 변수들)에 대응된다</li>
</ol>

<ul>
  <li>심볼 해석의 <strong>목적</strong>은 <strong>각각의 심볼 참조를 정확하게 하나의 심볼 정의에 연결</strong>하는 것임</li>
</ul>

<ol>
  <li><strong>재배치(relocation)</strong> : 컴파일러와 어셈블러는 주소 0번지에서 시작하는 코드와 데이터 섹션들을 생성. 링커는 <strong>이 섹션들을 각 심볼 정의와 연결시켜서 재배치 하며, 이 심볼들로 가는 모든 참조들을 수정해서 이들이 이 메모리 위치를 가리키도록 한다</strong></li>
</ol>

<h2 id="목적파일">목적파일</h2>

<p>목적파일에는 세 가지 형태가 있어</p>

<ul>
  <li>
    <p>재배치 가능 목적파일(Relocatable object file) : 포맷에 컴파일 할 때 <strong>실행 가능 목적파일을 생성하기 위해 다른 재구성가능 목적파일들과 결합될 수 있는 바이너리 코드와 데이터를 포함</strong>한다</p>

    <ul>
      <li>.o 로 끝나는 파일들이 그 예이다</li>
    </ul>
  </li>
  <li>
    <p>실행 가능 목적파일(Executable object file) : 메모리에 직접 복사될 수 있고 <strong>실행될 수 있는 형태</strong>로 바이너리 코드와 데이터를 포함</p>
  </li>
  <li>
    <p>공유 목적파일(Shared object file) : 로드타임(Load time) 또는 런타임(Runtime)시에 동적으로 링크되고 메모리에 로드될 수 있는 특수한 유형의 <strong>재배치 가능 목적파일</strong>이다</p>
  </li>
</ul>

<p><strong>컴파일러와 어셈블러</strong>는 재배치 가능 목적파일을 생성하고 <strong>링커</strong>는 실행 가능한 목적파일을 생성함</p>

<h2 id="재배치-가능-목적파일with-elf--executable-and-linkable-format">재배치 가능 목적파일(with ELF : Executable and Linkable Format)</h2>

<ul>
  <li><strong>ELF</strong> : 리눅스 같은 유닉스 시스템에서 실행 파일이나 오브젝트 파일을 위한 <strong>표준 포맷</strong>이다(예 : .o 파일이나 a.out 파일)</li>
</ul>

<p>아래의 표는 ELF 재배치 가능 목적파일의 포맷을 보여준다</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">┌</th>
      <th style="text-align: center">ELF header</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">s</td>
      <td style="text-align: center">.text</td>
    </tr>
    <tr>
      <td style="text-align: center">e</td>
      <td style="text-align: center">.rodata</td>
    </tr>
    <tr>
      <td style="text-align: center">c</td>
      <td style="text-align: center">.data</td>
    </tr>
    <tr>
      <td style="text-align: center">t</td>
      <td style="text-align: center">.bss</td>
    </tr>
    <tr>
      <td style="text-align: center">i</td>
      <td style="text-align: center">.symtab</td>
    </tr>
    <tr>
      <td style="text-align: center">o</td>
      <td style="text-align: center">.rel.text</td>
    </tr>
    <tr>
      <td style="text-align: center">n</td>
      <td style="text-align: center">.rel.data</td>
    </tr>
    <tr>
      <td style="text-align: center">s</td>
      <td style="text-align: center">.debug</td>
    </tr>
    <tr>
      <td style="text-align: center">└</td>
      <td style="text-align: center">.line</td>
    </tr>
    <tr>
      <td style="text-align: center">Describes object file sections</td>
      <td style="text-align: center">Section header table</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>ELF header : ELF 파일의 <strong>맨 처음에 위치한 아주 중요한 정보 블록</strong>으로써, “이 파일은 ELF 파일입니다”를 알려주고 “이 파일은 ELF 파일입니다” 문구는 운영체제나 링커가 확인. 이 파일을 생성한 워드 크기와 시스템의 바이트 순서를 나타내는 16바이트 배열로 시작함</p>

    <ul>
      <li>
        <p>나머지는 링커가 목적파일을 구문분석하고 해석하도록 하는 정보를 포함하고 있음</p>
      </li>
      <li>
        <p>여기에는 ELF header의 크기, 목적파일 타입(예: 재배치 가능, 실행 가능, 공유), 머신 타임(예: x86-64), section header table의 파일 오프셋, section header table의 크기와 엔트리 수가 들어 있다.</p>
      </li>
      <li>
        <p>여러 가지 섹션들의 위치와 크기는 section header table로 나타내며, 이 테이블은 목적파일의 각 섹션에 대해 고정된 크기의 엔트리를 가짐</p>
      </li>
    </ul>
  </li>
  <li>
    <p>.text : 컴파일된 프로그램의 머신 코드</p>
  </li>
  <li>
    <p>.rodata printf : 문장의 포맷 스트링, switch 문의 점프 테이블과 같은 읽기-허용 데이터</p>
  </li>
  <li>
    <p>.data : <strong>초기화된 C 전역변수 및 전역변수</strong>이며, 실제로 파일 안에 값이 저장됨<strong>(Disk 공간 차지)</strong></p>

    <ul>
      <li>
        <p>int a = 10; → Binary 파일에 기록됨 → a의 초기값 10이 포함된 형태로 .data 섹션에 저장</p>
      </li>
      <li>
        <p>만약 아래처럼 a가 지역 변수라면? 지역 변수는 스택에 들어가기 때문에, .data에 들어가지 않아</p>
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// 지역 변수 👉 스택에 들어감 ❗</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>.bss : <strong>초기화되지 않은 C 전역변수와 정적변수 그리고 0으로 초기화된 전역변수 및 정적변수</strong>이며, 실제 공간을 차지하지 않고 단순히 위치를 표시해(Disk 공간 차지하지 않음)</p>

    <ul>
      <li>
        <p>int b; 또는 static int c; → 초기화되지 않은 전역/정적 변수로 .bss 공간에 해당</p>

        <ul>
          <li>b의 값 또는 c의 값이 쓰래기 값이면 어떻게 될까? 운영체제가 프로그램을 메모리에 올릴 때, .bss 영역에 있는 변수들은 자동으로 0으로 채움!</li>
        </ul>
      </li>
      <li>
        <p>int y = 0; → 0으로 초기화된 전역/정적 변수로 .bss 공간에 해당</p>
      </li>
    </ul>
  </li>
  <li>
    <p>rel.text : 링커가 이 목적파일을 다른 파일들과 연결할 때 수정되어야 하는 .text 섹션 내 위치들의 리스트</p>

    <ul>
      <li>일반적으로 외부 함수를 호출하거나 전역변수를 참조하는 인스트럭션들은 모두 수정 되어야 하고 이 수정을 위해서 위치들의 정보를 갖고 있는게 아닐까 싶다</li>
    </ul>
  </li>
  <li>
    <p>rel.data : 해당 모듈에 의해 정의되거나 참조되는 전역변수들에 대한 재배치 정보</p>

    <ul>
      <li>일반적으로 초기값이 전역변수 또는 외부에 정의된 함수의 주소인 초기화된 전역변수들 모두 수정되어야 한다</li>
    </ul>
  </li>
  <li>
    <p>.debug : 프로그램 내에서 정의도니 지역변수들과 typedef, 프로그램과 최초 C 소스 파일에서 정의되고 참조되는 전역변수들을 위한 엔트리를 갖는 <strong>디버깅 심볼 테이블</strong></p>

    <ul>
      <li>컴파일러 드라이버가 -g 옵션으로 불린 경우에 생성됨</li>
    </ul>
  </li>
  <li>
    <p>.line : 최초 C 소스 프로그램과 .text 섹션 내 머신 코드 인스트럭션 내 라인 번호들간의 매핑</p>

    <ul>
      <li>컴파일러 드라이버가 -g 옵션으로 불린 경우에 생성됨</li>
    </ul>
  </li>
  <li>
    <p>.strtab : .strtab과 .debug 섹션들 내에 있는 심볼 테이블과 섹션 헤더들에 있는 섹션 이름들을 위한 스트링 테이블. 스트링 테이블은 널 문자로 종료된 스트링의 배열</p>
  </li>
</ul>

<h2 id="실행-가능-목적파일의-로딩">실행 가능 목적파일의 로딩</h2>

<p>우리가 실행 가능 목적파일을 실행하기 위해 아래와 같은 명령어를 타입해</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux&gt; ./prog
</code></pre></div></div>

<p>그러면 이 실행 가능 목적파일이 어떻게 로딩될까?</p>

<ul>
  <li>
    <p><strong>prog</strong>는 내장 Shell 명령어가 아니야. 그래서 Shell은 prog가 실행 가능한 목적파일이라고 생각하고 Loader 라는 메모리 상주 운영체제 코드를 호출해. 호출해서 이 프로그램을 실행해</p>

    <ul>
      <li>
        <p>리눅스 프로그램은 <strong>execve</strong> 함수를 호출해서 Loader를 호출할 수 있어</p>
      </li>
      <li>
        <p>Loader는 Disk로부터 실행 가능한 목적파일 내의 코드와 데이터를 메모리로 복사하고 이 프로그램의 첫 번째 Instruction, 즉 Entry point로 Jump해서 프로그램을 실행해</p>
      </li>
      <li>
        <p><strong>위와 같이 프로그램을 메모리로 복사하고 실행하는 과정을 Loading</strong>이라함</p>
      </li>
    </ul>
  </li>
</ul>

<p>모든 실행 중인 리눅스 프로그램은 아래 사진과 같은 런타임 메모리 이미지를 가진다</p>

<p><img src="/assets/img/blog/computerscience/LinuxRuntimeMemory.png" alt="런타임 메모리 이미지" /></p>

<ul>
  <li>
    <p>리눅스 시스템에서 code segment는 주소 0x400000에서 시작</p>
  </li>
  <li>
    <p>뒤이어 data segment(Read/write segment)가 옴</p>

    <ul>
      <li>실제로는 code와 data segment 사이에 공간이 존재함</li>
    </ul>
  </li>
  <li>
    <p>Run-time heap은 data segment 다음에 따라오고 malloc 라이브러리를 호출해서 위로 성장</p>
  </li>
  <li>
    <p>이 다음에는 공유 모듈(shared libraries)들을 위해 예약된 영역이 존재</p>
  </li>
  <li>
    <p>사용자 스택은 가장 큰 합법적 사용자 주소(2^48-1) 아래에서 시작해서 더 작은 메모리 주소 방향인 아래로 성장</p>
  </li>
  <li>
    <p>스택 위의 영역은 운영체제의 메모리 상주 부분인 커널의 코드와 데이터를 위해 예약</p>
  </li>
</ul>

<h3 id="로더-실행">로더 실행</h3>

<p>로더가 실행되면 아래와 같은 workflow를 가진다</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">                               </span><span class="err">┌</span><span class="w"> </span><span class="err">가상</span><span class="w"> </span><span class="err">메모리┐</span><span class="w">    </span><span class="err">로더가</span><span class="w"> </span><span class="err">프로그램의</span><span class="w"> </span><span class="nv">Entry</span><span class="w"> </span><span class="nv">point</span><span class="err">로</span><span class="w"> </span><span class="nv">jump</span><span class="w">     </span><span class="o">_</span><span class="nv">start</span><span class="w"> </span><span class="err">함수가</span><span class="w"> </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="err">호출</span><span class="w">     </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="o">:</span><span class="w">
</span><span class="err">로더</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="err">파일</span><span class="w"> </span><span class="err">덩어리</span><span class="w"> </span><span class="o">-&gt;</span><span class="err">│</span><span class="nv">data</span><span class="w"> </span><span class="nv">segment</span><span class="err">│</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">  </span><span class="err">┌────────────</span><span class="nv">crt1</span><span class="o">.</span><span class="nv">o</span><span class="err">────────────┐</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="err">┌────────────</span><span class="nv">libc</span><span class="o">.</span><span class="nv">so</span><span class="err">────────────┐</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">            </span><span class="o">-</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="err">환경</span><span class="w"> </span><span class="err">초기화</span><span class="w">
                           </span><span class="err">복사│</span><span class="nv">code</span><span class="w"> </span><span class="nv">segment</span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w">        </span><span class="o">_</span><span class="nv">start</span><span class="w"> </span><span class="err">함수</span><span class="w"> </span><span class="err">실행</span><span class="w">        </span><span class="err">│</span><span class="w">     </span><span class="err">│</span><span class="w">   </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="err">함수</span><span class="w"> </span><span class="err">실행</span><span class="w">  </span><span class="err">│</span><span class="w">                </span><span class="o">-</span><span class="w"> </span><span class="err">사용자</span><span class="w"> </span><span class="err">수준의</span><span class="w"> </span><span class="nv">main</span><span class="w"> </span><span class="err">함수호출</span><span class="w">
                               </span><span class="err">└───────────┘</span><span class="w">     </span><span class="err">└──────────────────────────────┘</span><span class="w">       </span><span class="err">└──────────────────────────────┘</span><span class="w">                 </span><span class="o">-</span><span class="w"> </span><span class="nv">return</span><span class="err">값</span><span class="w"> </span><span class="err">처리</span><span class="w">
                                                                                                                                         </span><span class="o">-</span><span class="w"> </span><span class="err">필요한</span><span class="w"> </span><span class="err">경우</span><span class="w"> </span><span class="err">제어권을</span><span class="w"> </span><span class="err">커널로</span><span class="w"> </span><span class="err">넘겨줌</span><span class="w">
</span></code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[링킹(linking)은 여러 개의 코드와 데이터를 모아서 연결하여 메모리에 로드될 수 있고 실행될 수 있는 한 개의 파일로 만드는 작업이다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">전위 순회(Pre-Order Traversal)와 후위 순회(Post-Order Traversal)의 연관성</title><link href="/blog/algorithm/pre-order-post-order/" rel="alternate" type="text/html" title="전위 순회(Pre-Order Traversal)와 후위 순회(Post-Order Traversal)의 연관성" /><published>2025-04-16T00:00:00+00:00</published><updated>2025-04-16T00:00:00+00:00</updated><id>/blog/algorithm/pre-order-post-order</id><content type="html" xml:base="/blog/algorithm/pre-order-post-order/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#전위-순회와-후위-순회의-구조적인-연관성" id="markdown-toc-전위-순회와-후위-순회의-구조적인-연관성">전위 순회와 후위 순회의 구조적인 연관성</a>    <ul>
      <li><a href="#표준-전위-순회-vs-변형-전위-순회" id="markdown-toc-표준-전위-순회-vs-변형-전위-순회">표준 전위 순회 vs 변형 전위 순회</a></li>
      <li><a href="#변형-전위-순회를-뒤집으면" id="markdown-toc-변형-전위-순회를-뒤집으면">변형 전위 순회를 뒤집으면?</a></li>
      <li><a href="#표준-전위-순회--변형-전위-순회--후위-순회-예제" id="markdown-toc-표준-전위-순회--변형-전위-순회--후위-순회-예제">표준 전위 순회 / 변형 전위 순회 / 후위 순회 예제</a></li>
      <li><a href="#c언어-예제" id="markdown-toc-c언어-예제">C언어 예제</a></li>
    </ul>
  </li>
</ul>

<p>C언어를 통해 재귀 없이 Stack 2개를 활용하여 후위순회를 진행하는 코드를 보고 전위순회와 후위순회의 구조적 연관성이 있겠다는 생각이 들었다. 왜냐하면, 1개의 스택은 전위순회의 구조를 바꾼 형태였고 나머지 스택 하나는 그 한개의 스택을 역순으로 출력하기 위해 존재 했었기 때문이다.</p>

<h2 id="전위-순회와-후위-순회의-구조적인-연관성">전위 순회와 후위 순회의 구조적인 연관성</h2>

<p>먼저 결론부터 얘기하자면, <strong>전위 순회의 구조를 살짝 바꾸고 나온 결과를 뒤집으면 후위 순회 순서와 같아짐</strong></p>

<h3 id="표준-전위-순회-vs-변형-전위-순회">표준 전위 순회 vs 변형 전위 순회</h3>

<ul>
  <li>
    <p>표준 전위 순회 : (Root) → (Left) → (Right)</p>
  </li>
  <li>
    <p>변형 전위 순회 : (Root) → (Right) → (Left)</p>
  </li>
</ul>

<h3 id="변형-전위-순회를-뒤집으면">변형 전위 순회를 뒤집으면?</h3>

<ul>
  <li>
    <p><strong>뒤집은</strong> 변형 전위 순회 : (Left) → (Right) → (Root)</p>
  </li>
  <li>
    <p>표준 후위 순회 : (Left) → (Right) → (Root)</p>
  </li>
</ul>

<h3 id="표준-전위-순회--변형-전위-순회--후위-순회-예제">표준 전위 순회 / 변형 전위 순회 / 후위 순회 예제</h3>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">        </span><span class="nv">A</span><span class="w">
       </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">
      </span><span class="nv">B</span><span class="w">   </span><span class="nb">C</span><span class="w">
     </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">   </span><span class="err">\</span><span class="w">
    </span><span class="nb">D</span><span class="w">   </span><span class="nb">E</span><span class="w">   </span><span class="nv">F</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>표준 전위 순회 (Root → Left → Right)
    <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">A</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">D</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">E</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">C</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">F</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>변형 전위 순회 (Root → Right → Left)
    <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">A</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">C</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">F</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">E</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">D</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>후위 순회 (Left → Right → Root)
    <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">D</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">E</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">F</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">C</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">A</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<h3 id="c언어-예제">C언어 예제</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">postOrderIterativeS2</span><span class="p">(</span><span class="n">BSTNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">Stack</span> <span class="o">*</span><span class="n">stk1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Stack</span><span class="p">));</span>
	<span class="n">Stack</span> <span class="o">*</span><span class="n">stk2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Stack</span><span class="p">));</span>
	<span class="n">stk1</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">stk2</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">push</span><span class="p">(</span><span class="n">stk1</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">stk1</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">BSTNode</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">stk1</span><span class="p">);</span>
		<span class="n">push</span><span class="p">(</span><span class="n">stk2</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
			<span class="n">push</span><span class="p">(</span><span class="n">stk1</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
			<span class="n">push</span><span class="p">(</span><span class="n">stk1</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">stk2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">BSTNode</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">stk2</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">free</span><span class="p">(</span><span class="n">stk1</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">stk2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/Algorithm.png" /><media:content medium="image" url="/assets/img/blog/postimage/Algorithm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>