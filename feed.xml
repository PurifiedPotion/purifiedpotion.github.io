<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-04-27T11:50:21+00:00</updated><id>/feed.xml</id><title type="html">PurifiedPotion’s Blog</title><subtitle>A blog for computer science
</subtitle><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><entry><title type="html">수작업으로 Malloc 구현</title><link href="/blog/computersystem/dynamic-memory-allocation/" rel="alternate" type="text/html" title="수작업으로 Malloc 구현" /><published>2025-04-27T00:00:00+00:00</published><updated>2025-04-27T00:00:00+00:00</updated><id>/blog/computersystem/dynamic-memory-allocation</id><content type="html" xml:base="/blog/computersystem/dynamic-memory-allocation/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#링커의-역할" id="markdown-toc-링커의-역할">링커의 역할</a>    <ul>
      <li><a href="#링킹을-왜-배워야-할까" id="markdown-toc-링킹을-왜-배워야-할까">링킹을 왜 배워야 할까?</a></li>
    </ul>
  </li>
  <li><a href="#정적-연결" id="markdown-toc-정적-연결">정적 연결</a></li>
  <li><a href="#목적파일" id="markdown-toc-목적파일">목적파일</a></li>
  <li><a href="#재배치-가능-목적파일with-elf--executable-and-linkable-format" id="markdown-toc-재배치-가능-목적파일with-elf--executable-and-linkable-format">재배치 가능 목적파일(with ELF : Executable and Linkable Format)</a></li>
  <li><a href="#실행-가능-목적파일의-로딩" id="markdown-toc-실행-가능-목적파일의-로딩">실행 가능 목적파일의 로딩</a>    <ul>
      <li><a href="#로더-실행" id="markdown-toc-로더-실행">로더 실행</a></li>
    </ul>
  </li>
</ul>

<p>말록 구현에 앞서, <strong>명시적 할당자(Explicit allocator)</strong>와 <strong>묵시적 할당자(Implicit allocator)</strong>에 대해 알아 보자</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Explicit allocator</th>
      <th style="text-align: center">Implicit allocator</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">사용 예</td>
      <td style="text-align: center">C언어에서 malloc 할당과 free</td>
      <td style="text-align: center">Java의 garbage collection, ML, and Lisp</td>
    </tr>
  </tbody>
</table>

<p><strong>Malloc</strong>에 관하여서는 이전에 포스팅한 <a href="././blog/c/_posts/2025-04-11-malloc-calloc-realloc.md" class="heading flip-title">동적 메모리 할당(Dynamic memory allocation)</a> 을 참조하면 된다</p>

<h2 id="링커의-역할">링커의 역할</h2>

<p>링커는 독립적인 컴파일을 가능하게 한다. 이 뜻이 뭐냐하면, 큰 규모의 응용프로그램을 한 개의 소스 파일로 구성하는 대신에 컴파일할 수 있는 보다 관리할 만한 규모의 더 작은 모듈들로 나눌 수 있다. 그리고 이거를 별도로 수정할 수 있게 된다.</p>

<ul>
  <li>모듈 중에 한 개를 변경할 때, 이 파일만을 간단히 재컴파일하고 다른 파일들을 재컴파일할 필요 없이 이 응용을 다시 링크한다.</li>
</ul>

<h3 id="링킹을-왜-배워야-할까">링킹을 왜 배워야 할까?</h3>

<ul>
  <li>
    <p><strong>큰 규모의 프로그램을 개발</strong>할 때, 링킹을 사용하게 될 텐데, <strong>어떻게 링커가 참조를 핵결해 나가는지, 라이브러리가 무엇인지를 배워서 링커 에러를 해결할 수 있다.</strong></p>
  </li>
  <li>
    <p>언어의 <strong>변수 영역 규칙이 구현되었는지 이해</strong>하는데 도움이 된다. 예를 들어, <strong>전역변수와 지역변수의 차이</strong>는 무엇인가?</p>
  </li>
  <li>
    <p><strong>공유 라이브러리에 대해 이해</strong>할 수 있다.</p>
  </li>
</ul>

<p>더 여러가지가 있지만, 내 기준에서 중요할 것 같은 내용들만 뽑아왔다.</p>

<h2 id="정적-연결">정적 연결</h2>

<p><strong>재배치 가능한 목적파일(.o)들</strong>과 <strong>명령줄 인자들을 입력</strong>으로 받아들여서 로드될 수 있고 실행될 수 있는 완전히 링크된 실행 가능 목적파일을 출력으로 생성한다.</p>

<p>실행파일을 만들기 위해서 링커는 두 가지 주요 작업을 수행해야 함</p>

<ol>
  <li><strong>심볼 해석(symbol resolution)</strong> : 목적파일들은 심볼들을 정의하고 참조하며 여기서 각 심볼은 함수, 전역변수 또는 정적변수(즉, C언어에서 static으로 선언된 모든 변수들)에 대응된다</li>
</ol>

<ul>
  <li>심볼 해석의 <strong>목적</strong>은 <strong>각각의 심볼 참조를 정확하게 하나의 심볼 정의에 연결</strong>하는 것임</li>
</ul>

<ol>
  <li><strong>재배치(relocation)</strong> : 컴파일러와 어셈블러는 주소 0번지에서 시작하는 코드와 데이터 섹션들을 생성. 링커는 <strong>이 섹션들을 각 심볼 정의와 연결시켜서 재배치 하며, 이 심볼들로 가는 모든 참조들을 수정해서 이들이 이 메모리 위치를 가리키도록 한다</strong></li>
</ol>

<h2 id="목적파일">목적파일</h2>

<p>목적파일에는 세 가지 형태가 있어</p>

<ul>
  <li>
    <p>재배치 가능 목적파일(Relocatable object file) : 포맷에 컴파일 할 때 <strong>실행 가능 목적파일을 생성하기 위해 다른 재구성가능 목적파일들과 결합될 수 있는 바이너리 코드와 데이터를 포함</strong>한다</p>

    <ul>
      <li>.o 로 끝나는 파일들이 그 예이다</li>
    </ul>
  </li>
  <li>
    <p>실행 가능 목적파일(Executable object file) : 메모리에 직접 복사될 수 있고 <strong>실행될 수 있는 형태</strong>로 바이너리 코드와 데이터를 포함</p>
  </li>
  <li>
    <p>공유 목적파일(Shared object file) : 로드타임(Load time) 또는 런타임(Runtime)시에 동적으로 링크되고 메모리에 로드될 수 있는 특수한 유형의 <strong>재배치 가능 목적파일</strong>이다</p>
  </li>
</ul>

<p><strong>컴파일러와 어셈블러</strong>는 재배치 가능 목적파일을 생성하고 <strong>링커</strong>는 실행 가능한 목적파일을 생성함</p>

<h2 id="재배치-가능-목적파일with-elf--executable-and-linkable-format">재배치 가능 목적파일(with ELF : Executable and Linkable Format)</h2>

<ul>
  <li><strong>ELF</strong> : 리눅스 같은 유닉스 시스템에서 실행 파일이나 오브젝트 파일을 위한 <strong>표준 포맷</strong>이다(예 : .o 파일이나 a.out 파일)</li>
</ul>

<p>아래의 표는 ELF 재배치 가능 목적파일의 포맷을 보여준다</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">┌</th>
      <th style="text-align: center">ELF header</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">s</td>
      <td style="text-align: center">.text</td>
    </tr>
    <tr>
      <td style="text-align: center">e</td>
      <td style="text-align: center">.rodata</td>
    </tr>
    <tr>
      <td style="text-align: center">c</td>
      <td style="text-align: center">.data</td>
    </tr>
    <tr>
      <td style="text-align: center">t</td>
      <td style="text-align: center">.bss</td>
    </tr>
    <tr>
      <td style="text-align: center">i</td>
      <td style="text-align: center">.symtab</td>
    </tr>
    <tr>
      <td style="text-align: center">o</td>
      <td style="text-align: center">.rel.text</td>
    </tr>
    <tr>
      <td style="text-align: center">n</td>
      <td style="text-align: center">.rel.data</td>
    </tr>
    <tr>
      <td style="text-align: center">s</td>
      <td style="text-align: center">.debug</td>
    </tr>
    <tr>
      <td style="text-align: center">└</td>
      <td style="text-align: center">.line</td>
    </tr>
    <tr>
      <td style="text-align: center">Describes object file sections</td>
      <td style="text-align: center">Section header table</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>ELF header : ELF 파일의 <strong>맨 처음에 위치한 아주 중요한 정보 블록</strong>으로써, “이 파일은 ELF 파일입니다”를 알려주고 “이 파일은 ELF 파일입니다” 문구는 운영체제나 링커가 확인. 이 파일을 생성한 워드 크기와 시스템의 바이트 순서를 나타내는 16바이트 배열로 시작함</p>

    <ul>
      <li>
        <p>나머지는 링커가 목적파일을 구문분석하고 해석하도록 하는 정보를 포함하고 있음</p>
      </li>
      <li>
        <p>여기에는 ELF header의 크기, 목적파일 타입(예: 재배치 가능, 실행 가능, 공유), 머신 타임(예: x86-64), section header table의 파일 오프셋, section header table의 크기와 엔트리 수가 들어 있다.</p>
      </li>
      <li>
        <p>여러 가지 섹션들의 위치와 크기는 section header table로 나타내며, 이 테이블은 목적파일의 각 섹션에 대해 고정된 크기의 엔트리를 가짐</p>
      </li>
    </ul>
  </li>
  <li>
    <p>.text : 컴파일된 프로그램의 머신 코드</p>
  </li>
  <li>
    <p>.rodata printf : 문장의 포맷 스트링, switch 문의 점프 테이블과 같은 읽기-허용 데이터</p>
  </li>
  <li>
    <p>.data : <strong>초기화된 C 전역변수 및 전역변수</strong>이며, 실제로 파일 안에 값이 저장됨<strong>(Disk 공간 차지)</strong></p>

    <ul>
      <li>
        <p>int a = 10; → Binary 파일에 기록됨 → a의 초기값 10이 포함된 형태로 .data 섹션에 저장</p>
      </li>
      <li>
        <p>만약 아래처럼 a가 지역 변수라면? 지역 변수는 스택에 들어가기 때문에, .data에 들어가지 않아</p>
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// 지역 변수 👉 스택에 들어감 ❗</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>.bss : <strong>초기화되지 않은 C 전역변수와 정적변수 그리고 0으로 초기화된 전역변수 및 정적변수</strong>이며, 실제 공간을 차지하지 않고 단순히 위치를 표시해(Disk 공간 차지하지 않음)</p>

    <ul>
      <li>
        <p>int b; 또는 static int c; → 초기화되지 않은 전역/정적 변수로 .bss 공간에 해당</p>

        <ul>
          <li>b의 값 또는 c의 값이 쓰래기 값이면 어떻게 될까? 운영체제가 프로그램을 메모리에 올릴 때, .bss 영역에 있는 변수들은 자동으로 0으로 채움!</li>
        </ul>
      </li>
      <li>
        <p>int y = 0; → 0으로 초기화된 전역/정적 변수로 .bss 공간에 해당</p>
      </li>
    </ul>
  </li>
  <li>
    <p>rel.text : 링커가 이 목적파일을 다른 파일들과 연결할 때 수정되어야 하는 .text 섹션 내 위치들의 리스트</p>

    <ul>
      <li>일반적으로 외부 함수를 호출하거나 전역변수를 참조하는 인스트럭션들은 모두 수정 되어야 하고 이 수정을 위해서 위치들의 정보를 갖고 있는게 아닐까 싶다</li>
    </ul>
  </li>
  <li>
    <p>rel.data : 해당 모듈에 의해 정의되거나 참조되는 전역변수들에 대한 재배치 정보</p>

    <ul>
      <li>일반적으로 초기값이 전역변수 또는 외부에 정의된 함수의 주소인 초기화된 전역변수들 모두 수정되어야 한다</li>
    </ul>
  </li>
  <li>
    <p>.debug : 프로그램 내에서 정의도니 지역변수들과 typedef, 프로그램과 최초 C 소스 파일에서 정의되고 참조되는 전역변수들을 위한 엔트리를 갖는 <strong>디버깅 심볼 테이블</strong></p>

    <ul>
      <li>컴파일러 드라이버가 -g 옵션으로 불린 경우에 생성됨</li>
    </ul>
  </li>
  <li>
    <p>.line : 최초 C 소스 프로그램과 .text 섹션 내 머신 코드 인스트럭션 내 라인 번호들간의 매핑</p>

    <ul>
      <li>컴파일러 드라이버가 -g 옵션으로 불린 경우에 생성됨</li>
    </ul>
  </li>
  <li>
    <p>.strtab : .strtab과 .debug 섹션들 내에 있는 심볼 테이블과 섹션 헤더들에 있는 섹션 이름들을 위한 스트링 테이블. 스트링 테이블은 널 문자로 종료된 스트링의 배열</p>
  </li>
</ul>

<h2 id="실행-가능-목적파일의-로딩">실행 가능 목적파일의 로딩</h2>

<p>우리가 실행 가능 목적파일을 실행하기 위해 아래와 같은 명령어를 타입해</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux&gt; ./prog
</code></pre></div></div>

<p>그러면 이 실행 가능 목적파일이 어떻게 로딩될까?</p>

<ul>
  <li>
    <p><strong>prog</strong>는 내장 Shell 명령어가 아니야. 그래서 Shell은 prog가 실행 가능한 목적파일이라고 생각하고 Loader 라는 메모리 상주 운영체제 코드를 호출해. 호출해서 이 프로그램을 실행해</p>

    <ul>
      <li>
        <p>리눅스 프로그램은 <strong>execve</strong> 함수를 호출해서 Loader를 호출할 수 있어</p>
      </li>
      <li>
        <p>Loader는 Disk로부터 실행 가능한 목적파일 내의 코드와 데이터를 메모리로 복사하고 이 프로그램의 첫 번째 Instruction, 즉 Entry point로 Jump해서 프로그램을 실행해</p>
      </li>
      <li>
        <p><strong>위와 같이 프로그램을 메모리로 복사하고 실행하는 과정을 Loading</strong>이라함</p>
      </li>
    </ul>
  </li>
</ul>

<p>모든 실행 중인 리눅스 프로그램은 아래 사진과 같은 런타임 메모리 이미지를 가진다</p>

<p><img src="/assets/img/blog/computerscience/LinuxRuntimeMemory.png" alt="런타임 메모리 이미지" /></p>

<ul>
  <li>
    <p>리눅스 시스템에서 code segment는 주소 0x400000에서 시작</p>
  </li>
  <li>
    <p>뒤이어 data segment(Read/write segment)가 옴</p>

    <ul>
      <li>실제로는 code와 data segment 사이에 공간이 존재함</li>
    </ul>
  </li>
  <li>
    <p>Run-time heap은 data segment 다음에 따라오고 malloc 라이브러리를 호출해서 위로 성장</p>
  </li>
  <li>
    <p>이 다음에는 공유 모듈(shared libraries)들을 위해 예약된 영역이 존재</p>
  </li>
  <li>
    <p>사용자 스택은 가장 큰 합법적 사용자 주소(2^48-1) 아래에서 시작해서 더 작은 메모리 주소 방향인 아래로 성장</p>
  </li>
  <li>
    <p>스택 위의 영역은 운영체제의 메모리 상주 부분인 커널의 코드와 데이터를 위해 예약</p>
  </li>
</ul>

<h3 id="로더-실행">로더 실행</h3>

<p>로더가 실행되면 아래와 같은 workflow를 가진다</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">                               </span><span class="err">┌</span><span class="w"> </span><span class="err">가상</span><span class="w"> </span><span class="err">메모리┐</span><span class="w">    </span><span class="err">로더가</span><span class="w"> </span><span class="err">프로그램의</span><span class="w"> </span><span class="nv">Entry</span><span class="w"> </span><span class="nv">point</span><span class="err">로</span><span class="w"> </span><span class="nv">jump</span><span class="w">     </span><span class="o">_</span><span class="nv">start</span><span class="w"> </span><span class="err">함수가</span><span class="w"> </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="err">호출</span><span class="w">     </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="o">:</span><span class="w">
</span><span class="err">로더</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="err">파일</span><span class="w"> </span><span class="err">덩어리</span><span class="w"> </span><span class="o">-&gt;</span><span class="err">│</span><span class="nv">data</span><span class="w"> </span><span class="nv">segment</span><span class="err">│</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">  </span><span class="err">┌────────────</span><span class="nv">crt1</span><span class="o">.</span><span class="nv">o</span><span class="err">────────────┐</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="err">┌────────────</span><span class="nv">libc</span><span class="o">.</span><span class="nv">so</span><span class="err">────────────┐</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">            </span><span class="o">-</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="err">환경</span><span class="w"> </span><span class="err">초기화</span><span class="w">
                           </span><span class="err">복사│</span><span class="nv">code</span><span class="w"> </span><span class="nv">segment</span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w">        </span><span class="o">_</span><span class="nv">start</span><span class="w"> </span><span class="err">함수</span><span class="w"> </span><span class="err">실행</span><span class="w">        </span><span class="err">│</span><span class="w">     </span><span class="err">│</span><span class="w">   </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="err">함수</span><span class="w"> </span><span class="err">실행</span><span class="w">  </span><span class="err">│</span><span class="w">                </span><span class="o">-</span><span class="w"> </span><span class="err">사용자</span><span class="w"> </span><span class="err">수준의</span><span class="w"> </span><span class="nv">main</span><span class="w"> </span><span class="err">함수호출</span><span class="w">
                               </span><span class="err">└───────────┘</span><span class="w">     </span><span class="err">└──────────────────────────────┘</span><span class="w">       </span><span class="err">└──────────────────────────────┘</span><span class="w">                 </span><span class="o">-</span><span class="w"> </span><span class="nv">return</span><span class="err">값</span><span class="w"> </span><span class="err">처리</span><span class="w">
                                                                                                                                         </span><span class="o">-</span><span class="w"> </span><span class="err">필요한</span><span class="w"> </span><span class="err">경우</span><span class="w"> </span><span class="err">제어권을</span><span class="w"> </span><span class="err">커널로</span><span class="w"> </span><span class="err">넘겨줌</span><span class="w">
</span></code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[C언어로 직접 Malloc을 구현해보자]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">링커(Linking)</title><link href="/blog/computersystem/linking/" rel="alternate" type="text/html" title="링커(Linking)" /><published>2025-04-21T00:00:00+00:00</published><updated>2025-04-21T00:00:00+00:00</updated><id>/blog/computersystem/linking</id><content type="html" xml:base="/blog/computersystem/linking/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#링커의-역할" id="markdown-toc-링커의-역할">링커의 역할</a>    <ul>
      <li><a href="#링킹을-왜-배워야-할까" id="markdown-toc-링킹을-왜-배워야-할까">링킹을 왜 배워야 할까?</a></li>
    </ul>
  </li>
  <li><a href="#정적-연결" id="markdown-toc-정적-연결">정적 연결</a></li>
  <li><a href="#목적파일" id="markdown-toc-목적파일">목적파일</a></li>
  <li><a href="#재배치-가능-목적파일with-elf--executable-and-linkable-format" id="markdown-toc-재배치-가능-목적파일with-elf--executable-and-linkable-format">재배치 가능 목적파일(with ELF : Executable and Linkable Format)</a></li>
  <li><a href="#실행-가능-목적파일의-로딩" id="markdown-toc-실행-가능-목적파일의-로딩">실행 가능 목적파일의 로딩</a>    <ul>
      <li><a href="#로더-실행" id="markdown-toc-로더-실행">로더 실행</a></li>
    </ul>
  </li>
</ul>

<p><strong>링킹(linking)</strong>은 여러 개의 코드와 데이터를 모아서 연결하여 메모리에 로드될 수 있고 실행될 수 있는 한 개의 파일로 만드는 작업이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">로더에 의해서 실행</th>
      <th style="text-align: center">응용프로그램에 의해서 실행</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">링커 수행 시기</td>
      <td style="text-align: center">로드 타임</td>
      <td style="text-align: center">실행 시</td>
    </tr>
  </tbody>
</table>

<h2 id="링커의-역할">링커의 역할</h2>

<p>링커는 독립적인 컴파일을 가능하게 한다. 이 뜻이 뭐냐하면, 큰 규모의 응용프로그램을 한 개의 소스 파일로 구성하는 대신에 컴파일할 수 있는 보다 관리할 만한 규모의 더 작은 모듈들로 나눌 수 있다. 그리고 이거를 별도로 수정할 수 있게 된다.</p>

<ul>
  <li>모듈 중에 한 개를 변경할 때, 이 파일만을 간단히 재컴파일하고 다른 파일들을 재컴파일할 필요 없이 이 응용을 다시 링크한다.</li>
</ul>

<h3 id="링킹을-왜-배워야-할까">링킹을 왜 배워야 할까?</h3>

<ul>
  <li>
    <p><strong>큰 규모의 프로그램을 개발</strong>할 때, 링킹을 사용하게 될 텐데, <strong>어떻게 링커가 참조를 핵결해 나가는지, 라이브러리가 무엇인지를 배워서 링커 에러를 해결할 수 있다.</strong></p>
  </li>
  <li>
    <p>언어의 <strong>변수 영역 규칙이 구현되었는지 이해</strong>하는데 도움이 된다. 예를 들어, <strong>전역변수와 지역변수의 차이</strong>는 무엇인가?</p>
  </li>
  <li>
    <p><strong>공유 라이브러리에 대해 이해</strong>할 수 있다.</p>
  </li>
</ul>

<p>더 여러가지가 있지만, 내 기준에서 중요할 것 같은 내용들만 뽑아왔다.</p>

<h2 id="정적-연결">정적 연결</h2>

<p><strong>재배치 가능한 목적파일(.o)들</strong>과 <strong>명령줄 인자들을 입력</strong>으로 받아들여서 로드될 수 있고 실행될 수 있는 완전히 링크된 실행 가능 목적파일을 출력으로 생성한다.</p>

<p>실행파일을 만들기 위해서 링커는 두 가지 주요 작업을 수행해야 함</p>

<ol>
  <li><strong>심볼 해석(symbol resolution)</strong> : 목적파일들은 심볼들을 정의하고 참조하며 여기서 각 심볼은 함수, 전역변수 또는 정적변수(즉, C언어에서 static으로 선언된 모든 변수들)에 대응된다</li>
</ol>

<ul>
  <li>심볼 해석의 <strong>목적</strong>은 <strong>각각의 심볼 참조를 정확하게 하나의 심볼 정의에 연결</strong>하는 것임</li>
</ul>

<ol>
  <li><strong>재배치(relocation)</strong> : 컴파일러와 어셈블러는 주소 0번지에서 시작하는 코드와 데이터 섹션들을 생성. 링커는 <strong>이 섹션들을 각 심볼 정의와 연결시켜서 재배치 하며, 이 심볼들로 가는 모든 참조들을 수정해서 이들이 이 메모리 위치를 가리키도록 한다</strong></li>
</ol>

<h2 id="목적파일">목적파일</h2>

<p>목적파일에는 세 가지 형태가 있어</p>

<ul>
  <li>
    <p>재배치 가능 목적파일(Relocatable object file) : 포맷에 컴파일 할 때 <strong>실행 가능 목적파일을 생성하기 위해 다른 재구성가능 목적파일들과 결합될 수 있는 바이너리 코드와 데이터를 포함</strong>한다</p>

    <ul>
      <li>.o 로 끝나는 파일들이 그 예이다</li>
    </ul>
  </li>
  <li>
    <p>실행 가능 목적파일(Executable object file) : 메모리에 직접 복사될 수 있고 <strong>실행될 수 있는 형태</strong>로 바이너리 코드와 데이터를 포함</p>
  </li>
  <li>
    <p>공유 목적파일(Shared object file) : 로드타임(Load time) 또는 런타임(Runtime)시에 동적으로 링크되고 메모리에 로드될 수 있는 특수한 유형의 <strong>재배치 가능 목적파일</strong>이다</p>
  </li>
</ul>

<p><strong>컴파일러와 어셈블러</strong>는 재배치 가능 목적파일을 생성하고 <strong>링커</strong>는 실행 가능한 목적파일을 생성함</p>

<h2 id="재배치-가능-목적파일with-elf--executable-and-linkable-format">재배치 가능 목적파일(with ELF : Executable and Linkable Format)</h2>

<ul>
  <li><strong>ELF</strong> : 리눅스 같은 유닉스 시스템에서 실행 파일이나 오브젝트 파일을 위한 <strong>표준 포맷</strong>이다(예 : .o 파일이나 a.out 파일)</li>
</ul>

<p>아래의 표는 ELF 재배치 가능 목적파일의 포맷을 보여준다</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">┌</th>
      <th style="text-align: center">ELF header</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">s</td>
      <td style="text-align: center">.text</td>
    </tr>
    <tr>
      <td style="text-align: center">e</td>
      <td style="text-align: center">.rodata</td>
    </tr>
    <tr>
      <td style="text-align: center">c</td>
      <td style="text-align: center">.data</td>
    </tr>
    <tr>
      <td style="text-align: center">t</td>
      <td style="text-align: center">.bss</td>
    </tr>
    <tr>
      <td style="text-align: center">i</td>
      <td style="text-align: center">.symtab</td>
    </tr>
    <tr>
      <td style="text-align: center">o</td>
      <td style="text-align: center">.rel.text</td>
    </tr>
    <tr>
      <td style="text-align: center">n</td>
      <td style="text-align: center">.rel.data</td>
    </tr>
    <tr>
      <td style="text-align: center">s</td>
      <td style="text-align: center">.debug</td>
    </tr>
    <tr>
      <td style="text-align: center">└</td>
      <td style="text-align: center">.line</td>
    </tr>
    <tr>
      <td style="text-align: center">Describes object file sections</td>
      <td style="text-align: center">Section header table</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>ELF header : ELF 파일의 <strong>맨 처음에 위치한 아주 중요한 정보 블록</strong>으로써, “이 파일은 ELF 파일입니다”를 알려주고 “이 파일은 ELF 파일입니다” 문구는 운영체제나 링커가 확인. 이 파일을 생성한 워드 크기와 시스템의 바이트 순서를 나타내는 16바이트 배열로 시작함</p>

    <ul>
      <li>
        <p>나머지는 링커가 목적파일을 구문분석하고 해석하도록 하는 정보를 포함하고 있음</p>
      </li>
      <li>
        <p>여기에는 ELF header의 크기, 목적파일 타입(예: 재배치 가능, 실행 가능, 공유), 머신 타임(예: x86-64), section header table의 파일 오프셋, section header table의 크기와 엔트리 수가 들어 있다.</p>
      </li>
      <li>
        <p>여러 가지 섹션들의 위치와 크기는 section header table로 나타내며, 이 테이블은 목적파일의 각 섹션에 대해 고정된 크기의 엔트리를 가짐</p>
      </li>
    </ul>
  </li>
  <li>
    <p>.text : 컴파일된 프로그램의 머신 코드</p>
  </li>
  <li>
    <p>.rodata printf : 문장의 포맷 스트링, switch 문의 점프 테이블과 같은 읽기-허용 데이터</p>
  </li>
  <li>
    <p>.data : <strong>초기화된 C 전역변수 및 전역변수</strong>이며, 실제로 파일 안에 값이 저장됨<strong>(Disk 공간 차지)</strong></p>

    <ul>
      <li>
        <p>int a = 10; → Binary 파일에 기록됨 → a의 초기값 10이 포함된 형태로 .data 섹션에 저장</p>
      </li>
      <li>
        <p>만약 아래처럼 a가 지역 변수라면? 지역 변수는 스택에 들어가기 때문에, .data에 들어가지 않아</p>
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// 지역 변수 👉 스택에 들어감 ❗</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>.bss : <strong>초기화되지 않은 C 전역변수와 정적변수 그리고 0으로 초기화된 전역변수 및 정적변수</strong>이며, 실제 공간을 차지하지 않고 단순히 위치를 표시해(Disk 공간 차지하지 않음)</p>

    <ul>
      <li>
        <p>int b; 또는 static int c; → 초기화되지 않은 전역/정적 변수로 .bss 공간에 해당</p>

        <ul>
          <li>b의 값 또는 c의 값이 쓰래기 값이면 어떻게 될까? 운영체제가 프로그램을 메모리에 올릴 때, .bss 영역에 있는 변수들은 자동으로 0으로 채움!</li>
        </ul>
      </li>
      <li>
        <p>int y = 0; → 0으로 초기화된 전역/정적 변수로 .bss 공간에 해당</p>
      </li>
    </ul>
  </li>
  <li>
    <p>rel.text : 링커가 이 목적파일을 다른 파일들과 연결할 때 수정되어야 하는 .text 섹션 내 위치들의 리스트</p>

    <ul>
      <li>일반적으로 외부 함수를 호출하거나 전역변수를 참조하는 인스트럭션들은 모두 수정 되어야 하고 이 수정을 위해서 위치들의 정보를 갖고 있는게 아닐까 싶다</li>
    </ul>
  </li>
  <li>
    <p>rel.data : 해당 모듈에 의해 정의되거나 참조되는 전역변수들에 대한 재배치 정보</p>

    <ul>
      <li>일반적으로 초기값이 전역변수 또는 외부에 정의된 함수의 주소인 초기화된 전역변수들 모두 수정되어야 한다</li>
    </ul>
  </li>
  <li>
    <p>.debug : 프로그램 내에서 정의도니 지역변수들과 typedef, 프로그램과 최초 C 소스 파일에서 정의되고 참조되는 전역변수들을 위한 엔트리를 갖는 <strong>디버깅 심볼 테이블</strong></p>

    <ul>
      <li>컴파일러 드라이버가 -g 옵션으로 불린 경우에 생성됨</li>
    </ul>
  </li>
  <li>
    <p>.line : 최초 C 소스 프로그램과 .text 섹션 내 머신 코드 인스트럭션 내 라인 번호들간의 매핑</p>

    <ul>
      <li>컴파일러 드라이버가 -g 옵션으로 불린 경우에 생성됨</li>
    </ul>
  </li>
  <li>
    <p>.strtab : .strtab과 .debug 섹션들 내에 있는 심볼 테이블과 섹션 헤더들에 있는 섹션 이름들을 위한 스트링 테이블. 스트링 테이블은 널 문자로 종료된 스트링의 배열</p>
  </li>
</ul>

<h2 id="실행-가능-목적파일의-로딩">실행 가능 목적파일의 로딩</h2>

<p>우리가 실행 가능 목적파일을 실행하기 위해 아래와 같은 명령어를 타입해</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux&gt; ./prog
</code></pre></div></div>

<p>그러면 이 실행 가능 목적파일이 어떻게 로딩될까?</p>

<ul>
  <li>
    <p><strong>prog</strong>는 내장 Shell 명령어가 아니야. 그래서 Shell은 prog가 실행 가능한 목적파일이라고 생각하고 Loader 라는 메모리 상주 운영체제 코드를 호출해. 호출해서 이 프로그램을 실행해</p>

    <ul>
      <li>
        <p>리눅스 프로그램은 <strong>execve</strong> 함수를 호출해서 Loader를 호출할 수 있어</p>
      </li>
      <li>
        <p>Loader는 Disk로부터 실행 가능한 목적파일 내의 코드와 데이터를 메모리로 복사하고 이 프로그램의 첫 번째 Instruction, 즉 Entry point로 Jump해서 프로그램을 실행해</p>
      </li>
      <li>
        <p><strong>위와 같이 프로그램을 메모리로 복사하고 실행하는 과정을 Loading</strong>이라함</p>
      </li>
    </ul>
  </li>
</ul>

<p>모든 실행 중인 리눅스 프로그램은 아래 사진과 같은 런타임 메모리 이미지를 가진다</p>

<p><img src="/assets/img/blog/computerscience/LinuxRuntimeMemory.png" alt="런타임 메모리 이미지" /></p>

<ul>
  <li>
    <p>리눅스 시스템에서 code segment는 주소 0x400000에서 시작</p>
  </li>
  <li>
    <p>뒤이어 data segment(Read/write segment)가 옴</p>

    <ul>
      <li>실제로는 code와 data segment 사이에 공간이 존재함</li>
    </ul>
  </li>
  <li>
    <p>Run-time heap은 data segment 다음에 따라오고 malloc 라이브러리를 호출해서 위로 성장</p>
  </li>
  <li>
    <p>이 다음에는 공유 모듈(shared libraries)들을 위해 예약된 영역이 존재</p>
  </li>
  <li>
    <p>사용자 스택은 가장 큰 합법적 사용자 주소(2^48-1) 아래에서 시작해서 더 작은 메모리 주소 방향인 아래로 성장</p>
  </li>
  <li>
    <p>스택 위의 영역은 운영체제의 메모리 상주 부분인 커널의 코드와 데이터를 위해 예약</p>
  </li>
</ul>

<h3 id="로더-실행">로더 실행</h3>

<p>로더가 실행되면 아래와 같은 workflow를 가진다</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">                               </span><span class="err">┌</span><span class="w"> </span><span class="err">가상</span><span class="w"> </span><span class="err">메모리┐</span><span class="w">    </span><span class="err">로더가</span><span class="w"> </span><span class="err">프로그램의</span><span class="w"> </span><span class="nv">Entry</span><span class="w"> </span><span class="nv">point</span><span class="err">로</span><span class="w"> </span><span class="nv">jump</span><span class="w">     </span><span class="o">_</span><span class="nv">start</span><span class="w"> </span><span class="err">함수가</span><span class="w"> </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="err">호출</span><span class="w">     </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="o">:</span><span class="w">
</span><span class="err">로더</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="err">파일</span><span class="w"> </span><span class="err">덩어리</span><span class="w"> </span><span class="o">-&gt;</span><span class="err">│</span><span class="nv">data</span><span class="w"> </span><span class="nv">segment</span><span class="err">│</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">  </span><span class="err">┌────────────</span><span class="nv">crt1</span><span class="o">.</span><span class="nv">o</span><span class="err">────────────┐</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="err">┌────────────</span><span class="nv">libc</span><span class="o">.</span><span class="nv">so</span><span class="err">────────────┐</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">            </span><span class="o">-</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="err">환경</span><span class="w"> </span><span class="err">초기화</span><span class="w">
                           </span><span class="err">복사│</span><span class="nv">code</span><span class="w"> </span><span class="nv">segment</span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w">        </span><span class="o">_</span><span class="nv">start</span><span class="w"> </span><span class="err">함수</span><span class="w"> </span><span class="err">실행</span><span class="w">        </span><span class="err">│</span><span class="w">     </span><span class="err">│</span><span class="w">   </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="err">함수</span><span class="w"> </span><span class="err">실행</span><span class="w">  </span><span class="err">│</span><span class="w">                </span><span class="o">-</span><span class="w"> </span><span class="err">사용자</span><span class="w"> </span><span class="err">수준의</span><span class="w"> </span><span class="nv">main</span><span class="w"> </span><span class="err">함수호출</span><span class="w">
                               </span><span class="err">└───────────┘</span><span class="w">     </span><span class="err">└──────────────────────────────┘</span><span class="w">       </span><span class="err">└──────────────────────────────┘</span><span class="w">                 </span><span class="o">-</span><span class="w"> </span><span class="nv">return</span><span class="err">값</span><span class="w"> </span><span class="err">처리</span><span class="w">
                                                                                                                                         </span><span class="o">-</span><span class="w"> </span><span class="err">필요한</span><span class="w"> </span><span class="err">경우</span><span class="w"> </span><span class="err">제어권을</span><span class="w"> </span><span class="err">커널로</span><span class="w"> </span><span class="err">넘겨줌</span><span class="w">
</span></code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[링킹(linking)은 여러 개의 코드와 데이터를 모아서 연결하여 메모리에 로드될 수 있고 실행될 수 있는 한 개의 파일로 만드는 작업이다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">전위 순회(Pre-Order Traversal)와 후위 순회(Post-Order Traversal)의 연관성</title><link href="/blog/algorithm/pre-order-post-order/" rel="alternate" type="text/html" title="전위 순회(Pre-Order Traversal)와 후위 순회(Post-Order Traversal)의 연관성" /><published>2025-04-16T00:00:00+00:00</published><updated>2025-04-16T00:00:00+00:00</updated><id>/blog/algorithm/pre-order-post-order</id><content type="html" xml:base="/blog/algorithm/pre-order-post-order/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#전위-순회와-후위-순회의-구조적인-연관성" id="markdown-toc-전위-순회와-후위-순회의-구조적인-연관성">전위 순회와 후위 순회의 구조적인 연관성</a>    <ul>
      <li><a href="#표준-전위-순회-vs-변형-전위-순회" id="markdown-toc-표준-전위-순회-vs-변형-전위-순회">표준 전위 순회 vs 변형 전위 순회</a></li>
      <li><a href="#변형-전위-순회를-뒤집으면" id="markdown-toc-변형-전위-순회를-뒤집으면">변형 전위 순회를 뒤집으면?</a></li>
      <li><a href="#표준-전위-순회--변형-전위-순회--후위-순회-예제" id="markdown-toc-표준-전위-순회--변형-전위-순회--후위-순회-예제">표준 전위 순회 / 변형 전위 순회 / 후위 순회 예제</a></li>
      <li><a href="#c언어-예제" id="markdown-toc-c언어-예제">C언어 예제</a></li>
    </ul>
  </li>
</ul>

<p>C언어를 통해 재귀 없이 Stack 2개를 활용하여 후위순회를 진행하는 코드를 보고 전위순회와 후위순회의 구조적 연관성이 있겠다는 생각이 들었다. 왜냐하면, 1개의 스택은 전위순회의 구조를 바꾼 형태였고 나머지 스택 하나는 그 한개의 스택을 역순으로 출력하기 위해 존재 했었기 때문이다.</p>

<h2 id="전위-순회와-후위-순회의-구조적인-연관성">전위 순회와 후위 순회의 구조적인 연관성</h2>

<p>먼저 결론부터 얘기하자면, <strong>전위 순회의 구조를 살짝 바꾸고 나온 결과를 뒤집으면 후위 순회 순서와 같아짐</strong></p>

<h3 id="표준-전위-순회-vs-변형-전위-순회">표준 전위 순회 vs 변형 전위 순회</h3>

<ul>
  <li>
    <p>표준 전위 순회 : (Root) → (Left) → (Right)</p>
  </li>
  <li>
    <p>변형 전위 순회 : (Root) → (Right) → (Left)</p>
  </li>
</ul>

<h3 id="변형-전위-순회를-뒤집으면">변형 전위 순회를 뒤집으면?</h3>

<ul>
  <li>
    <p><strong>뒤집은</strong> 변형 전위 순회 : (Left) → (Right) → (Root)</p>
  </li>
  <li>
    <p>표준 후위 순회 : (Left) → (Right) → (Root)</p>
  </li>
</ul>

<h3 id="표준-전위-순회--변형-전위-순회--후위-순회-예제">표준 전위 순회 / 변형 전위 순회 / 후위 순회 예제</h3>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">        </span><span class="nv">A</span><span class="w">
       </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">
      </span><span class="nv">B</span><span class="w">   </span><span class="nb">C</span><span class="w">
     </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">   </span><span class="err">\</span><span class="w">
    </span><span class="nb">D</span><span class="w">   </span><span class="nb">E</span><span class="w">   </span><span class="nv">F</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>표준 전위 순회 (Root → Left → Right)
    <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">A</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">D</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">E</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">C</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">F</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>변형 전위 순회 (Root → Right → Left)
    <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">A</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">C</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">F</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">E</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">D</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>후위 순회 (Left → Right → Root)
    <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">D</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">E</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">F</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">C</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">A</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<h3 id="c언어-예제">C언어 예제</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">postOrderIterativeS2</span><span class="p">(</span><span class="n">BSTNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">Stack</span> <span class="o">*</span><span class="n">stk1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Stack</span><span class="p">));</span>
	<span class="n">Stack</span> <span class="o">*</span><span class="n">stk2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Stack</span><span class="p">));</span>
	<span class="n">stk1</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">stk2</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">push</span><span class="p">(</span><span class="n">stk1</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">stk1</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">BSTNode</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">stk1</span><span class="p">);</span>
		<span class="n">push</span><span class="p">(</span><span class="n">stk2</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
			<span class="n">push</span><span class="p">(</span><span class="n">stk1</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
			<span class="n">push</span><span class="p">(</span><span class="n">stk1</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">stk2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">BSTNode</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">stk2</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">free</span><span class="p">(</span><span class="n">stk1</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">stk2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/Algorithm.png" /><media:content medium="image" url="/assets/img/blog/postimage/Algorithm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">크래프톤 정글에서 첫달을 보낸 후</title><link href="/blog/diary/first_month/" rel="alternate" type="text/html" title="크래프톤 정글에서 첫달을 보낸 후" /><published>2025-04-14T00:00:00+00:00</published><updated>2025-04-14T00:00:00+00:00</updated><id>/blog/diary/first_month</id><content type="html" xml:base="/blog/diary/first_month/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#0주차" id="markdown-toc-0주차">0주차</a>    <ul>
      <li><a href="#해요일" id="markdown-toc-해요일">해요일</a></li>
    </ul>
  </li>
  <li><a href="#1주차" id="markdown-toc-1주차">1주차</a></li>
  <li><a href="#2주차" id="markdown-toc-2주차">2주차</a></li>
  <li><a href="#3주차" id="markdown-toc-3주차">3주차</a></li>
  <li><a href="#4주차" id="markdown-toc-4주차">4주차</a></li>
</ul>

<p>벌써 1달이라는 시간이 지났다. 아무래도 블로그 운영이 취업 목적과도 연관이 있어서 꾸준히 배운것에 대해 포스팅은 진행했지만, 배운것 외에 내가 느낀점에 대해서는 포스팅하지 않았고 필요도 느끼지 못했다. 그런데, 결국에 배운것은 모두 GPT가 알려준 것이어서 블로그 포스팅이 의미없지 않냐는 다른 정글러분의 의견에 생각이 바뀌어서 정글 5개월 동안 1개월마다 회고록을 써보고자 한다. 먼저 시간대별로 느꼈던점을 기술하는것이 정리가 잘 될거 같아서 시간대별로 내가 느낀점을 적도록 하겠다.</p>

<h2 id="0주차">0주차</h2>

<p>처음 들어왔을때, 설렘 반 긴장 반의 감정으로 들어왔던것 같다. 나에게는 너무 큰 도전이었기에, 첫날에 나온 식사는 잘 넘어가지 않았다.</p>

<p>처음에 내주었던 과제는 웹 서비스 개발 프로젝트였고, 기획부터 해서 배포까지 하는것이 과제였다. 어떤 웹서비스를 구현할지 고민했고, 크래프톤 정글 프로그램상 일요일날에는 식사가 제공되지 않아서 이때 나가서 밥 같이 먹을 사람, 아님 취미를 같이 해볼 수 있도록 도와주는 웹 서비스를 구현하기로 팀원끼리 합의했다.</p>

<h3 id="해요일">해요일</h3>

<p><strong>일요일날은 해日와 관련이 있고, 또 뭔가를 하자는 의미에서 해요일</strong>이라고 우리의 웹 서비스를 구현하고자 했다. 해당 프로젝트는 이 블로그 Projects에 있으니 참고 가능하다.</p>

<p>팀원이 3명으로 이루어졌고 나 빼고 2명은 전공자셨기 때문에, 내가 과연 도움이 될까 싶었다. 아무래도 그분들보다 Python이든, html을 다뤄보지 않았기 때문이다. 어쨋든 시간은 3일 밖에 주어지지 않았고 도움이 되어야만 했다.</p>

<p>웹 서비스 구현할때, Tailwind CSS, JWT, Jinja 를 포함시켜서 구현을 해야 했다. 우리가 원해서는 아니었고 과제 세부사항으로써 의무였다. Jinja 같은 경우 어려워서 먼저 javascript에 ajax 사용해서 만든 코드를 GPT한테 Jinja 코드로 변환시켜 달라고 해서 구현을 했고, Tailwind CSS는 웹페이지에 있는것 따라하면서 구현을 했다.</p>

<p>현준이라는 정글러님이 디자인 감각이 좋으셔서 내가 만들었던 페이지를 개선시켜주셨다. 덕분에 프로젝트의 미적 부분이 많아 좋아졌다. 또한 성현 정글러님이 백엔드(Python)쪽을 빠르게 구현해 주셔서 페이지 하나하나 연결시키는게 빨랐고 덕분에 우리가 구현하고자 했던 웹 서비스를 모두 구현 시킬 수 있었다. 나는 front-end를 맡았고 Main page, My page, 구현과 회원가입때 e-mail OTP 구현같은 경우 front와 back 모두 맡았다.</p>

<p>최종적으로 시연까지 발표하니까 성취감을 느꼈고 동료애를 많이 느꼈다. 그러면서도 걱정이 들었던 것은 이 정도 강도를 5개월동안 유지못할 것 같다는 것이었다. 어쨌든 미래의 걱정은 제쳐두고 최종 발표 저녁때 삼겹살 파티를 쥐최해주셔서 맛있게 먹고 빨리 쉬러 들어갔다.</p>

<h2 id="1주차">1주차</h2>

<p>0주차가 끝나고 다시 새로운 팀원 배정이 이루어 지게 되었다. 1주차가 시작되면서 발제가 이루어졌고 발제때의 내용을 들어보니 다행히도 강도가 많이 내려갔다. 그런데, 이미 0주차때 많이 쏟아 부어서인지 0주차에 버금가는 집중력을 유지하게 되는 주였다. 아마 이 집중력은 이 글을 쓰는 5주차에도 계속 유지가 되었단 것을 알려주고 싶다.</p>

<p>1주차에는 Python 기초부터 다지기 시작했고 Baekjoon 문제를 풀어보는 주가 되었다. 하 난이도부터 중,상 난이도로 나누어서 모든 문제를 풀라는 과제를 내주셨고 이때 많은 문제를 풀어보면서 Python 언어와 많이 친숙해 질 수 있었다. 백준 문제들 중 입출력/조건문/반복문/배열/함수/문자열/수학/재귀함수/정렬/완전 탐색의 종류인 문제를 풀었다.</p>

<p>Python 외적으로는 <strong>Computer Systems A Programmer’s Perspective</strong> 책 1장을 읽었고 hello.c가 응용 목적 프로그램까지 어떻게 저장(컴파일)되는지 각 단계별로 간단하게 알게 되는 한주였다.</p>

<p>또한 시간 복잡도와 공간 복잡도에 대해서 배웠고 이걸 BigO로 어떻게 표현되는지에 대해서도 배웠다. 정렬 알고리즘에 대해서 많이 배우게 되는 한주였는데, 버블/단순 선택/단순 삽입/이진 삽입/셸/퀵/병합/힙 정렬에 대해서 배웠다.</p>

<p>첫주여서 그런지 조금 만만하게 생각했던 점이 있다. 하지만 목요일날에 봤던 시험을 만족스럽게 보지 못해서 반성하는 계기가 되었다.</p>

<h2 id="2주차">2주차</h2>

<p>첫주차에서 반성하는 계기를 통해서 2주차때는 조금 더 열심히 해보고자 하였다. 먼저 팀원들과의 코어타임을 조금 더 도움되게 바꾸기 위해 첫주차에서 어떻게 진행했는지 물어보았고 좋은 것들을 채택해 진행하기로 했다. 덕분에 매 코어타임이 모두에게 도움되는 시간이었고 이후부터 어떻게 공부할지, 그리고 어떻게 함께 지식을 공유해야 할지 배우게 되었다.</p>

<p>2주차에서 알고리즘 같은 경우 이분 탐색/분할 정복/스택/큐/우선순위 큐에 대해 배우게 되었는데, 지금 생각해보면 이때 열심히 공부했던 것이 빛을 발하게 된것 같다. 현재 C 언어에서 스택과 큐를 사용해 함수 구현하고 있는데, 2주차때 배웠던 내용들이 알고리즘의 중추였다고 느낀다. 여러 알고리즘이 있지만, 특히 스택과 큐, 그리고 우선순위 큐가 지금으로써 도움이 많이 된다.</p>

<p>Computer System 같은 경우 캐시 / 가상 메모리의 계층 / 운영체제의 대략적인 역할을 배우게 되었다. 스택 같은 경우 위에서 아래로, 큐 같은 경우 아래에서 위로 저장이 된다고 배웠고 이게 서로 만난다면 충돌이 날 수도 있으니 주의하라고 한점도 기억이 난다.</p>

<h2 id="3주차">3주차</h2>

<p>2주차에서 나름 공부를 잘했다고 느꼈고 이 느낀점 때문에 3주차에서는 조금 더 열심히 해볼 계기가 되었다. 첫날부터 리뷰할 시간 없이 코어타임을 저녁때 가지기로 했고, 이때 Computer System을 다루기로 했다. 짧은 시간이었지만, 집중력을 통해 <strong>인스트럭션들의 병렬성</strong>과 <strong>쓰레드의 동시성</strong>에 대해 설명할 수 있었고 이때 한 조원의 호기심으로 인해 Computer System 관하여 오래 논의를 나누었다.</p>

<p>그리고 알고리즘 관하여서는 처음으로 그래프(vetex, edge, node, arc)에 대해서 배우고 BFS, DFS, 위상정렬, 최단거리, 사이클 탐지, 최소 신장 트리, 자기 균형 이진 탐색 트리까지 많은 알고리즘을 할당 받아서 3주차도 집중을 놓치지 않고 모두 공부하였고, 물론 쉽진 않았다. 다행히도 다 할 수 있었단 것에 내 자신에게 고맙게 느끼는 한 주였다. 그리고 3주차에서는 다루는 내용도 많았지만, 중간 중간 팀원들이 새로운 지식을 알려줘서 더 발전하게 되는 한 주였다. 팀원들한테 고마움을 느낀다.</p>

<h2 id="4주차">4주차</h2>

<p>Python을 통해 알고리즘을 배우는 마지막 주 4주차에서는 많은 것을 얻어간것 같다. 알고리즘을 많이 배우진 않았지만, Computer System쪽에서 지식을 많이 얻게 되는 한 주였다. <strong>Computer Systems A Programmer’s Perspective</strong> 책 3장 전체를 다 보라는 과제가 있었고 아쉽게도 다 보진 못했지만, 레지스터에서 어떻게 인수를 저장하고 또 메모리에서 값을 받아오는 행위의 세부적인걸 알게 되었다.</p>

<p>알고리즘으로는 동적 프로그래밍과 그리디 알고리즘을 배웠다. 이상한게 2차원 배열의 움직임을 구현하는 것은 나에게 굉장히 어려웠는데, 시간이 해결을 해준건지 시험에서 나온 DP문제를 2차원 배열과 DPS 방식으로 풀게 되었다. 물론 백준 시간 초과가 나오게 되면서 문제를 풀었다고 할 수 없긴 했지만, 그래도 꾸준히 공부를 해왔던 것에 보람을 느끼게 되었다. 앞으로 난관을 마주하게 되더라도 이런 경험에서 나왔듯이 시간이 해결해줄 것이라고 믿고 앞으로 나아갈것 같다.</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="diary" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4%EC%A0%95%EA%B8%80.jpg" /><media:content medium="image" url="/assets/img/blog/postimage/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4%EC%A0%95%EA%B8%80.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">크래프톤 정글에서 두번째 달을 보낸 후</title><link href="/blog/diary/second-month/" rel="alternate" type="text/html" title="크래프톤 정글에서 두번째 달을 보낸 후" /><published>2025-04-14T00:00:00+00:00</published><updated>2025-04-14T00:00:00+00:00</updated><id>/blog/diary/second-month</id><content type="html" xml:base="/blog/diary/second-month/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#5주차" id="markdown-toc-5주차">5주차</a></li>
  <li><a href="#6주차" id="markdown-toc-6주차">6주차</a></li>
</ul>

<p>벌써 1달이라는 시간이 지났다. 아무래도 블로그 운영이 취업 목적과도 연관이 있어서 꾸준히 배운것에 대해 포스팅은 진행했지만, 배운것 외에 내가 느낀점에 대해서는 포스팅하지 않았고 필요도 느끼지 못했다. 그런데, 결국에 배운것은 모두 GPT가 알려준 것이어서 블로그 포스팅이 의미없지 않냐는 다른 정글러분의 의견에 생각이 바뀌어서 정글 5개월 동안 1개월마다 회고록을 써보고자 한다. 먼저 시간대별로 느꼈던점을 기술하는것이 정리가 잘 될거 같아서 시간대별로 내가 느낀점을 적도록 하겠다.</p>

<h2 id="5주차">5주차</h2>

<p>파이썬으로 알고리즘을 배우는 첫 달이 끝나고, 이제는 C언어로 컴퓨터에게 깊이 빠져드는 첫 주가 되었다. 과제로 주어진 것은 Linked List/Stack and Queue/Binary Tree/Binary Search Tree 알고리즘 기반으로 문제를 푸는 것이었다.</p>

<p>C언어를 잘 몰랐기에, 먼저 Youtube의 6시간짜리 C 언어 기초 동영상으로 시작을 했다. 졸려가는걸 버티면서 3~4시간쯤 보았을 때, 다른 정들러분들이 문제를 시작한걸 보고 남들보다 진도가 조금 뒤쳐진다는걸 깨달았다. 그래서 우선 기초는 여기까지 마무리하고 문제로 넘어갔다.</p>

<p>문제로 넘어간 뒤에 2시간 동안 코드해석 하는 데에만 쏟았는데, 이 2시간이 의미가 있었다. 언어 해석하는데에 수월해지는 시간이었고 문제를 바로 풀 수 있었다. 5주차를 마무리 하면서 쓰는 결론으로는 Binary Tree 빼고 모든 문제는 다 풀 수 있었다. 당연히 문제를 본인 스스로 다 풀지는 못하였지만, 내 스스로 50%정도는 스스로 풀 수 있었다.</p>

<p>팀원분들과 첫 Core-time을 가졌을때, 많은 것을 얻을 수 있었다. 두분 모두 열심히 준비를 해주셔서 한 주를 잘 시작할 수 있었다. 다만, 아쉽게도 불가피한 사정으로 인해서 두 분 모두 시간을 온전히 투자할 수 있는 상황이 아니었어서 중간에 흐지부지 했었던점이 조금 아쉬웠다. 그럼에도 불구하고 5주차 때 열심히 했어서 많이 도움이 되었다.</p>

<h2 id="6주차">6주차</h2>

<p>6주차에서는 C언어로 Red-Black Tree를 구현하는 과제가 주어졌다. 여태까지 미리 미리 보아두라고 했었지만, 그러지 않았기 때문에, 나에게는 불똥이 떨어진 셈이다. 그나마 다행이었던 것은 모두 Red-Black Tree에 대해서 많이 알지 못했던 것이다. 그래서 같이 시작하면 됐다.</p>

<p>불똥이 떨어졌기 때문에, 트리에 대한 이해를 빠르게 해야만 했다. 첫날에 Red-Black Tree에 대해서 개념을 먼저 다지자고 팀원들과 얘기했고, 빠르게 공부를 시작했다. 아쉽게도 첫날에는 삽입에 대해서만 개념을 다루었고 그 다음날에 삭제까지 개념을 다지면서 마무리가 되었다.</p>

<p>개념을 다지고 이제 C언어로 구현을 해야 하는데, 막막한 느낌이 없지 않아 있었고 알고리즘(Introduction to ALGORITHMS)책을 통해 시작할 수 있게 되었다. 해당 책을 통해 많은 도움을 받았고 직접 구현하기 보다는 이미 짜여진 코드를 이해하는게 더 중요하다고 생각이 되었다. 그 이유에 대해서는, 처음으로 트리를 구현하는 것이었기 때문에, 처음부터 RBTree를 구현하는 것은 많은 시간을 쓸거라고 생각했고, 다른 과제들 또한 있었기 때문에 타협을 본 셈이다.</p>

<p>C언어로 RBTree 구현을 모두 마치고 CS:APP 책 8장과 9장을 읽어야 했다. 결론적으로 다 읽지는 못하였지만, 8장에서 예외처리를 위한 시그널과 9장에서 가상 메모리를 쓰는 이유에 대해 배울 수 있게 되었다. 팀원들과 가졌던 Core-time에서 내가 알고 있던 내용과 팀원들이 알고있던 내용에 다른점이 존재했다. 내가 알고 있던 내용이 맞았고 정정을 해주었던 점이 기억에 남는다. 앞으로도 깊게 파고드는 습관을 유지하면서 공부하고자 하는 계기를 만들었다. 그럼에도 불구하고, 과제를 모두 마치지 못한 첫 주가 되었고 많이 아쉬웠다. 완수를 못한점에 대해 만회하고자 차주부터 열심히 하고자 한다.</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="diary" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4%EC%A0%95%EA%B8%80.jpg" /><media:content medium="image" url="/assets/img/blog/postimage/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4%EC%A0%95%EA%B8%80.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">gcc(GNU Compiler Collection)</title><link href="/blog/c/gcc/" rel="alternate" type="text/html" title="gcc(GNU Compiler Collection)" /><published>2025-04-13T00:00:00+00:00</published><updated>2025-04-13T00:00:00+00:00</updated><id>/blog/c/gcc</id><content type="html" xml:base="/blog/c/gcc/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#gcc란" id="markdown-toc-gcc란">gcc란?</a></li>
  <li><a href="#gcc의-기본-사용법" id="markdown-toc-gcc의-기본-사용법">gcc의 기본 사용법</a>    <ul>
      <li><a href="#가장-기본적인-사용" id="markdown-toc-가장-기본적인-사용">가장 기본적인 사용</a></li>
      <li><a href="#실행" id="markdown-toc-실행">실행</a></li>
    </ul>
  </li>
  <li><a href="#컴파일-단계의-gcc-내부-동작" id="markdown-toc-컴파일-단계의-gcc-내부-동작">컴파일 단계의 gcc 내부 동작</a></li>
  <li><a href="#자주-쓰는-옵션들" id="markdown-toc-자주-쓰는-옵션들">자주 쓰는 옵션들</a></li>
  <li><a href="#기타-유용한-gcc-관련-도구들" id="markdown-toc-기타-유용한-gcc-관련-도구들">기타 유용한 gcc 관련 도구들</a>    <ul>
      <li><a href="#makefile이란" id="markdown-toc-makefile이란">Makefile이란?</a>        <ul>
          <li><a href="#구조예제" id="markdown-toc-구조예제">구조(예제)</a></li>
          <li><a href="#사용-방법" id="markdown-toc-사용-방법">사용 방법</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#docker에서-c-파일을-컴파일하고-실행하기" id="markdown-toc-docker에서-c-파일을-컴파일하고-실행하기">Docker에서 C 파일을 컴파일하고 실행하기</a>    <ul>
      <li><a href="#구조간단-예제" id="markdown-toc-구조간단-예제">구조(간단 예제)</a></li>
      <li><a href="#실행간단-예제" id="markdown-toc-실행간단-예제">실행(간단 예제)</a></li>
      <li><a href="#구조복잡한-예제-makefile-추가-사용" id="markdown-toc-구조복잡한-예제-makefile-추가-사용">구조(복잡한 예제, Makefile 추가 사용)</a></li>
      <li><a href="#실행복잡한-예제-makefile-추가-사용" id="markdown-toc-실행복잡한-예제-makefile-추가-사용">실행(복잡한 예제, Makefile 추가 사용)</a></li>
    </ul>
  </li>
  <li><a href="#자주-쓰는-dockerfile-팁" id="markdown-toc-자주-쓰는-dockerfile-팁">자주 쓰는 Dockerfile 팁</a></li>
  <li><a href="#정리" id="markdown-toc-정리">정리</a></li>
</ul>

<h2 id="gcc란">gcc란?</h2>

<p>gcc는 GNU Compiler Collection의 약자로, 원래는 C 언어 <strong>컴파일러(GNU C Compiler)</strong>로 시작했지만 지금은 C, C++, Objective-C, Fortran, Ada, Go 등 다양한 언어를 지원하는 컴파일러 모음이야</p>

<ul>
  <li>
    <p>C 언어 컴파일러로 가장 유명하고, 리눅스에서 표준처럼 사용돼</p>
  </li>
  <li>
    <p>윈도우에서도 MinGW, WSL, 또는 MSYS2 등을 통해 사용할 수 있어</p>
  </li>
  <li>
    <p>오픈소스이고 성능도 좋기 때문에 많은 시스템과 프로젝트에서 쓰이고 있어</p>
  </li>
</ul>

<h2 id="gcc의-기본-사용법">gcc의 기본 사용법</h2>

<h3 id="가장-기본적인-사용">가장 기본적인 사용</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc hello.c <span class="nt">-o</span> hello
</code></pre></div></div>

<ul>
  <li>
    <p>hello.c : 소스 파일</p>
  </li>
  <li>
    <p>o hello : 출력 파일 이름을 hello로 설정</p>
  </li>
</ul>

<h3 id="실행">실행</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./hello
</code></pre></div></div>

<h2 id="컴파일-단계의-gcc-내부-동작">컴파일 단계의 gcc 내부 동작</h2>

<p>C 코드를 실행 파일로 만들기 위해 gcc는 다음 네 가지 단계를 거쳐:</p>

<ol>
  <li>전처리(Preprocessing) :</li>
</ol>

<ul>
  <li>#include, #define 등의 전처리 지시문 처리</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-E</span> hello.c <span class="nt">-o</span> hello.i
</code></pre></div></div>

<ol>
  <li>컴파일(Compilation) :</li>
</ol>

<ul>
  <li>C 코드를 어셈블리어로 변환</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-S</span> hello.i <span class="nt">-o</span> hello.s
</code></pre></div></div>

<ol>
  <li>어셈블(Assembly) :</li>
</ol>

<ul>
  <li>어셈블리어 코드를 기계어로 변환 (객체 파일 .o)</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-c</span> hello.s <span class="nt">-o</span> hello.o
</code></pre></div></div>

<ol>
  <li>링크(Linking) :</li>
</ol>

<ul>
  <li>라이브러리와 함께 실행 파일을 생성</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc hello.o <span class="nt">-o</span> hello
</code></pre></div></div>

<p>✅ 위 단계를 한 줄 명령어로 묶은 게 그냥 gcc hello.c -o hello 라고 보면 돼!</p>

<h2 id="자주-쓰는-옵션들">자주 쓰는 옵션들</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">옵션</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-o <file></file></td>
      <td style="text-align: center">출력 파일 이름 지정</td>
    </tr>
    <tr>
      <td style="text-align: center">-wall</td>
      <td style="text-align: center">모든 경고 출력</td>
    </tr>
    <tr>
      <td style="text-align: center">-g</td>
      <td style="text-align: center">디버깅 정보 포함 (gdb로 디버깅할 때 필요)</td>
    </tr>
    <tr>
      <td style="text-align: center">-O0, -O1, -O2, -O3</td>
      <td style="text-align: center">최적화 수준 설정</td>
    </tr>
    <tr>
      <td style="text-align: center">-std=c99, -std=c11 등</td>
      <td style="text-align: center">C 표준 지정</td>
    </tr>
    <tr>
      <td style="text-align: center">-c</td>
      <td style="text-align: center">링크하지 않고 객체 파일까지만 생성</td>
    </tr>
    <tr>
      <td style="text-align: center">-I<dir></dir></td>
      <td style="text-align: center">헤더 파일 포함 디렉토리 지정</td>
    </tr>
    <tr>
      <td style="text-align: center">-L<dir></dir></td>
      <td style="text-align: center">라이브러리 디렉토리 지정</td>
    </tr>
    <tr>
      <td style="text-align: center">-l<lib></lib></td>
      <td style="text-align: center">라이브러리 링크 (-lm은 수학 라이브러리 libm.so를 의미)</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>예제 : 디버깅용 컴파일
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-g</span> hello.c <span class="nt">-o</span> hello
</code></pre></div>    </div>
  </li>
  <li>예제 : 최적화 적용
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-O2</span> hello.c <span class="nt">-o</span> hello
</code></pre></div>    </div>
  </li>
  <li>예제 : 여러 파일 컴파일
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc main.c utils.c <span class="nt">-o</span> myprogram
</code></pre></div>    </div>
  </li>
  <li>예제 : 객체 파일 따로 만들기
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-c</span> main.c <span class="nt">-o</span> main.o
gcc <span class="nt">-c</span> utils.c <span class="nt">-o</span> utils.o
gcc main.o utils.o <span class="nt">-o</span> myprogram
↑여러 객체 파일들을 하나의 실행파일로 합치는 과정<span class="o">(</span>함수 참조 등 이 단계에서 해결됨, 예 : main.c가 utils.c의 함수 호출<span class="o">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<ul>
  <li>4번 예제 같은 경우, 저 3개의 코드를 실행한 후, utils.c 만 수정한다면, 아래처럼 코드 실행이 필요함</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>utils.c 수정됨
↓
gcc <span class="nt">-c</span> utils.c
↓ 
gcc main.o utils.o <span class="nt">-o</span> myprogram<span class="o">(</span>링크<span class="o">)</span>
</code></pre></div></div>

<h2 id="기타-유용한-gcc-관련-도구들">기타 유용한 gcc 관련 도구들</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">도구</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">make</td>
      <td style="text-align: center">컴파일 자동화 도구(Makefile 사용)</td>
    </tr>
    <tr>
      <td style="text-align: center">gdb</td>
      <td style="text-align: center">GNU debugger</td>
    </tr>
    <tr>
      <td style="text-align: center">valgrind</td>
      <td style="text-align: center">메모리 누수 검사</td>
    </tr>
    <tr>
      <td style="text-align: center">objdump, nm, readelf</td>
      <td style="text-align: center">바이너리 분석 도구들</td>
    </tr>
  </tbody>
</table>

<h3 id="makefile이란">Makefile이란?</h3>

<p>Makefile은 C 프로젝트 빌드 자동화 도구인 make 명령어의 설정 파일이야. 컴파일 명령을 일일이 타이핑 안 해도 <strong>make</strong>만 치면 자동으로 빌드해줘!</p>

<h4 id="구조예제">구조(예제)</h4>

<p>디렉토리 구조</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">myproject</span><span class="o">/</span>
<span class="err">├──</span> <span class="nt">main</span><span class="nc">.c</span>
<span class="err">├──</span> <span class="nt">utils</span><span class="nc">.c</span>
<span class="err">├──</span> <span class="nt">utils</span><span class="nc">.h</span>
<span class="err">├──</span> <span class="nt">Makefile</span>
</code></pre></div></div>

<p>C 예시 파일(main.c)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"utils.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print_hello</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>C 예시 파일(utils.c)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">print_hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello from utils!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>C 예시 파일(utils.h)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef UTILS_H
#define UTILS_H
</span>
<span class="kt">void</span> <span class="nf">print_hello</span><span class="p">();</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p>Makefile 예시</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 변수 설정
</span><span class="nv">CC</span> <span class="o">=</span> gcc
<span class="nv">CFLAGS</span> <span class="o">=</span> <span class="nt">-Wall</span> <span class="nt">-g</span>

<span class="c"># 타겟: 의존 파일들
# 명령 (앞에 tab 필수!)
</span><span class="nl">all</span><span class="o">:</span> <span class="nf">main</span>

<span class="nl">main</span><span class="o">:</span> <span class="nf">main.o utils.o</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nt">-o</span> main main.o utils.o

<span class="nl">main.o</span><span class="o">:</span> <span class="nf">main.c utils.h</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nt">-c</span> main.c

<span class="nl">utils.o</span><span class="o">:</span> <span class="nf">utils.c utils.h</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nt">-c</span> utils.c

<span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="k">*</span>.o main
</code></pre></div></div>

<h4 id="사용-방법">사용 방법</h4>

<ul>
  <li>bash에서 아래 실행</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make        <span class="c"># main 실행파일 빌드</span>
make clean  <span class="c"># 중간파일 삭제</span>
</code></pre></div></div>

<ul>
  <li>gdb로 디버깅하기(C 프로그램을 한 줄씩 실행해보거나 변수 추적), 위에 Makefile 보면 아래와 같은 코드가 보일거야</li>
</ul>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span> <span class="o">=</span> <span class="nt">-Wall</span> <span class="nt">-g</span>
</code></pre></div></div>

<ul>
  <li>디버깅 실행은 bash에서</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb ./main
</code></pre></div></div>

<h2 id="docker에서-c-파일을-컴파일하고-실행하기">Docker에서 C 파일을 컴파일하고 실행하기</h2>

<h3 id="구조간단-예제">구조(간단 예제)</h3>

<p>C 예시 파일(hello.c)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello, Dockerized C!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dockerfile 예시</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># 1. gcc가 포함된 베이스 이미지 사용
</span><span class="n">FROM</span> <span class="n">gcc</span><span class="o">:</span><span class="n">latest</span>

<span class="cp"># 2. 작업 디렉토리 설정
</span><span class="n">WORKDIR</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span>

<span class="cp"># 3. 현재 디렉토리의 파일을 컨테이너로 복사
</span><span class="n">COPY</span> <span class="p">.</span> <span class="p">.</span>

<span class="cp"># 4. hello.c 파일 컴파일
</span><span class="n">RUN</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span> <span class="n">hello</span><span class="p">.</span><span class="n">c</span>

<span class="cp"># 5. 컨테이너 실행 시 hello 실행
</span><span class="n">CMD</span> <span class="p">[</span><span class="s">"./hello"</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="실행간단-예제">실행(간단 예제)</h3>

<ol>
  <li>도커 이미지 빌드
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> my-c-program <span class="nb">.</span>
</code></pre></div>    </div>
  </li>
  <li>컨테이너 실행
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--rm</span> my-c-program
</code></pre></div>    </div>
  </li>
</ol>

<ul>
  <li>출력 결과</li>
</ul>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Hello</span><span class="o">,</span><span class="w"> </span><span class="nv">Dockerized</span><span class="w"> </span><span class="nb">C</span><span class="o">!</span><span class="w">
</span></code></pre></div></div>

<h3 id="구조복잡한-예제-makefile-추가-사용">구조(복잡한 예제, Makefile 추가 사용)</h3>

<p>디렉토리 구조</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">my-c-project</span><span class="o">/</span>
<span class="err">├──</span> <span class="nt">main</span><span class="nc">.c</span>
<span class="err">├──</span> <span class="nt">utils</span><span class="nc">.c</span>
<span class="err">├──</span> <span class="nt">utils</span><span class="nc">.h</span>
<span class="err">├──</span> <span class="nt">Makefile</span>
<span class="err">├──</span> <span class="nt">Dockerfile</span>
</code></pre></div></div>

<p>Dockerfile 예시</p>
<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> gcc:latest</span>

<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="k">COPY</span><span class="s"> . .</span>

<span class="k">RUN </span>make

<span class="k">CMD</span><span class="s"> ["./app"]</span>
</code></pre></div></div>

<p>Makefile 예시</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">all</span><span class="o">:</span> <span class="nf">app</span>

<span class="nl">app</span><span class="o">:</span> <span class="nf">main.o utils.o</span>
	gcc <span class="nt">-o</span> app main.o utils.o

<span class="nl">main.o</span><span class="o">:</span> <span class="nf">main.c utils.h</span>
	gcc <span class="nt">-c</span> main.c

<span class="nl">utils.o</span><span class="o">:</span> <span class="nf">utils.c utils.h</span>
	gcc <span class="nt">-c</span> utils.c

<span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="k">*</span>.o app
</code></pre></div></div>

<h3 id="실행복잡한-예제-makefile-추가-사용">실행(복잡한 예제, Makefile 추가 사용)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> my-make-c-app <span class="nb">.</span>
docker run <span class="nt">--rm</span> my-make-c-app
</code></pre></div></div>

<h2 id="자주-쓰는-dockerfile-팁">자주 쓰는 Dockerfile 팁</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">용도</th>
      <th style="text-align: center">예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">디버깅용 빌드</td>
      <td style="text-align: center">RUN gcc -g -o hello hello.c</td>
    </tr>
    <tr>
      <td style="text-align: center">최적화 빌드</td>
      <td style="text-align: center">RUN gcc -02 hello hello.c</td>
    </tr>
    <tr>
      <td style="text-align: center">빌드 캐시 활용</td>
      <td style="text-align: center">COPY hello.c → Run gcc … 순서 중요</td>
    </tr>
    <tr>
      <td style="text-align: center">헤더/라이브러리 추가</td>
      <td style="text-align: center">apt-get install로 필요 패키지 추가</td>
    </tr>
  </tbody>
</table>

<h2 id="정리">정리</h2>

<ul>
  <li>
    <p>gcc는 컴파일러의 왕이자, 오픈소스 생태계의 심장</p>
  </li>
  <li>
    <p>그냥 C 코드 실행파일 만드는 툴이 아니라, 시스템 프로그래밍, 임베디드, 운영체제 개발까지 두루 쓰여</p>
  </li>
  <li>
    <p>옵션을 자유자재로 다루면 성능 개선이나 디버깅도 더 수월해져</p>
  </li>
</ul>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="c" /><category term="gcc" /><category term="GNU" /><category term="Compiler" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/C.png" /><media:content medium="image" url="/assets/img/blog/postimage/C.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">가상화(Virtualization)</title><link href="/blog/c/virtualization/" rel="alternate" type="text/html" title="가상화(Virtualization)" /><published>2025-04-13T00:00:00+00:00</published><updated>2025-04-13T00:00:00+00:00</updated><id>/blog/c/virtualization</id><content type="html" xml:base="/blog/c/virtualization/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#가상화의-종류" id="markdown-toc-가상화의-종류">가상화의 종류</a>    <ul>
      <li><a href="#전통적인-vm" id="markdown-toc-전통적인-vm">전통적인 VM</a></li>
      <li><a href="#컨테이너docker" id="markdown-toc-컨테이너docker">컨테이너(Docker)</a></li>
    </ul>
  </li>
  <li><a href="#왜-가상화가-필요한-걸까" id="markdown-toc-왜-가상화가-필요한-걸까">왜 가상화가 필요한 걸까?</a></li>
  <li><a href="#가상화의-장점" id="markdown-toc-가상화의-장점">가상화의 장점</a></li>
  <li><a href="#가상화의-단점" id="markdown-toc-가상화의-단점">가상화의 단점</a></li>
  <li><a href="#c언어-할때-우리가-docker-사용하는-이유" id="markdown-toc-c언어-할때-우리가-docker-사용하는-이유">C언어 할때 우리가 Docker 사용하는 이유</a>    <ul>
      <li><a href="#개발-환경-일관성-유지" id="markdown-toc-개발-환경-일관성-유지">개발 환경 일관성 유지</a></li>
      <li><a href="#빌드-자동화--테스트-자동화" id="markdown-toc-빌드-자동화--테스트-자동화">빌드 자동화 &amp; 테스트 자동화</a></li>
      <li><a href="#실행-환경과-호환-문제-해결" id="markdown-toc-실행-환경과-호환-문제-해결">실행 환경과 호환 문제 해결</a></li>
      <li><a href="#학생--강의--과제-제출용" id="markdown-toc-학생--강의--과제-제출용">학생 / 강의 / 과제 제출용</a></li>
      <li><a href="#보안성" id="markdown-toc-보안성">보안성</a></li>
    </ul>
  </li>
</ul>

<p>하드웨어 자원을 소프트웨어적으로 추상화해서, 여러 개의 독립된 시스템처럼 사용하는 기술 <strong>가상화(Virtualization)</strong>에 대해 알아볼게</p>

<p>가상화를 통해 하나의 물리 컴퓨터 위에서</p>

<ul>
  <li>
    <p>여러 운영처제(OS)</p>
  </li>
  <li>
    <p>여러 어플리케이션 환경</p>
  </li>
</ul>

<p>을 독립적이고 격리된 상태로 실행할 수 있도록 해줘</p>

<h2 id="가상화의-종류">가상화의 종류</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">VM(Virtual Machine)</th>
      <th style="text-align: center">Docker(Container)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">OS 포함</td>
      <td style="text-align: center">각 VM마다 Guest OS 포함</td>
      <td style="text-align: center">커널 공유, OS는 없음</td>
    </tr>
    <tr>
      <td style="text-align: center">부팅 속도</td>
      <td style="text-align: center">느림(분 단위)</td>
      <td style="text-align: center">매우 빠름(초 단위)</td>
    </tr>
    <tr>
      <td style="text-align: center">성능</td>
      <td style="text-align: center">비교적 낮음</td>
      <td style="text-align: center">거의 네이티브 수준</td>
    </tr>
    <tr>
      <td style="text-align: center">자원 사용</td>
      <td style="text-align: center">무거움(OS 단위로 메모리 사용)</td>
      <td style="text-align: center">가벼움(커널 공유하기 때문)</td>
    </tr>
    <tr>
      <td style="text-align: center">격리성</td>
      <td style="text-align: center">강력함</td>
      <td style="text-align: center">비교적 약함(같은 커널 공유)</td>
    </tr>
    <tr>
      <td style="text-align: center">이미지 크기</td>
      <td style="text-align: center">수 GB</td>
      <td style="text-align: center">수 MB ~ GB</td>
    </tr>
    <tr>
      <td style="text-align: center">사용 사례</td>
      <td style="text-align: center">전체 OS 시뮬레이션, 강한 격리 필요시</td>
      <td style="text-align: center">마이크로서비스, CI/CD, 빠른 배포</td>
    </tr>
  </tbody>
</table>

<h3 id="전통적인-vm">전통적인 VM</h3>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span> <span class="nt">물리</span> <span class="nt">하드웨어</span> <span class="o">]</span>
       <span class="err">↓</span>
<span class="o">[</span> <span class="nt">호스트</span> <span class="nt">OS</span> <span class="o">]</span>
       <span class="err">↓</span>
<span class="o">[</span> <span class="nt">하이퍼바이저</span> <span class="o">(</span><span class="nt">Hypervisor</span><span class="o">)</span> <span class="o">]</span>
       <span class="err">↓↓↓↓↓</span>
 <span class="err">┌──────────────┐</span>  <span class="err">┌──────────────┐</span>  <span class="err">┌──────────────┐</span>
 <span class="err">│</span>   <span class="nt">VM</span> <span class="err">1</span>       <span class="err">│</span>  <span class="err">│</span>   <span class="nt">VM</span> <span class="err">2</span>       <span class="err">│</span>  <span class="err">│</span>   <span class="nt">VM</span> <span class="err">3</span>       <span class="err">│</span>
 <span class="err">│</span> <span class="nt">Guest</span> <span class="nt">OS</span>     <span class="err">│</span>  <span class="err">│</span> <span class="nt">Guest</span> <span class="nt">OS</span>     <span class="err">│</span>  <span class="err">│</span> <span class="nt">Guest</span> <span class="nt">OS</span>     <span class="err">│</span>
 <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>  <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>  <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>
 <span class="err">└──────────────┘</span>  <span class="err">└──────────────┘</span>  <span class="err">└──────────────┘</span>
</code></pre></div></div>

<ul>
  <li>
    <p>하드웨어 위에 Hypervisor 설치</p>
  </li>
  <li>
    <p>각 VM마다 운영체제(Guest OS) 전체를 포함</p>
  </li>
  <li>
    <p>리소스 무거움</p>
  </li>
</ul>

<h3 id="컨테이너docker">컨테이너(Docker)</h3>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span> <span class="nt">물리</span> <span class="nt">하드웨어</span> <span class="o">]</span>
       <span class="err">↓</span>
<span class="o">[</span> <span class="nt">호스트</span> <span class="nt">OS</span> <span class="o">(</span><span class="nt">Linux</span> <span class="nt">등</span><span class="o">)</span> <span class="o">]</span>
       <span class="err">↓</span>
<span class="o">[</span> <span class="nt">Docker</span> <span class="nt">Engine</span> <span class="o">]</span>
       <span class="err">↓↓↓↓↓</span>
 <span class="err">┌──────────────┐</span>  <span class="err">┌──────────────┐</span>  <span class="err">┌──────────────┐</span>
 <span class="err">│</span> <span class="nt">Container</span> <span class="err">1</span>  <span class="err">│</span>  <span class="err">│</span> <span class="nt">Container</span> <span class="err">2</span>  <span class="err">│</span>  <span class="err">│</span> <span class="nt">Container</span> <span class="err">3</span>  <span class="err">│</span>
 <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>  <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>  <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>
 <span class="err">└──────────────┘</span>  <span class="err">└──────────────┘</span>  <span class="err">└──────────────┘</span>
</code></pre></div></div>

<ul>
  <li>
    <p>컨테이너들은 호스트 OS의 커널을 공유</p>
  </li>
  <li>
    <p>애플리케이션 + 라이브러리만 포함된 컨테이너 단위로 실행</p>
  </li>
  <li>
    <p>불필요한 OS가 없음 → 가볍고 빠름</p>
  </li>
  <li>
    <p>자원 사용이 효율적</p>
  </li>
</ul>

<h2 id="왜-가상화가-필요한-걸까">왜 가상화가 필요한 걸까?</h2>

<p><strong>리소스 효율화</strong></p>

<ul>
  <li>
    <p>서버 1대를 여러 대처럼 나눠서 사용 가능</p>
  </li>
  <li>
    <p>하드웨어 낭비 줄일 수 있음</p>
  </li>
</ul>

<p><strong>격리성(Isolation)</strong></p>

<ul>
  <li>
    <p>서로 다른 환경을 완전히 분리</p>
  </li>
  <li>
    <p>한 앱이 죽어도 다른 앱에 영향 없음</p>
  </li>
</ul>

<p><strong>테스트/배포 자동화</strong></p>

<ul>
  <li>개발 → 테스트 → 배포까지 동일한 환경 유지 가능 (특히 Docker)</li>
</ul>

<p><strong>보안성</strong></p>

<ul>
  <li>서로 다른 사용자/프로세스를 독립적으로 운영 가능</li>
</ul>

<h2 id="가상화의-장점">가상화의 장점</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">장점</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">자원 효율성</td>
      <td style="text-align: center">물리 서버 하나로 여러 작업 가능</td>
    </tr>
    <tr>
      <td style="text-align: center">유연성</td>
      <td style="text-align: center">필요한 환경만 골라서 빠르게 만들 수 있음</td>
    </tr>
    <tr>
      <td style="text-align: center">테스트에 용이</td>
      <td style="text-align: center">다양한 OS, 설정 실험 가능</td>
    </tr>
    <tr>
      <td style="text-align: center">격리성 보장</td>
      <td style="text-align: center">하나가 망가져도 다른 프로세스에는 영향 X</td>
    </tr>
    <tr>
      <td style="text-align: center">배포 자동화</td>
      <td style="text-align: center">Dockerfile로 같은 환경을 어디서든 재현 가능</td>
    </tr>
  </tbody>
</table>

<h2 id="가상화의-단점">가상화의 단점</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단점</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">성능 오버헤드</td>
      <td style="text-align: center">특히 VM은 OS 전체를 돌리므로 무거움</td>
    </tr>
    <tr>
      <td style="text-align: center">복잡도 증가</td>
      <td style="text-align: center">관리, 설정, 보안 측면에서 신경 쓸 게 많음</td>
    </tr>
    <tr>
      <td style="text-align: center">네트워크/디스크 이슈</td>
      <td style="text-align: center">가상화 계층이 개입되면 속도 손해 가능성</td>
    </tr>
    <tr>
      <td style="text-align: center">Docker : 커널 공유</td>
      <td style="text-align: center">호스트 커널에 의존 → 커널 레벨 취약점에 취약</td>
    </tr>
  </tbody>
</table>

<h2 id="c언어-할때-우리가-docker-사용하는-이유">C언어 할때 우리가 Docker 사용하는 이유</h2>

<h3 id="개발-환경-일관성-유지">개발 환경 일관성 유지</h3>

<ul>
  <li>
    <p>시스템마다 컴파일러 버전, 라이브러리, 경로 다름 → 내 컴퓨터에서는 되지만, 다른 컴퓨터에선느 안될 수 있음</p>
  </li>
  <li>
    <p>Docker는 Dockerfile에 환경을 정의해두면 → 어디서든 똑같은 환경에서 C 코드 실행 가능</p>
  </li>
</ul>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> gcc:latest</span>
<span class="k">COPY</span><span class="s"> . /app</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="k">RUN </span>gcc main.c <span class="nt">-o</span> main
<span class="k">CMD</span><span class="s"> ["./main"]</span>
</code></pre></div></div>

<p>이렇게 하면, 어디서든 gcc main.c 빌드 환경이 같아짐</p>

<h3 id="빌드-자동화--테스트-자동화">빌드 자동화 &amp; 테스트 자동화</h3>

<ul>
  <li>
    <p>Makefile, Cmake 빌드 시스템을 컨테이너에 넣어서 → 코드 푸시하면 자동 빌드가 가능해짐</p>
  </li>
  <li>
    <p>CI/CD (예 : Github Actions, Jenkins)와 연동 쉬움</p>
  </li>
</ul>

<h3 id="실행-환경과-호환-문제-해결">실행 환경과 호환 문제 해결</h3>

<ul>
  <li>
    <p>예를 들어, 코드가 리눅스에서만 돌아간다? → 맥북이나 윈도우에서도 Docker로 리눅스 환경 돌리면 끝!</p>
  </li>
  <li>
    <p>특정 라이브러리나 커널 기능이 필요한 프로젝트일 때 → 해당 환경을 Docker로 재현 가능능</p>
  </li>
</ul>

<h3 id="학생--강의--과제-제출용">학생 / 강의 / 과제 제출용</h3>

<ul>
  <li>
    <p>실습 환경 다르면 문제 생기니까 Docker로 통일하면 편해</p>
  </li>
  <li>
    <p>교수님 팀원한테 “이 Dockerfile 돌리면 됩니다”라고 주면 끝!</p>
  </li>
</ul>

<h3 id="보안성">보안성</h3>

<ul>
  <li>악성 코드 실험, 위험한 시스템 호출 시 Docker에서 격리된 환경에서 안전하게 테스트 가능</li>
</ul>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="c" /><category term="C" /><category term="가상화" /><category term="Virtualization" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/C.png" /><media:content medium="image" url="/assets/img/blog/postimage/C.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">동적 메모리 할당(Dynamic memory allocation)</title><link href="/blog/c/malloc-calloc-realloc/" rel="alternate" type="text/html" title="동적 메모리 할당(Dynamic memory allocation)" /><published>2025-04-11T00:00:00+00:00</published><updated>2025-04-11T00:00:00+00:00</updated><id>/blog/c/malloc-calloc-realloc</id><content type="html" xml:base="/blog/c/malloc-calloc-realloc/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#동적-메모리-할당을-사용할-때는-언제일까" id="markdown-toc-동적-메모리-할당을-사용할-때는-언제일까">동적 메모리 할당을 사용할 때는 언제일까?</a>    <ul>
      <li><a href="#c언어에서의-정적-할당과-동적-할당의-예시" id="markdown-toc-c언어에서의-정적-할당과-동적-할당의-예시">C언어에서의 정적 할당과 동적 할당의 예시</a></li>
      <li><a href="#동적-메모리-할당-vs-정적-메모리-할당-차이점" id="markdown-toc-동적-메모리-할당-vs-정적-메모리-할당-차이점">동적 메모리 할당 vs 정적 메모리 할당 차이점</a></li>
    </ul>
  </li>
  <li><a href="#동적-메모리-할당malloc-calloc-realloc-free" id="markdown-toc-동적-메모리-할당malloc-calloc-realloc-free">동적 메모리 할당(malloc, calloc, realloc, free)</a>    <ul>
      <li><a href="#용어-정리" id="markdown-toc-용어-정리">용어 정리</a></li>
      <li><a href="#mallocmemory-allocation" id="markdown-toc-mallocmemory-allocation">malloc(Memory Allocation)</a></li>
      <li><a href="#calloccontinguous-allocation" id="markdown-toc-calloccontinguous-allocation">calloc(Continguous Allocation)</a></li>
      <li><a href="#reallocreallocation" id="markdown-toc-reallocreallocation">realloc(Reallocation)</a>        <ul>
          <li><a href="#기존-블록에서-크기-조정이-가능한-경우realloc의-두-가지-시나리오" id="markdown-toc-기존-블록에서-크기-조정이-가능한-경우realloc의-두-가지-시나리오">기존 블록에서 크기 조정이 가능한 경우(realloc의 두 가지 시나리오)</a></li>
          <li><a href="#기존-블록에서-확장-불가능한-경우realloc의-두-가지-시나리오" id="markdown-toc-기존-블록에서-확장-불가능한-경우realloc의-두-가지-시나리오">기존 블록에서 확장 불가능한 경우(realloc의 두 가지 시나리오)</a></li>
        </ul>
      </li>
      <li><a href="#freeptr" id="markdown-toc-freeptr">free(ptr)</a>        <ul>
          <li><a href="#free-사용하면-안-되는-경우" id="markdown-toc-free-사용하면-안-되는-경우">free() 사용하면 안 되는 경우</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#주의할-점" id="markdown-toc-주의할-점">주의할 점</a></li>
  <li><a href="#마무리" id="markdown-toc-마무리">마무리</a></li>
  <li><a href="#추가내용" id="markdown-toc-추가내용">추가내용</a></li>
</ul>

<p>C언어에서의 동적 메모리 관리를 위해 사용하는 표준 라이브러리 함수 malloc, calloc, realloc, free에 대해서 알아보자. 이 함수들은 <stdio.h>에 정의 되어 있어.</stdio.h></p>

<h2 id="동적-메모리-할당을-사용할-때는-언제일까">동적 메모리 할당을 사용할 때는 언제일까?</h2>

<ul>
  <li>
    <p>입력 크기를 미리 알 수 없을 때 (ex. 사용자 입력)</p>
  </li>
  <li>
    <p>메모리를 효율적으로 쓰고 싶을 때</p>
  </li>
  <li>
    <p>복잡한 자료구조를 다룰 때 (ex. 트리, 그래프, 연결 리스트)</p>
  </li>
</ul>

<p>먼저 동적 메모리 할당(dynamic memory allocation) 설명 전에 정적 메모리 할당(static memory allocation)에 대해 간략하게 소개할게</p>

<h3 id="c언어에서의-정적-할당과-동적-할당의-예시">C언어에서의 정적 할당과 동적 할당의 예시</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 정적 할당</span>
<span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>  <span class="c1">// 크기 10으로 고정</span>
<span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

<span class="c1">// 동적 할당</span>
<span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">10</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>  <span class="c1">// 실행 중 필요한 만큼 할당</span>
</code></pre></div></div>

<h3 id="동적-메모리-할당-vs-정적-메모리-할당-차이점">동적 메모리 할당 vs 정적 메모리 할당 차이점</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">구분</th>
      <th style="text-align: center">정적 메모리 할당</th>
      <th style="text-align: center">동적 메모리 할당</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">할당 영역</td>
      <td style="text-align: center">스택</td>
      <td style="text-align: center">힙</td>
    </tr>
    <tr>
      <td style="text-align: center">크기 제한</td>
      <td style="text-align: center">작음(MB 단위)</td>
      <td style="text-align: center">큼(GB까지도 가능)</td>
    </tr>
    <tr>
      <td style="text-align: center">특징</td>
      <td style="text-align: center">자동 관리, 빠름, 고정 크기</td>
      <td style="text-align: center">수동 관리, 느림, 유연함</td>
    </tr>
    <tr>
      <td style="text-align: center">시점</td>
      <td style="text-align: center">컴파일 타임(프로그램을 빌드할 때, 저장)</td>
      <td style="text-align: center">런타임(실행 중에 운영체제로부터 메모리를 요청해서 사용)</td>
    </tr>
    <tr>
      <td style="text-align: center">예시</td>
      <td style="text-align: center">배열처럼 크기가 고정된 변수</td>
      <td style="text-align: center">리스트처럼 크기가 유동적인 구조</td>
    </tr>
    <tr>
      <td style="text-align: center">메모리 해제</td>
      <td style="text-align: center">자동 해제 or 함수 종료 시</td>
      <td style="text-align: center">직접 해제 필요 (ex. free() in C)</td>
    </tr>
  </tbody>
</table>

<h2 id="동적-메모리-할당malloc-calloc-realloc-free">동적 메모리 할당(malloc, calloc, realloc, free)</h2>

<h4 id="용어-정리">용어 정리</h4>

<ul>
  <li>
    <p>void* 는 “타입이 정해지지 않은 주소값”으로</p>

    <ul>
      <li>
        <p>메모리 주소를 가리키는 포인터인데, 어떤 타입인지 아직 모르겠다는 뜻</p>
      </li>
      <li>
        <p>그래서 나중에 원하는 타입으로 형변환 (cast) 해서 써야 해</p>
      </li>
    </ul>
  </li>
</ul>

<p>예시 : malloc()은 void ptr를 반환하니까, int ptr 로 형변환. 하지만 c언어에서 *은 자동 형변환됨</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">5</span><span class="p">);</span>

</code></pre></div></div>

<h3 id="mallocmemory-allocation">malloc(Memory Allocation)</h3>

<p>지정한 바이트만큼의 메모리를 할당</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">malloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></div>
<ul>
  <li>
    <p>초기화: ❌ 초기화되지 않음. 메모리의 내용은 쓰레기값(garbage values)일 수 있음</p>
  </li>
  <li>
    <p>반환값: 성공하면 void 포인터(void*)를 반환. 실패하면 NULL 반환</p>
  </li>
</ul>

<p>예제 : int 5개를 저장할 수 있는 메모리를 동적으로 할당함</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</code></pre></div></div>

<h3 id="calloccontinguous-allocation">calloc(Continguous Allocation)</h3>

<p>num 개의 요소 각각 size 바이트 크기로 메모리를 할당.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">calloc</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">num</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>
    <p>초기화: ✅ 0으로 초기화됨(할당 대상이 배열이라면, calloc이 더 안전 - 초기화 누락 방지)</p>
  </li>
  <li>
    <p>반환값: 성공하면 void* 반환. 실패하면 NULL</p>
  </li>
</ul>

<p>예제 : int 5개 크기의 메모리를 0으로 초기화한 채 할당.</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">calloc</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</code></pre></div></div>

<h3 id="reallocreallocation">realloc(Reallocation)</h3>

<p>이미 할당된 메모리 블록의 크기를 변경 (확장 또는 축소)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span><span class="o">*</span> <span class="nf">realloc</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span> <span class="n">ptr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">new_size</span><span class="p">);</span>
</code></pre></div></div>

<ul>
  <li>
    <p>ptr이 NULL이면 malloc처럼 동작</p>
  </li>
  <li>
    <p>new_size가 0이면 free(ptr)처럼 동작</p>
  </li>
</ul>

<p>예제 : int 10개 크기로 확장함</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">arr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">5</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="n">arr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">realloc</span><span class="p">(</span><span class="n">arr</span><span class="p">,</span> <span class="mi">10</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</code></pre></div></div>

<ul>
  <li>
    <p>초기화: 새로 늘어난 부분은 초기화되지 않음</p>
  </li>
  <li>
    <p>새 크기의 메모리를 새로 확보하고, 기존 데이터는 유지함. 새 영역으로 이동할 수도 있음(새로운 블록이 현재 블록의 “바로 뒤”에 있으면)</p>
  </li>
</ul>

<h4 id="기존-블록에서-크기-조정이-가능한-경우realloc의-두-가지-시나리오">기존 블록에서 크기 조정이 가능한 경우(realloc의 두 가지 시나리오)</h4>

<ul>
  <li>
    <p>힙 영역에서 현재 블록 뒤쪽에 충분한 여유 공간이 있는 경우, 기존 위치에서 확장이 가능해</p>
  </li>
  <li>
    <p>이 경우 realloc은 새 메모리를 할당하지 않고, 기존 블록의 크기만 늘리고 주소도 그대로 반환</p>
  </li>
  <li>
    <p>성능적으로 가장 좋음! (복사 불필요요)</p>
  </li>
</ul>

<h4 id="기존-블록에서-확장-불가능한-경우realloc의-두-가지-시나리오">기존 블록에서 확장 불가능한 경우(realloc의 두 가지 시나리오)</h4>

<ul>
  <li>
    <p>기존 블록 뒤쪽에 다른 메모리 할당이 있어서 공간 확장이 불가</p>
  </li>
  <li>
    <p>realloc은 내부적으로 malloc(new_size)로 새 블록을 만들고, memcpy로 기존 데이터를 복사한 다음, 기존 블록은 free()처리하고, 새 주소를 반환환</p>
  </li>
</ul>

<h3 id="freeptr">free(ptr)</h3>

<p>동적 메모리 할당 사용시 메모리 수동해제가 필수야! 아래처럼 사용이 끝났을 때 호출해야해</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>

<span class="c1">// ... ptr을 사용해서 작업 수행 ...</span>

<span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>  <span class="c1">// 사용이 끝났으면 반드시 해제해야 함!</span>
</code></pre></div></div>

<ul>
  <li>
    <p>같은 포인터를 두 번 free()하면 안 돼! → “Double Free” 에러</p>
  </li>
  <li>
    <p>보통 free() 한 뒤에는 NULL로 초기화하는 습관이 좋아</p>
    <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="o">*</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="nf">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
<span class="c1">// ...</span>
<span class="n">free</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>  <span class="c1">// 꼭 해제!</span>
<span class="n">data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="c1">// 안전을 위해 초기화</span>
</code></pre></div>    </div>
  </li>
</ul>

<h4 id="free-사용하면-안-되는-경우">free() 사용하면 안 되는 경우</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">잘못된 예시</th>
      <th style="text-align: center">이유</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">free() 없이 종료</td>
      <td style="text-align: center">메모리 누수 발생</td>
    </tr>
    <tr>
      <td style="text-align: center">스택에 할당한 변수에 free()</td>
      <td style="text-align: center">malloc 등으로 할당한 메모리만 해제 가능</td>
    </tr>
    <tr>
      <td style="text-align: center">같은 포인터를 두 번 free()</td>
      <td style="text-align: center">프로그램이 비정상 종료될 수 있음</td>
    </tr>
    <tr>
      <td style="text-align: center">다른 포인터로 free()</td>
      <td style="text-align: center">정확히 할당했던 포인터로만 해제해야 함</td>
    </tr>
  </tbody>
</table>

<p>예제 : 스택 메모리에 free()</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="n">free</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>  <span class="c1">// ❌ 이렇게 하면 안 됨! (스택 메모리는 해제하지 마!)</span>
</code></pre></div></div>

<h2 id="주의할-점">주의할 점</h2>

<ul>
  <li>
    <p>반환값이 NULL인지 반드시 체크할 것! malloc이나 calloc은 실패할 수 있음</p>
  </li>
  <li>
    <p>메모리 누수 방지를 위해 사용 후 free(ptr)를 꼭 호출해야 함</p>
  </li>
  <li>
    <p>malloc은 초기화를 안 해줘서 쓰기 전에 꼭 값 채워야 해</p>
  </li>
  <li>
    <p>realloc은 새로운 주소로 이동될 수 있으니, 반드시 반환값을 다시 변수에 할당해야 함</p>
  </li>
  <li>
    <p>free() 이후 그 포인터를 다시 쓰면 “댕글링 포인터(dangling pointer)” 문제가 생길 수 있어</p>
  </li>
</ul>

<h2 id="마무리">마무리</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">함수</th>
      <th style="text-align: center">역할</th>
      <th style="text-align: center">초기화 여부</th>
      <th style="text-align: center">사용 시기</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">malloc</td>
      <td style="text-align: center">지정한 크기만큼 할당</td>
      <td style="text-align: center">❌ 안 됨</td>
      <td style="text-align: center">빠르게 할당만 하고 싶을 때</td>
    </tr>
    <tr>
      <td style="text-align: center">calloc</td>
      <td style="text-align: center">여러 개 요소를 할당 + 초기화</td>
      <td style="text-align: center">✅ 0으로 초기화</td>
      <td style="text-align: center">배열 등 초기화가 필요한 경우</td>
    </tr>
    <tr>
      <td style="text-align: center">realloc</td>
      <td style="text-align: center">기존 메모리 크기 변경</td>
      <td style="text-align: center">❌ 안 됨</td>
      <td style="text-align: center">크기를 동적으로 바꿔야 할 때</td>
    </tr>
  </tbody>
</table>

<h2 id="추가내용">추가내용</h2>

<ul>
  <li>realloc이 ‘이동했는지’ 알아낼 수 있을까?</li>
</ul>

<p>예제 : realloc이 반환한 포인터와 기존 포인터를 비교</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">new_ptr</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="mi">200</span><span class="p">);</span>

<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">new_ptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 같은 위치에서 확장 성공 (이동 없음)</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 다른 위치로 이동해서 데이터 복사함</span>
<span class="p">}</span>
</code></pre></div></div>

<ul>
  <li>realloc이 실패하면 NULL값 반환되는데, 이때 기존 포인터는 해제되지 않아서 안전하게 쓰는 방법은 아래와 같아</li>
</ul>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span> <span class="c1">// 성공하면 ptr을 새 주소로 갱신</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// 실패해도 ptr은 여전히 유효한 메모리, 누수 방지 가능</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="c" /><category term="malloc" /><category term="calloc" /><category term="realloc" /><category term="동적" /><category term="메모리" /><category term="할당" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/C.png" /><media:content medium="image" url="/assets/img/blog/postimage/C.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">포인터(pointer), &amp;amp; 연산자와 * 연산자</title><link href="/blog/algorithm/pointer-and-star/" rel="alternate" type="text/html" title="포인터(pointer), &amp;amp; 연산자와 * 연산자" /><published>2025-04-04T00:00:00+00:00</published><updated>2025-04-04T00:00:00+00:00</updated><id>/blog/algorithm/pointer-and-star</id><content type="html" xml:base="/blog/algorithm/pointer-and-star/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#포인터pointer란" id="markdown-toc-포인터pointer란">포인터(pointer)란?</a></li>
  <li><a href="#-연산자-주소-연산자" id="markdown-toc--연산자-주소-연산자">&amp; 연산자 (주소 연산자)</a></li>
  <li><a href="#-연산자-역참조-연산자-또는-간접-참조-연산자" id="markdown-toc--연산자-역참조-연산자-또는-간접-참조-연산자">* 연산자 (역참조 연산자 또는 간접 참조 연산자)</a>    <ul>
      <li><a href="#포인터-선언" id="markdown-toc-포인터-선언">포인터 선언</a></li>
      <li><a href="#역참조dereferencing" id="markdown-toc-역참조dereferencing">역참조(Dereferencing)</a></li>
      <li><a href="#시각화-마인드-이미지" id="markdown-toc-시각화-마인드-이미지">시각화 (마인드 이미지)</a></li>
    </ul>
  </li>
  <li><a href="#마무리" id="markdown-toc-마무리">마무리</a></li>
</ul>

<h2 id="포인터pointer란">포인터(pointer)란?</h2>

<p>포인터는 ‘어떤 변수의 메모리 주소’를 저장하는 변수야.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
</code></pre></div></div>
<ul>
  <li>
    <p>a는 정수형 변수이고 값은 10이야</p>
  </li>
  <li>
    <p>&amp;a는 a의 메모리 주소를 의미해</p>
  </li>
  <li>
    <p>p는 포인터 변수로, 정수형 변수의 주소를 저장할 수 있어. 그래서 int*p;라고 선언해</p>
  </li>
  <li>
    <p>p = &amp;a;는 a의 주소를 p에 저장한다는 뜻이야</p>
  </li>
</ul>

<h2 id="-연산자-주소-연산자">&amp; 연산자 (주소 연산자)</h2>

<p>&amp;는 변수의 주소를 얻는 연산자야</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%p"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// 변수 a의 주소를 출력함</span>
</code></pre></div></div>

<p>&amp;a 는 a의 메모리 주소를 반환해</p>

<h2 id="-연산자-역참조-연산자-또는-간접-참조-연산자">* 연산자 (역참조 연산자 또는 간접 참조 연산자)</h2>

<ul>
  <li>는 두 가지 용도로 쓰여</li>
</ul>

<h3 id="포인터-선언">포인터 선언</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
</code></pre></div></div>

<ul>
  <li>p는 int형 값을 가리키는 포인터야</li>
</ul>

<h3 id="역참조dereferencing">역참조(Dereferencing)</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>

<span class="n">printf</span><span class="p">(</span><span class="s">"%d"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>  <span class="c1">// 10 출력</span>
</code></pre></div></div>

<ul>
  <li>
    <p>*p는 p가 가리키는 주소에 저장된 값을 의미</p>
  </li>
  <li>
    <p>즉, *p는 a와 같아!</p>
  </li>
</ul>

<h3 id="시각화-마인드-이미지">시각화 (마인드 이미지)</h3>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">a</span> <span class="p">=</span> <span class="m">10</span><span class="p">;</span>

   <span class="p">[</span><span class="n">a</span><span class="p">]</span>
<span class="err">주소</span><span class="p">:</span> <span class="m">0x100</span>
<span class="err">값</span><span class="p">:</span>   <span class="m">10</span>

<span class="kt">int</span> <span class="p">*</span><span class="n">p</span> <span class="p">=</span> <span class="p">&amp;</span><span class="n">a</span><span class="p">;</span>

   <span class="p">[</span><span class="n">p</span><span class="p">]</span>
<span class="err">주소</span><span class="p">:</span> <span class="m">0x200</span>  <span class="p">(</span><span class="n">p</span><span class="err">의</span> <span class="err">주소</span><span class="p">)</span>
<span class="err">값</span><span class="p">:</span>   <span class="m">0x100</span>  <span class="p">(</span><span class="n">a</span><span class="err">의</span> <span class="err">주소</span><span class="p">)</span>

<span class="p">*</span><span class="n">p</span> <span class="p">=&gt;</span> <span class="m">10</span>
</code></pre></div></div>

<ul>
  <li>
    <p>p는 0x100이라는 값을 가지고 있다 (즉, a의 주소를 저장).</p>
  </li>
  <li>
    <p>*p는 0x100 주소에 있는 값을 참조한다, 즉 a의 값 10</p>
  </li>
  <li>
    <p>마지막으로 p 자체도 메모리에 저장되기 때문에, p의 주소도 있어</p>
  </li>
</ul>

<p><strong><em>쉽게 정리</em></strong></p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">);</span> <span class="c1">// a의 주소 (예: 0x100)</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>  <span class="c1">// p가 가리키는 주소 (=&amp;a) → 0x100</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%d</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span> <span class="c1">// p가 가리키는 주소의 값 → 10</span>
<span class="n">printf</span><span class="p">(</span><span class="s">"%p</span><span class="se">\n</span><span class="s">"</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">);</span> <span class="c1">// p 자체의 주소 (예: 0x200)</span>
</code></pre></div></div>

<h2 id="마무리">마무리</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">연산자</th>
      <th style="text-align: center">의미</th>
      <th style="text-align: center">예시</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">&amp;</td>
      <td style="text-align: center">주소값 반환</td>
      <td style="text-align: center">&amp;a</td>
      <td style="text-align: center">변수 a의 주소값</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">역참조 / 값에 접근</td>
      <td style="text-align: center">*p</td>
      <td style="text-align: center">포인터 p가 가리키는 값</td>
    </tr>
    <tr>
      <td style="text-align: center">*</td>
      <td style="text-align: center">포인터 선언 시 사용</td>
      <td style="text-align: center">int *p</td>
      <td style="text-align: center">정수를 가리키는 포인터 선언</td>
    </tr>
  </tbody>
</table>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="algorithm" /><category term="포인터" /><category term="pointer" /><category term="연산자" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/Algorithm.png" /><media:content medium="image" url="/assets/img/blog/postimage/Algorithm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">프로그램의 기계수준 표현(Machine-Level Representation of Programs)</title><link href="/blog/computersystem/machine-level-representation-of-programs/" rel="alternate" type="text/html" title="프로그램의 기계수준 표현(Machine-Level Representation of Programs)" /><published>2025-04-04T00:00:00+00:00</published><updated>2025-04-04T00:00:00+00:00</updated><id>/blog/computersystem/machine-level-representation-of-programs</id><content type="html" xml:base="/blog/computersystem/machine-level-representation-of-programs/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#프래그로머로써-왜-어셈블리어를-배워야-할까" id="markdown-toc-프래그로머로써-왜-어셈블리어를-배워야-할까">프래그로머로써 왜 어셈블리어를 배워야 할까?</a></li>
  <li><a href="#기계수준-코드" id="markdown-toc-기계수준-코드">기계수준 코드</a>    <ul>
      <li><a href="#프로그램-메모리" id="markdown-toc-프로그램-메모리">프로그램 메모리</a></li>
    </ul>
  </li>
  <li><a href="#코드-예제" id="markdown-toc-코드-예제">코드 예제</a></li>
  <li><a href="#정보-접근하기" id="markdown-toc-정보-접근하기">정보 접근하기</a>    <ul>
      <li><a href="#오퍼랜드-식별자operand-specifier" id="markdown-toc-오퍼랜드-식별자operand-specifier">오퍼랜드 식별자(Operand specifier)</a></li>
    </ul>
  </li>
  <li><a href="#데이터-이동-예제" id="markdown-toc-데이터-이동-예제">데이터 이동 예제</a>    <ul>
      <li><a href="#자료형-변환-type-casting" id="markdown-toc-자료형-변환-type-casting">자료형 변환 (Type Casting)</a>        <ul>
          <li><a href="#작은-타입--큰-타입-확장" id="markdown-toc-작은-타입--큰-타입-확장">작은 타입 → 큰 타입 (확장)</a></li>
          <li><a href="#큰-타입--작은-타입-축소" id="markdown-toc-큰-타입--작은-타입-축소">큰 타입 → 작은 타입 (축소)</a></li>
        </ul>
      </li>
      <li><a href="#정수형-확장" id="markdown-toc-정수형-확장">정수형 확장</a></li>
      <li><a href="#부호성과-크기의-변환" id="markdown-toc-부호성과-크기의-변환">부호성과 크기의 변환</a>        <ul>
          <li><a href="#그러면-부호성은-언제-사용하냐" id="markdown-toc-그러면-부호성은-언제-사용하냐">그러면 부호성은 언제 사용하냐?</a></li>
        </ul>
      </li>
      <li><a href="#자료형-정수형-확장-부호성과-크기의-변환-요약" id="markdown-toc-자료형-정수형-확장-부호성과-크기의-변환-요약">자료형, 정수형 확장, 부호성과 크기의 변환 요약</a></li>
      <li><a href="#c언어에서의-signed-vs-unsigned-기본-개념" id="markdown-toc-c언어에서의-signed-vs-unsigned-기본-개념">C언어에서의 signed vs unsigned 기본 개념</a>        <ul>
          <li><a href="#왜-굳이-unsigned를-쓸까" id="markdown-toc-왜-굳이-unsigned를-쓸까">왜 굳이 unsigned를 쓸까?</a></li>
          <li><a href="#그럼-signed는-왜-따로-쓸까" id="markdown-toc-그럼-signed는-왜-따로-쓸까">그럼 signed는 왜 따로 쓸까?</a></li>
          <li><a href="#c에서-char-signed-char-unsigned-char의-차이" id="markdown-toc-c에서-char-signed-char-unsigned-char의-차이">C에서 char, signed char, unsigned char의 차이</a></li>
          <li><a href="#정수-오버플로언더플로와-관련" id="markdown-toc-정수-오버플로언더플로와-관련">정수 오버플로/언더플로와 관련</a></li>
          <li><a href="#unsignedsigned-정리" id="markdown-toc-unsignedsigned-정리">unsigned/signed 정리</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#rsp스택-포인터의-감소" id="markdown-toc-rsp스택-포인터의-감소">%rsp(스택 포인터)의 감소</a></li>
</ul>

<p>컴퓨터는 데이터를 처리하고, 메모리를 관리하고, 저장장치에 데이터를 읽거나 쓰고, 네트워크를 통해 통신하는 등의 하위 동작들을 인코딩한 연속된 바이트인 기계어 코드를 실행한다.</p>

<h2 id="프래그로머로써-왜-어셈블리어를-배워야-할까">프래그로머로써 왜 어셈블리어를 배워야 할까?</h2>

<p>최신 최적화 컴파일러가 만들어 낸 코드는 대부분 잘 훈련된 어셈블리어 프래그로머가 손으로 작성한 것과 유사한 효율성을 갖는다. 그 말은 잘 훈련된 프로그래머의 어셈블리어가 최신 최적화 컴파일러가 만들어 낸 코드만큼의 효율성을 갖는다는 얘기다. 어셈블리어 코드를 읽고 이해할 수 있으면, 컴파일러의 최적화 성능을 알 수 있으며, 코드에 내재된 비효율성을 분석할 수 있다</p>

<h2 id="기계수준-코드">기계수준 코드</h2>

<p>기계수준 프로그래밍에 중요한 특징 두가지가 있어</p>

<ul>
  <li>
    <ol>
      <li>기계수준 프로그램의 형식과 동작은 인스트럭션 집합구조(Instruction set architecture) 즉, “ISA”에 의해 정의된다</li>
    </ol>
  </li>
  <li>
    <ol>
      <li>기계수준 프로그램이 사용하는 주소는 가상주소이며, 메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델 제공</li>
    </ol>
  </li>
</ul>

<p>그리고 프로세서 내부 구조에 대해서 설명할게</p>

<ul>
  <li>
    <p><strong><em>프로그램 카운터</em></strong>(일반적으로 PC라고 하며, x86-64에서는 %rip라고 함)는 실행할 다음 인스트럭션의 메모리 주소를 가리킴</p>
  </li>
  <li>
    <p><strong><em>정수 레지스터</em></strong> 파일은 64비트 값을 저장하기 위한 16개의 이름을 붙인 위치를 갖는다. 이들 레지스터는 주소(C언어의 포인터에 해당하는)나 정수 데이터를 저장할 수 있다. 일부 레지스터는 프로그램의 중요한 상태를 추적하는데 사용할 수 있으며, 다른 레지스터들은 함수의 리턴 값뿐만 아니라 프로시저의 지역변수와 인자 같은 임시 값을 저장하는 데 사용한다</p>
  </li>
  <li>
    <p><strong><em>조건코드 레지스터</em></strong>들은 가장 최근에 실행한 산술 또는 논리 인스트럭션에 관한 상태 정보를 저장한다. 이들은 if나 while문을 구현할 때 필요한 제어나 조건에 따른 데이터 흐름의 변경을 구현하기 위해 사용된다</p>
  </li>
  <li>
    <p><strong><em>벡터 레지스터</em></strong>들의 집합은 하나 이상의 정수나 부동소수점 값들을 각각 저장할 수 있다</p>
  </li>
</ul>

<h3 id="프로그램-메모리">프로그램 메모리</h3>

<p>프로그램 메모리는 프로그램의 실행 기계어 코드, 운영체제를 위한 일부 정보, 프로시저 호출과 리턴을 관리하는 런타임 스택, 사용자에 의해 할당된(예를 들어 malloc 라이브러리 함수를 사용해서) 메모리 블록들을 포함하고 있다</p>

<h2 id="코드-예제">코드 예제</h2>

<hr />

<h2 id="정보-접근하기">정보 접근하기</h2>

<p>인스트럭션들은 16개의 레지스터 하위 바이트들에 저장된 다양한 크기의 데이터에 대해 연산할 수 있다. 바이트수준 연산들은 가장 덜 중요한 바이트에 대해 연산을 할 수 있으며, 16비트 연산들은 가장 덜 중요한 2바이트에 접근하고, 32비트 연산은 덜 중요한 4바이트에, 64비트 연산은 레지스터 전체에 접근할 수 있다.</p>

<h3 id="오퍼랜드-식별자operand-specifier">오퍼랜드 식별자(Operand specifier)</h3>

<p>대부분의 인스트럭션은 하나 이상의 오퍼랜드를 가진다. 오퍼랜드는 연산을 수행할 소스(source)값과 그 결과를 저장할 목적지(destination)의 위치를 명시한다.</p>

<h2 id="데이터-이동-예제">데이터 이동 예제</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">명령어 접미사</th>
      <th style="text-align: center">크기</th>
      <th style="text-align: center">예시 레지스터</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">b (byte)</td>
      <td style="text-align: center">8 비트</td>
      <td style="text-align: center">%al, %bl</td>
    </tr>
    <tr>
      <td style="text-align: center">w (word)</td>
      <td style="text-align: center">16 비트</td>
      <td style="text-align: center">%ax, %bx</td>
    </tr>
    <tr>
      <td style="text-align: center">l (long)</td>
      <td style="text-align: center">32 비트</td>
      <td style="text-align: center">%eax, %ebx</td>
    </tr>
    <tr>
      <td style="text-align: center">q (quad)</td>
      <td style="text-align: center">64 비트</td>
      <td style="text-align: center">%rax, %rbx</td>
    </tr>
  </tbody>
</table>

<h3 id="자료형-변환-type-casting">자료형 변환 (Type Casting)</h3>

<h4 id="작은-타입--큰-타입-확장">작은 타입 → 큰 타입 (확장)</h4>

<p>예 : char(8bit) → int(32bit)</p>

<p>같은 경우 두 가지 방식으로 확장 가능 :</p>

<ul>
  <li>
    <p>Zero extension (0으로 채움) : 부호 없는 확장</p>
  </li>
  <li>
    <p>Sign extenstion (부호비트 복사) : 부호 있는 확장</p>
  </li>
</ul>

<pre><code class="language-assembly">; 예: 8비트 AL 레지스터 → 32비트 EAX로 확장

movzx eax, al     ; zero-extension: AL을 EAX로 확장
movsx eax, al     ; sign-extension: AL을 EAX로 확장 (AL이 음수면 1로 채움)
</code></pre>

<h4 id="큰-타입--작은-타입-축소">큰 타입 → 작은 타입 (축소)</h4>

<p>예 : int(32bit) → char(8bit)</p>

<p>이건 단순히 상위 비트를 버림. 잘못하면 값이 잘릴 수 있음</p>

<pre><code class="language-assembly">mov al, bl       ; 단순 복사 → 상위 비트 무시
</code></pre>

<h3 id="정수형-확장">정수형 확장</h3>

<p>자료형 변환과 확장되는데 다사 정리하자면 :</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">종류</th>
      <th style="text-align: center">설명</th>
      <th style="text-align: center">어셈블리어 명령어</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Zero Extension</td>
      <td style="text-align: center">상위 비트를 0으로 채움</td>
      <td style="text-align: center">MOVZX</td>
    </tr>
    <tr>
      <td style="text-align: center">Sign Extension</td>
      <td style="text-align: center">상위 비트를 부호 비트로 채움</td>
      <td style="text-align: center">MOVSX</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>C언어에서 unsigned char → int 변환하면 zero-extension</p>
  </li>
  <li>
    <p>signed char → int은 sign-extension 됨</p>
  </li>
</ul>

<h3 id="부호성과-크기의-변환">부호성과 크기의 변환</h3>

<p>부호성(sign)은 같은 비트 패턴이라도 해석 방법이 다름</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">이진수</th>
      <th style="text-align: center">부호 있음(signed)</th>
      <th style="text-align: center">부호 없음(unsigned)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">11111111 (8bit)</td>
      <td style="text-align: center">-1</td>
      <td style="text-align: center">255</td>
    </tr>
    <tr>
      <td style="text-align: center">10000000</td>
      <td style="text-align: center">-128</td>
      <td style="text-align: center">128</td>
    </tr>
  </tbody>
</table>

<p>예시 : 이런 식으로, 같은 al = 0xFF 값을 어떻게 해석하냐에 따라 완전히 다른 결과가 나와.</p>
<pre><code class="language-assembly">mov al, -1         ; al = 0xFF (-1)
movzx eax, al      ; eax = 0x000000FF (255) ← zero-extension
movsx eax, al      ; eax = 0xFFFFFFFF (-1) ← sign-extension
</code></pre>

<h4 id="그러면-부호성은-언제-사용하냐">그러면 부호성은 언제 사용하냐?</h4>

<ul>
  <li>
    <p>함수 호출 시 작은 자료형을 큰 레지스터에 넣을 때</p>
  </li>
  <li>
    <p>시스템 콜에 인자 전달할 때 정수형 확장 필수</p>
  </li>
  <li>
    <p>부호 있는 비교 (cmp) vs 부호 없는 비교 (cmp + ja/jb 등)에서 차이 발생</p>
  </li>
  <li>
    <p>imul, mul 등 부호 여부에 따라 다른 명령어 사용</p>
  </li>
</ul>

<h3 id="자료형-정수형-확장-부호성과-크기의-변환-요약">자료형, 정수형 확장, 부호성과 크기의 변환 요약</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">개념</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">자료형 없음</td>
      <td style="text-align: center">어셈블리는 타입보다 “크기”와 “부호 여부”에 집중</td>
    </tr>
    <tr>
      <td style="text-align: center">Zero-extension</td>
      <td style="text-align: center">unsigned 확장. 상위 비트를 0으로 채움</td>
    </tr>
    <tr>
      <td style="text-align: center">Sign-extension</td>
      <td style="text-align: center">signed 확장. 부호 비트를 상위에 복사</td>
    </tr>
    <tr>
      <td style="text-align: center">축소(Casting down)</td>
      <td style="text-align: center">상위 비트 잘림 (주의 필요)</td>
    </tr>
    <tr>
      <td style="text-align: center">부호 해석</td>
      <td style="text-align: center">같은 비트라도 signed/unsigned로 다르게 해석됨</td>
    </tr>
    <tr>
      <td style="text-align: center">주요 명령어</td>
      <td style="text-align: center">mov, movzx, movsx, cmp, imul, mul</td>
    </tr>
  </tbody>
</table>

<h3 id="c언어에서의-signed-vs-unsigned-기본-개념">C언어에서의 signed vs unsigned 기본 개념</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">타입</th>
      <th style="text-align: center">표현 가능한 값</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">signed(기본)</td>
      <td style="text-align: center">음수 ~ 양수</td>
    </tr>
    <tr>
      <td style="text-align: center">unsigned</td>
      <td style="text-align: center">0 ~ 양수 (두 배 범위)</td>
    </tr>
  </tbody>
</table>

<p>예 : char는 1바이트니까 총 256개의 값을 표현할 수 있음</p>

<ul>
  <li>
    <p>signed char : -128 ~ 127</p>
  </li>
  <li>
    <p>unsigned char : 0 ~ 255</p>
  </li>
</ul>

<h4 id="왜-굳이-unsigned를-쓸까">왜 굳이 unsigned를 쓸까?</h4>

<p><strong>음수가 절대 나올 수 없는 값에 적절함</strong></p>

<p>예 : 나이, 인덱스, 배열 크기, 파일 크기, 시간 등</p>

<p>→ 당연히 음수가 될 수 없으니 unsigned를 쓰면 안전하고 의미도 더 분명함</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">age</span> <span class="o">=</span> <span class="mi">23</span><span class="p">;</span>
</code></pre></div></div>

<p><strong>저장 범위를 최대한 활용하고 싶을 때</strong></p>

<p>unsigned는 같은 크기에서 더 큰 수까지 표현 가능하니까, 한정된 메모리로 최대한 많은 값을 표현하고 싶을 때 유용해.</p>

<p>예 : 색상값 (0~255)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">red</span> <span class="o">=</span> <span class="mi">255</span><span class="p">;</span>  <span class="c1">// 딱 1바이트로 0~255 표현</span>
</code></pre></div></div>

<p>** 비트 연산을 명확하게 할 때</p>

<p>unsigned는 부호 비트(맨 앞 비트) 를 걱정하지 않아도 돼서 비트 마스크, 쉬프트 연산 등을 더 안정적으로 할 수 있어</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mask</span> <span class="o">=</span> <span class="mh">0xF0</span><span class="p">;</span>
<span class="n">value</span> <span class="o">=</span> <span class="n">value</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="그럼-signed는-왜-따로-쓸까">그럼 signed는 왜 따로 쓸까?</h4>

<p>사실 C에서는 int, char는 기본적으로 signed야.(char는 컴파일러마다 다름) 명시적으로 부호 있는 정수라는 걸 강조하거나, 플랫폼 독립적으로 정확한 표현 범위를 보장하고 싶을 때 signed를 명시해</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">signed</span> <span class="kt">char</span> <span class="n">temperature</span> <span class="o">=</span> <span class="o">-</span><span class="mi">20</span><span class="p">;</span>
</code></pre></div></div>

<h4 id="c에서-char-signed-char-unsigned-char의-차이">C에서 char, signed char, unsigned char의 차이</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">타입</th>
      <th style="text-align: center">범위</th>
      <th style="text-align: center">용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">char</td>
      <td style="text-align: center">컴파일러에 따라 signed/unsigned 다름</td>
      <td style="text-align: center">문자 표현용</td>
    </tr>
    <tr>
      <td style="text-align: center">signed char</td>
      <td style="text-align: center">-128 ~ 127</td>
      <td style="text-align: center">음수 포함할 때</td>
    </tr>
    <tr>
      <td style="text-align: center">unsigned char</td>
      <td style="text-align: center">0 ~ 255</td>
      <td style="text-align: center">바이트 데이터 처리, 파일 읽기 등</td>
    </tr>
  </tbody>
</table>

<p>예를 들어 이미지 파일을 바이트 단위로 읽을 때는 unsigned char가 더 적절해. 0xFF(255)가 음수로 해석되면 문제가 생기거든</p>

<h4 id="정수-오버플로언더플로와-관련">정수 오버플로/언더플로와 관련</h4>

<p><strong>unsigned</strong>는 overflow/underflow 시 모듈로 연산처럼 동작</p>

<p><strong>signed</strong>는 overflow시 동작이 정의되지 않음(UB, undefined behavior)</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">x</span><span class="o">--</span><span class="p">;</span>  <span class="c1">// x = 4294967295 (underflow)</span>

<span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="mi">2147483647</span><span class="p">;</span>
<span class="n">y</span><span class="o">++</span><span class="p">;</span>  <span class="c1">// UB (비정상 동작 가능성)</span>
</code></pre></div></div>

<h4 id="unsignedsigned-정리">unsigned/signed 정리</h4>

<table>
  <thead>
    <tr>
      <th style="text-align: center">쓰는 이유</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">의미 명확히 하기</td>
      <td style="text-align: center">나이는 음수가 될 수 없으니 unsigned 사용</td>
    </tr>
    <tr>
      <td style="text-align: center">범위 확장</td>
      <td style="text-align: center">같은 바이트로 더 큰 수 저장</td>
    </tr>
    <tr>
      <td style="text-align: center">비트 연산 안전성</td>
      <td style="text-align: center">부호 없는 연산이 더 예측 가능함</td>
    </tr>
    <tr>
      <td style="text-align: center">성능/메모리 최적화</td>
      <td style="text-align: center">char 1바이트 단위로 다루고 싶을 때 등</td>
    </tr>
  </tbody>
</table>

<h2 id="rsp스택-포인터의-감소">%rsp(스택 포인터)의 감소</h2>

<ul>
  <li>%rsp는 데이터를 push하거나 스택 프레임을 만들 때 감소하는데, 이때의 감소량은 저장되는 데이터의 크기를 기준으로 해</li>
</ul>

<pre><code class="language-assembly">push %rbp   ; 8바이트 감소 (64비트 시스템에서 레지스터는 8바이트)
sub $16, %rsp  ; 스택에 16바이트 공간 확보 -&gt; %rsp는 16바이트 감소
</code></pre>

<p>예제 : 함수 진입 시 흔한 패턴:</p>
<pre><code class="language-assembly">push %rbp         ; 이전 프레임 포인터 저장 -&gt; %rsp -= 8
mov %rsp, %rbp    ; 현재 스택 포인터를 프레임 포인터로 복사
sub $32, %rsp     ; 로컬 변수 32바이트 공간 확보 -&gt; %rsp -= 32
</code></pre>

<p>예제 : 반대로 함수가 끝날 때:</p>
<pre><code class="language-assembly">leave             ; mov %rbp, %rsp + pop %rbp와 동일 (프레임 복구)
ret               ; 스택에서 리턴 주소 pop -&gt; %rsp += 8
</code></pre>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>