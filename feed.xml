<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="ko-KR, en-US"><generator uri="https://jekyllrb.com/" version="3.10.0">Jekyll</generator><link href="/feed.xml" rel="self" type="application/atom+xml" /><link href="/" rel="alternate" type="text/html" hreflang="ko-KR, en-US" /><updated>2025-04-30T14:52:32+00:00</updated><id>/feed.xml</id><title type="html">PurifiedPotion’s Blog</title><subtitle>A blog for computer science
</subtitle><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><entry><title type="html">Demand-zero memory</title><link href="/blog/computersystem/demand-zero-memory/" rel="alternate" type="text/html" title="Demand-zero memory" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>/blog/computersystem/demand-zero-memory</id><content type="html" xml:base="/blog/computersystem/demand-zero-memory/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#동작-흐름" id="markdown-toc-동작-흐름">동작 흐름</a></li>
  <li><a href="#왜-쓰일까" id="markdown-toc-왜-쓰일까">왜 쓰일까?</a></li>
  <li><a href="#언제-볼-수-있을까" id="markdown-toc-언제-볼-수-있을까">언제 볼 수 있을까?</a></li>
  <li><a href="#요약" id="markdown-toc-요약">요약</a>    <ul>
      <li><a href="#나만의-요약" id="markdown-toc-나만의-요약">나만의 요약</a></li>
    </ul>
  </li>
</ul>

<p><strong>Demand-zero memory(또는 zero-filled-on-demand page)</strong>는 운영체제가 <strong>“필요해질 때(demand)”</strong> 처음 접근되는 순간에만 물리 페이지를 연결하고, 그 페이지의 모든 바이트를 0으로 채워서(zero-fill) 사용자 프로세스에 넘겨주는 메모리 할당 기법</p>

<h2 id="동작-흐름">동작 흐름</h2>

<ol>
  <li>가상 주소 공간만 잡아 두기</li>
</ol>

<ul>
  <li>
    <p>프로그램이 malloc, VirtualAlloc(…, MEM_RESERVE), 스택 확대, BSS(전역/정적 0-초기화 변수) 등으로 “새 메모리를” 요구하면,</p>
  </li>
  <li>
    <p>커널은 대응되는 물리 페이지 없이 가상 주소 범위를 예약해 두고, PTE(Page-Table Entry)에 “아직 물리 페이지 없음, demand-zero”라는 플래그를 세워 둠</p>
  </li>
</ul>

<ol>
  <li>첫 접근 → 페이지 폴트(page fault)</li>
</ol>

<ul>
  <li>CPU가 그 주소를 읽거나 쓰려고 하면 PTE에 실제 프레임이 없으므로 페이지 폴트가 발생</li>
</ul>

<ol>
  <li>커널이 물리 페이지 할당 &amp; 0으로 초기화</li>
</ol>

<ul>
  <li>
    <p>커널의 Zero Page List에서 이미 0으로 클리어돼 있는 여유 페이지를 하나 꺼내오거나,</p>
  </li>
  <li>
    <p>여유 페이지가 없다면 새 페이지를 확보한 뒤 memset(page, 0, PAGE_SIZE)로 0-필(fill) 한다</p>
  </li>
</ul>

<ol>
  <li>PTE 갱신 후 재시도</li>
</ol>

<ul>
  <li>PTE를 “valid + 해당 물리 프레임”으로 고쳐 놓고, fault 된 명령을 재실행하면 이제 정상적으로 0값이 보임</li>
</ul>

<h2 id="왜-쓰일까">왜 쓰일까?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">장점</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">메모리 절약</td>
      <td style="text-align: center">큰 배열/구조체를 “0으로 초기화”해 예약만 해 놓고, 실제로 접근한 부분만 물리 메모리를 소비함</td>
    </tr>
    <tr>
      <td style="text-align: center">보안 &amp; 안정성</td>
      <td style="text-align: center">항상 0으로 채워 주므로, 이전 프로세스의 잔류 데이터가 노출되지 않음</td>
    </tr>
    <tr>
      <td style="text-align: center">속도(평균)</td>
      <td style="text-align: center">초기화 루프를 사용자 코드에서 돌릴 필요가 없고, 커널은 미리 0-클리어 해 둔 zero-page 풀을 재사용해 페이지 폴트 처리 시간을 최소화함</td>
    </tr>
  </tbody>
</table>

<h2 id="언제-볼-수-있을까">언제 볼 수 있을까?</h2>

<ul>
  <li>
    <p>Windows - MEM_COMMIT 없이 VirtualAlloc으로 예약만 한 뒤 접근할 때, 또는 일반 HeapAlloc/new 내부적으로</p>
  </li>
  <li>
    <p>Linux/Unix - 익명 매핑 mmap(…, MAP_ANONYMOUS)·스택·BSS·brk/sbrk 등</p>
  </li>
  <li>
    <p>하이퍼바이저/가상머신 - 게스트가 처음 쓰는 시점까지 진짜 호스트 RAM을 배정하지 않는 ballooning 기법과 결합되기도 함</p>
  </li>
</ul>

<h2 id="요약">요약</h2>

<p>Demand-zero memory = “필요할 때 0으로 초기화된 물리 페이지를 뒤늦게 붙이는 가상 메모리 기술”</p>

<p>→ 프로그램 입장에서는 ‘이미 0으로 초기화돼 있는 새 메모리’를 즉시 얻은 것처럼 보이지만, 실제 RAM은 첫 사용 시점까지 쓰이지 않아 메모리를 아끼고 보안을 높여 줌</p>

<h3 id="나만의-요약">나만의 요약</h3>

<ol>
  <li>
    <p>물리 메모리 같은 경우 첫 사용 전까지는 메모리 할당이 되지 않음</p>
  </li>
  <li>
    <p>하지만 가상 메모리에서는 공간이 확보된 상태</p>
  </li>
  <li>
    <p>실제 사용시에는 page fault 되면서 물리 메모리 할당이 이루어짐, PTE의 Not-present → Present로 갱신</p>
  </li>
</ol>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[Demand-zero memory(또는 zero-filled-on-demand page)는 운영체제가 “필요해질 때(demand)” 처음 접근되는 순간에만 물리 페이지를 연결하고, 그 페이지의 모든 바이트를 0으로 채워서(zero-fill) 사용자 프로세스에 넘겨주는 메모리 할당 기법이다]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">Direct Memory Access</title><link href="/blog/computersystem/dma/" rel="alternate" type="text/html" title="Direct Memory Access" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>/blog/computersystem/dma</id><content type="html" xml:base="/blog/computersystem/dma/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#dmadirect-memory-access란" id="markdown-toc-dmadirect-memory-access란">DMA(Direct Memory Access)란?</a></li>
  <li><a href="#왜-dma가-필요한가" id="markdown-toc-왜-dma가-필요한가">왜 DMA가 필요한가?</a></li>
  <li><a href="#기본-구성-요소" id="markdown-toc-기본-구성-요소">기본 구성 요소</a>    <ul>
      <li><a href="#dma-레지스터-src-dst-len" id="markdown-toc-dma-레지스터-src-dst-len">DMA 레지스터 SRC, DST, LEN</a></li>
    </ul>
  </li>
  <li><a href="#동작-흐름-x86-pc-예시" id="markdown-toc-동작-흐름-x86-pc-예시">동작 흐름 (x86 PC 예시)</a>    <ul>
      <li><a href="#동작-흐름-더-자세히" id="markdown-toc-동작-흐름-더-자세히">동작 흐름 더 자세히</a>        <ul>
          <li><a href="#1-단계---cpu까-준비만-하고-손을-뗀다" id="markdown-toc-1-단계---cpu까-준비만-하고-손을-뗀다">1 단계 - CPU까 준비만 하고 손을 뗀다</a></li>
          <li><a href="#2-단계---버스-소유권-교환" id="markdown-toc-2-단계---버스-소유권-교환">2 단계 - 버스 소유권 교환</a></li>
          <li><a href="#3-단계---실제-데이터-이동" id="markdown-toc-3-단계---실제-데이터-이동">3 단계 - 실제 데이터 이동</a></li>
          <li><a href="#4-단계---전송-완료-알림" id="markdown-toc-4-단계---전송-완료-알림">4 단계 - 전송 완료 알림</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#전송-모드" id="markdown-toc-전송-모드">전송 모드</a></li>
  <li><a href="#현대-시스템에서의-dma-변화" id="markdown-toc-현대-시스템에서의-dma-변화">현대 시스템에서의 DMA 변화</a></li>
  <li><a href="#장점과-단점-요약" id="markdown-toc-장점과-단점-요약">장점과 단점 요약</a></li>
  <li><a href="#실무-예시" id="markdown-toc-실무-예시">실무 예시</a></li>
  <li><a href="#운영체제-관점" id="markdown-toc-운영체제-관점">운영체제 관점</a></li>
</ul>

<h2 id="dmadirect-memory-access란">DMA(Direct Memory Access)란?</h2>

<p>DMA는 CPU를 거치지 않고 I/O 장치가 주 메모리(RAM)에 직접 읽기·쓰기 할 수 있도록 시스템 버스를 “잠깐” 빌려서 데이터 블록을 전송하는 하드웨어 메커니즘</p>

<h2 id="왜-dma가-필요한가">왜 DMA가 필요한가?</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">문제점(전통적 PIO)</th>
      <th style="text-align: center">DMA가 주는 이점</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">CPU가 I/O 레지스터를 통해 바이트 단위로 데이터를 옮기면 레이턴시·오버헤드가 큼</td>
      <td style="text-align: center">한 번에 수십~수천 바이트 블록을 메모리로 직행 ⇒ CPU cycles 절약</td>
    </tr>
    <tr>
      <td style="text-align: center">빠른 장치(SSD, 10 GbE NIC 등)는 CPU 속도보다 I/O 대역폭이 큼 → CPU가 “목”이 됨</td>
      <td style="text-align: center">DMA 엔진이 버스 마스터로 동작해 메모리 버스를 직접 차단·사용</td>
    </tr>
    <tr>
      <td style="text-align: center">멀티코어 시대에 CPU는 계산에 집중하고 싶음</td>
      <td style="text-align: center">CPU는 전송 시작/종료만 관리 → I/O wait 시간 줄고, 캐시 miss도 감소</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>덕분에 대역폭·지연시간 모두 절감, 특히 디스크 I/O, 네트워크 카드, 오디오 스트리밍처럼 폭이 넓고 반복적인 전송에 필수적이다</li>
</ul>

<h2 id="기본-구성-요소">기본 구성 요소</h2>

<ol>
  <li>
    <p>DMA 컨트롤러(DMAC)</p>

    <ul>
      <li>
        <p>전용 칩(고전 ISA-DMA) 또는 주변장치 내부 DMA 엔진(PCIe, NVMe 컨트롤러)</p>
      </li>
      <li>
        <p>소스/목적지 물리 주소, 전송 길이, 모드, 제어 플래그 등을 저장하는 레지스터(메모리 맵 레지스터) 보유</p>
      </li>
      <li>
        <p>여러 채널이 있으면 동시에 여러 장치 지원</p>
      </li>
    </ul>
  </li>
  <li>
    <p>시스템 버스</p>

    <ul>
      <li>
        <p>CPU ↔ 메모리 ↔ DMA 컨트롤러가 공유</p>
      </li>
      <li>
        <p>CPU와 DMAC가 동시에 쓰지 않도록 <strong>버스 중재(bus arbitration)</strong> 를 수행</p>
      </li>
    </ul>
  </li>
  <li>
    <p>메모리 버스</p>

    <ul>
      <li>DMAC가 버스 마스터(master) 권한을 요청(Bus Request, BR) → 메모리와 직접 주고받음</li>
    </ul>
  </li>
  <li>
    <p>주변장치(Device)</p>

    <ul>
      <li>디스크, NIC, GPU, 오디오 코드 … 데이터가 실제로 존재/필요한 곳</li>
    </ul>
  </li>
  <li>
    <p>CPU &amp; OS</p>

    <ul>
      <li>전송 파라미터를 DMAC 레지스터에 써 주고, 완료 인터럽트(DMA done)를 처리</li>
    </ul>
  </li>
  <li>
    <p>I/O 장치(버스 마스터 가능 장치)</p>

    <ul>
      <li>PCIe NIC, NVMe SSD, GPU 등은 자체 DMA 엔진을 내장해 버스 마스터 가 되기도 한다</li>
    </ul>
  </li>
</ol>

<h3 id="dma-레지스터-src-dst-len">DMA 레지스터 SRC, DST, LEN</h3>

<table>
  <thead>
    <tr>
      <th style="text-align: center">레지스터</th>
      <th style="text-align: center">역할</th>
      <th style="text-align: center">일반적 크기</th>
      <th style="text-align: center">세부 사항</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">SRC (Source Address)</td>
      <td style="text-align: center">읽어 올 원본 주소. 장치 → RAM 전송이면 장치 쪽 FIFO 주소, RAM → 장치 전송이면 RAM의 시작 주소</td>
      <td style="text-align: center">32 bit(SoC) 또는 64 bit(서버)</td>
      <td style="text-align: center">* 버스트·비버스트 여부, 버스트 길이에 따라 자동 증가(inc) 여부 선택 플래그 존재<br />* Scatter-Gather 모드에선 “다음 표(list) 항목” 주소로 해석되기도 함</td>
    </tr>
    <tr>
      <td style="text-align: center">DST (Destination Address)</td>
      <td style="text-align: center">쓰기 대상 주소</td>
      <td style="text-align: center">32/64 bit</td>
      <td style="text-align: center">* 자동 증가/고정 선택 가능 (예: 오디오 DAC 같은 스트리밍 장치는 고정 주소, 메모리 버퍼는 증가)</td>
    </tr>
    <tr>
      <td style="text-align: center">LEN (Length / Count)</td>
      <td style="text-align: center">총 바이트(혹은 워드) 수</td>
      <td style="text-align: center">16 bit(65 kB) ~ 32 bit(4 GB) 이상</td>
      <td style="text-align: center">* 전송이 끝날 때마다 LEN–; 0 → 인터럽트 발생<br />* 어떤 컨트롤러는 LEN 대신 COUNT×DATA_WIDTH 형태 사용</td>
    </tr>
  </tbody>
</table>

<p><strong>요약</strong> : SRC·DST는 “어디서 → 어디로”를, LEN은 “얼마나”를 알려주는 좌표 + 거리 정보라고 생각하면 된다</p>

<h2 id="동작-흐름-x86-pc-예시">동작 흐름 (x86 PC 예시)</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: center">신호선 &amp; 동작</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">① CPU 설정</td>
      <td style="text-align: center">DMAC 레지스터에 &lt;소스, 목적지, 길이, 모드&gt; 기록 후 Bus Request(BR) 활성화</td>
    </tr>
    <tr>
      <td style="text-align: center">② 버스 획득</td>
      <td style="text-align: center">CPU가 <em>Bus Grant(BG)</em>로 응답 → CPU 파이프라인이 버스를 놓고 다른 연산(레지스터 계산 등) 수행</td>
    </tr>
    <tr>
      <td style="text-align: center">③ 데이터 전송</td>
      <td style="text-align: center">DMAC가 메모리 ↔ 장치 간 버스 싸이클 생성</td>
    </tr>
    <tr>
      <td style="text-align: center">④ 완료 인터럽트</td>
      <td style="text-align: center">전송 길이가 0이 되면 DMAC가 CPU에 DMA 완료 인터럽트. CPU는 이후 버스 재획득</td>
    </tr>
  </tbody>
</table>

<p><strong>중요</strong> : DMAC가 버스를 잡은 동안 메모리 전체 버스 주도권을 갖기 때문에 CPU는 RAM을 전혀 접근하지 못한다. 개별 “주소 권한”이 아닌 “버스 소유권”의 문제다. 이 때문에 짝수 클럭마다 한 워드만 빼앗고 바로 돌려주는 Cycle Stealing 모드가 등장했다</p>

<h3 id="동작-흐름-더-자세히">동작 흐름 더 자세히</h3>

<p><img src="/assets/img/blog/computerscience/dma.png" alt="DMA" /></p>

<h4 id="1-단계---cpu까-준비만-하고-손을-뗀다">1 단계 - CPU까 준비만 하고 손을 뗀다</h4>

<ol>
  <li>
    <p>전송 파라미터 설정</p>

    <ul>
      <li>
        <p>SRC, DST, LEN, MODE을 레지스터에 값을 써 넣습니다</p>
      </li>
      <li>
        <p>마지막으로 Enable 플래그를 1로 두면 DMAC가 “이제 내가 처리할게!”하고 대기</p>
      </li>
    </ul>
  </li>
  <li>
    <p>버스 요청(BR 신호)</p>

    <ul>
      <li>DMAC는 버스 중재기(arbiter)에게 “버스 좀 빌려주세요” 라고 손을 듦</li>
    </ul>
  </li>
</ol>

<h4 id="2-단계---버스-소유권-교환">2 단계 - 버스 소유권 교환</h4>

<ol>
  <li>
    <p>CPU → DMAC ‘Bus Grant(BG)’</p>

    <ul>
      <li>
        <p>CPU가 진행 중인 버스 싸이클을 마치면 주소·데이터 라인을 tristate해 두고 계산 같은 비-버스 작업에 집중함</p>

        <ul>
          <li>
            <p>tristate란, 여러개의 마스터(CPU, DMAC, GPU…)가 하나의 전선을 공유하고, 한 쪽이 0V, 다른쪽이 동시에 Vcc를 내보내면 단락(short) 위험을 방지하고자 버스를 넘겨받은 쪽만 드라이버를 켜고 나머지는 Hi-Z로 물러나야 함</p>
          </li>
          <li>
            <p>버스가 필요 없는 작업이란, 파이프라인이 레지스터와 내부 캐시 만으로 실행 가능한 명령들</p>
          </li>
        </ul>
      </li>
    </ul>
  </li>
  <li>
    <p>DMAC가 버스 장악</p>

    <ul>
      <li>
        <p>이 순간부터 RAM과 I/O 장치 사이를 오가는 모든 신호는 DMAC가 생성</p>
      </li>
      <li>
        <p>CPU는 RAM을 못 만지기 때문에 캐시 miss가 나도 대기해야 함</p>
      </li>
    </ul>
  </li>
</ol>

<h4 id="3-단계---실제-데이터-이동">3 단계 - 실제 데이터 이동</h4>

<ol>
  <li>
    <p>전송 모드에 따른 사이클</p>

    <ul>
      <li>
        <p>Burst/Block : LEN만큼 연속으로 → 최고속, 대신 CPU 길게 정지</p>
      </li>
      <li>
        <p>Cycle-Stealing : 한 사이클씩 “훔치고” 바로 돌려줌 → 실시간 오디어/비디오</p>
      </li>
      <li>
        <p>Scatter-Gather : 메모리 리스트 따라 다중 블록 자동 전송 → NVMe·NIC</p>
      </li>
    </ul>
  </li>
  <li>
    <p>주소·카운터 자동 증가</p>

    <ul>
      <li>DMAC 내부 카운터가 0이 될 때까지 SRC++, DST++, LEN–</li>
    </ul>
  </li>
</ol>

<h4 id="4-단계---전송-완료-알림">4 단계 - 전송 완료 알림</h4>

<ol>
  <li>
    <p>DMA 완료 인터럽트</p>

    <ul>
      <li>
        <p>LEN==0 → DMAC가 IRQ를 날리고 버스 요청을 내림</p>
      </li>
      <li>
        <p>CPU는 인터럽트 핸들러에서 데이터 후처리(예: 패킷 파싱, 디스크 블록 체크섬) 수행</p>
      </li>
    </ul>
  </li>
  <li>
    <p>버스 복귀</p>

    <ul>
      <li>Arbiter가 다시 CPU에 ‘Bus Grant’ → 평상시 메모리 접근 재개</li>
    </ul>
  </li>
</ol>

<h2 id="전송-모드">전송 모드</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">모드</th>
      <th style="text-align: center">특징</th>
      <th style="text-align: center">사용 예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">Cycle-Stealing</td>
      <td style="text-align: center">버스 싸이클 1 개만 “훔친” 뒤 즉시 CPU에 반환 → CPU 지연 최소</td>
      <td style="text-align: center">실시간 오디오, 비디오 스트림</td>
    </tr>
    <tr>
      <td style="text-align: center">Block/Burst</td>
      <td style="text-align: center">전체 블록(혹은 버스트) 한 번에 전송 → 가장 빠르지만 CPU 길게 정지</td>
      <td style="text-align: center">SATA, SDIO, 대부분의 PCIe 장치</td>
    </tr>
    <tr>
      <td style="text-align: center">Demand/Scatter-Gather</td>
      <td style="text-align: center">장치가 필요할 때마다, 혹은 메모리 리스트 기반 다중 블록 이동</td>
      <td style="text-align: center">고성능 NIC, NVMe SSD, GPU VRAM 업로드</td>
    </tr>
  </tbody>
</table>

<h2 id="현대-시스템에서의-dma-변화">현대 시스템에서의 DMA 변화</h2>

<ol>
  <li>
    <p>PCIe Bus mastering - 주변장치가 메인 메모리를 완전히 “빌려” 직접 읽고/쓴다</p>
  </li>
  <li>
    <p>IOMMU(DMA-Remapping) - 가상화·보안 목적. 장치가 접근 가능한 주소를 OS가 테이블로 전환 → 버퍼 오염·DMA 공격 방어</p>
  </li>
  <li>
    <p>Cache coherency 문제 - CPU 캐시에 남은 더러운(line dirty) 데이터 vs DMA가 본 메모리 불일치. 해결 : dma_sync_*() - (Linux)·Cache flush, non-cacheable region, snoopint 버스.</p>
  </li>
  <li>
    <p>Zero-copy - 네트워크 스택이나 GPU ↔ CPU 사이에서 “복사 없는” 파이프라인 구축 (DPDK, RDMA, CUDA cudaMemcpyAsync 등)</p>

    <ul>
      <li>운영체제 버퍼를 추가로 “복사(copy)”하지 않고, 장치 ↔ 응용이 같은 메모리 페이지를 공유하도록 하는 기법. CPU가 불필요한 memcpy()를 안 하므로 지연과 캐시오염↓</li>
    </ul>
  </li>
  <li>
    <p>RDMA(Remode DMA) - NIC가 원격 호스트의 메모리에까지 DMA 쓰기/읽기를 수행. 커널 네트워크 스택을 우회하여 μs 단위 지연시간을 제공한다. 고속 HPC, 데이터베이스 복제에서 필수</p>
  </li>
</ol>

<h2 id="장점과-단점-요약">장점과 단점 요약</h2>

<p><strong>장점</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- CPU 사용률 감소, 전력 효율 ↑

- 대역폭 활용 극대화(PCIe Gen4 x4 ≈ 8 GB/s 급)

- 실시간 스트리밍 지원(오디오 스터터링 방지 등)
</code></pre></div></div>

<p><strong>단점</strong></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>- 하드웨어·드라이버 복잡도 증가

- 버스 우선순위 조정 실패 시 CPU 지연 가능

- 캐시 일관성, 보안("DMA 공격") 이슈 처리 필요

    - IOMMU로 보완
</code></pre></div></div>

<h2 id="실무-예시">실무 예시</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">장치</th>
      <th style="text-align: center">DMA 활용</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">SSD/NVMe</td>
      <td style="text-align: center">플래시 컨트롤러가 OS 버퍼를 읽어 와 NAND로 쓰기, 반대 방향 읽기</td>
    </tr>
    <tr>
      <td style="text-align: center">10 GbE NIC</td>
      <td style="text-align: center">패킷을 커널 버퍼나 XSP ring으로 직접 놓고, 완료 시 인터럽트</td>
    </tr>
    <tr>
      <td style="text-align: center">GPU</td>
      <td style="text-align: center">대용량 텍스처/버퍼를 PCIe로 복사하거나, VRAM↔CPU RAM pinned transfer</td>
    </tr>
    <tr>
      <td style="text-align: center">Audio Codec</td>
      <td style="text-align: center">PCM 버퍼를 주기적으로 DMA → DAC, 실시간 재생</td>
    </tr>
    <tr>
      <td style="text-align: center">USB 컨트롤러</td>
      <td style="text-align: center">호스트 메모리의 전송 링(Transfer Ring)을 DMA 로 순회</td>
    </tr>
  </tbody>
</table>

<h2 id="운영체제-관점">운영체제 관점</h2>

<ul>
  <li>
    <p>Linux : dma_map_single(), dma_alloc_coherent(), struct dma_async_tx_descriptor, DMAengine 프레임워크</p>
  </li>
  <li>
    <p>Windows : WdfDmaTransaction*, KeFlushIoBuffers(), Scatter/Gather 목록 지원</p>
  </li>
  <li>
    <p>RTOS(FreeRTOS, Zephyr) : MCU마다 별도의 DMAMUX &amp; HAP API 제공</p>
  </li>
</ul>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[여태까지 컴퓨터는 직접 메모리에 대해 접근하지 않고 가상 메모리를 사용하는 것으로 배웠는데, 만약 직접 메모리 접근이 있다면?]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">System Call</title><link href="/blog/computersystem/system-call/" rel="alternate" type="text/html" title="System Call" /><published>2025-04-28T00:00:00+00:00</published><updated>2025-04-28T00:00:00+00:00</updated><id>/blog/computersystem/system-call</id><content type="html" xml:base="/blog/computersystem/system-call/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#호출-흐름리눅스-x86-64-예" id="markdown-toc-호출-흐름리눅스-x86-64-예">호출 흐름(리눅스 x86-64 예)</a></li>
  <li><a href="#대표-범주" id="markdown-toc-대표-범주">대표 범주</a></li>
  <li><a href="#언제-볼-수-있을까" id="markdown-toc-언제-볼-수-있을까">언제 볼 수 있을까?</a></li>
  <li><a href="#요약" id="markdown-toc-요약">요약</a>    <ul>
      <li><a href="#나만의-요약" id="markdown-toc-나만의-요약">나만의 요약</a></li>
    </ul>
  </li>
</ul>

<p>응용 프로그램(유저 레벨 코드)이 직접 하드웨어를 만지면 안 되므로, 운영체제(OS)가 대신 해준다. 프로세스가 커널에게 무언가를 “요청”하는 공식 통로가 바로 <strong>System Call</strong>이다.</p>

<ul>
  <li>
    <p>“파일을 열어 줘(open)”, “데이터를 읽어 줘(read)”, “새 프로세스를 만들어 줘(fork)” … 같은 요구 사항을 전달한다</p>
  </li>
  <li>
    <p>커널은 트랩(trap)을 통해 특권 모드(커널 모드)로 올라가 작업을 수행한 뒤, 결과(보통 레지스터 값 또는 errno)를 돌려주고 사용자 모드로 복귀한다</p>
  </li>
</ul>

<h2 id="호출-흐름리눅스-x86-64-예">호출 흐름(리눅스 x86-64 예)</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단계</th>
      <th style="text-align: left">사용자 공간</th>
      <th style="text-align: left">커널 공간</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">1</td>
      <td style="text-align: left">라이브러리 wrapper 함수 (read(int fd, void *buf, size_t n))</td>
      <td style="text-align: left">-</td>
    </tr>
    <tr>
      <td style="text-align: center">2</td>
      <td style="text-align: left">시스템 콜 번호와 인수들을 레지스터에 적재하고 syscall(또는 int 0x80) 실행</td>
      <td style="text-align: left">트랩 발생→권한 레벨 전환, 커널 스택 진입</td>
    </tr>
    <tr>
      <td style="text-align: center">3</td>
      <td style="text-align: left">시스템 콜 디스패처가 번호를 해석해 해당 핸들러(sys_read) 호출</td>
      <td style="text-align: left">핸들러가 실제 I/O 수행, 파일 테이블 등 갱신</td>
    </tr>
    <tr>
      <td style="text-align: center">4</td>
      <td style="text-align: left">반환값을 레지스터에 넣고 sysret</td>
      <td style="text-align: left">-</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: left">라이브러리 wrapper가 음수면 errno 설정 후 반환</td>
      <td style="text-align: left">-</td>
    </tr>
  </tbody>
</table>

<p>여기서 <strong>컨텍스트 스위치(레지스터·프로그램 카운터·스택 교체)</strong>는 수십 ~ 수백 나노초가 소요되므로, 시스템 콜은 함수 호출보다 느리다</p>

<h2 id="대표-범주">대표 범주</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">범주</th>
      <th style="text-align: left">대표 시스템 콜</th>
      <th style="text-align: left">설명·용도</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">프로세스 제어</td>
      <td style="text-align: left">fork, execve, waitpid, exit</td>
      <td style="text-align: left">프로세스 생성·변경·종료</td>
    </tr>
    <tr>
      <td style="text-align: center">파일 I/O</td>
      <td style="text-align: left">open/close, read/write, lseek, stat</td>
      <td style="text-align: left">모든 디스크·파이프·소켓 I/O 통일 인터페이스(“Everything is a file”)</td>
    </tr>
    <tr>
      <td style="text-align: center">장치 제어</td>
      <td style="text-align: left">ioctl, mmap, munmap</td>
      <td style="text-align: left">특수 장치 제어, 파일 매핑 등</td>
    </tr>
    <tr>
      <td style="text-align: center">메모리 관리</td>
      <td style="text-align: left">brk, mmap</td>
      <td style="text-align: left">힙 확장(malloc 내부)</td>
    </tr>
    <tr>
      <td style="text-align: center">5</td>
      <td style="text-align: left">라이브러리 wrapper가 음수면 errno 설정 후 반환</td>
      <td style="text-align: left">-</td>
    </tr>
  </tbody>
</table>

<h2 id="언제-볼-수-있을까">언제 볼 수 있을까?</h2>

<ul>
  <li>
    <p>Windows - MEM_COMMIT 없이 VirtualAlloc으로 예약만 한 뒤 접근할 때, 또는 일반 HeapAlloc/new 내부적으로</p>
  </li>
  <li>
    <p>Linux/Unix - 익명 매핑 mmap(…, MAP_ANONYMOUS)·스택·BSS·brk/sbrk 등</p>
  </li>
  <li>
    <p>하이퍼바이저/가상머신 - 게스트가 처음 쓰는 시점까지 진짜 호스트 RAM을 배정하지 않는 ballooning 기법과 결합되기도 함</p>
  </li>
</ul>

<h2 id="요약">요약</h2>

<p>Demand-zero memory = “필요할 때 0으로 초기화된 물리 페이지를 뒤늦게 붙이는 가상 메모리 기술”</p>

<p>→ 프로그램 입장에서는 ‘이미 0으로 초기화돼 있는 새 메모리’를 즉시 얻은 것처럼 보이지만, 실제 RAM은 첫 사용 시점까지 쓰이지 않아 메모리를 아끼고 보안을 높여 줌</p>

<h3 id="나만의-요약">나만의 요약</h3>

<ol>
  <li>
    <p>물리 메모리 같은 경우 첫 사용 전까지는 메모리 할당이 되지 않음</p>
  </li>
  <li>
    <p>하지만 가상 메모리에서는 공간이 확보된 상태</p>
  </li>
  <li>
    <p>실제 사용시에는 page fault 되면서 물리 메모리 할당이 이루어짐, PTE의 Not-present → Present로 갱신</p>
  </li>
</ol>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[응용프로그램(User level code)이 Hardware를 조작하고 싶을때, 무엇을 할까?]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">수작업으로 Malloc 구현(9.9장)</title><link href="/blog/computersystem/dynamic-memory-allocation/" rel="alternate" type="text/html" title="수작업으로 Malloc 구현(9.9장)" /><published>2025-04-27T00:00:00+00:00</published><updated>2025-04-27T00:00:00+00:00</updated><id>/blog/computersystem/dynamic-memory-allocation</id><content type="html" xml:base="/blog/computersystem/dynamic-memory-allocation/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#malloc-할당" id="markdown-toc-malloc-할당">Malloc 할당</a>    <ul>
      <li><a href="#응용-프로그램" id="markdown-toc-응용-프로그램">응용 프로그램</a></li>
      <li><a href="#allocator" id="markdown-toc-allocator">Allocator</a></li>
      <li><a href="#용어-정리" id="markdown-toc-용어-정리">용어 정리</a></li>
    </ul>
  </li>
  <li><a href="#명시적-리스트explicit-list에서의-refactoring" id="markdown-toc-명시적-리스트explicit-list에서의-refactoring">명시적 리스트(Explicit list)에서의 refactoring</a>    <ul>
      <li><a href="#refactoring-함수" id="markdown-toc-refactoring-함수">Refactoring 함수</a></li>
      <li><a href="#개선된-case-4" id="markdown-toc-개선된-case-4">개선된 Case 4</a></li>
    </ul>
  </li>
</ul>

<p>말록 구현에 앞서, <strong>명시적 할당자(Explicit allocator)</strong>와 <strong>묵시적 할당자(Implicit allocator)</strong>에 대해 알아 보자</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">Explicit allocator</th>
      <th style="text-align: center">Implicit allocator</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">사용 예</td>
      <td style="text-align: center">C언어에서 malloc 할당과 free</td>
      <td style="text-align: center">Java의 garbage collection, ML, and Lisp</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>free 수행에 관해서 직접적인지 또는 간접적인지에 따라서 달라진다</li>
</ul>

<p><strong>Malloc</strong>에 관하여서는 이전에 포스팅한 [동적 메모리 할당(Dynamic memory allocation)]{:.heading.flip-title} 을 참조하면 된다</p>

<p>여기서 다룰 내용은 <strong>Explicit allocator</strong>인 malloc 할당을 직접 구현할 예정이다</p>

<h2 id="malloc-할당">Malloc 할당</h2>

<p><img src="/assets/img/blog/computerscience/mallocallocation.png" alt="말록 할당" /></p>

<p>위 사진의 순서 같은 경우 아래와 같다</p>

<ol>
  <li>
    <p>p1(int사이즈X4) 할당</p>
  </li>
  <li>
    <p>p2(int사이즈X5) 할당</p>
  </li>
  <li>
    <p>p3(int사이즈X6) 할당</p>
  </li>
  <li>
    <p>p2 free</p>
  </li>
  <li>
    <p>p4(int사이즈X2) 할당</p>
  </li>
</ol>

<h3 id="응용-프로그램">응용 프로그램</h3>

<ul>
  <li>
    <p>응용프로그램 같은 경우 마음대로 malloc 할당과 free 요청이 가능하다</p>
  </li>
  <li>
    <p>free 할 시에는 malloc된 block이어야 한다</p>
  </li>
</ul>

<h3 id="allocator">Allocator</h3>

<p>명시적 할당기들은 아래와 같은 엄격한 제한사항 내에서 동작해야 함</p>

<ul>
  <li>
    <p>할당된 블럭의 갯수와 크기에 대한 관리 권한이 없다</p>
  </li>
  <li>
    <p>malloc 요청에 즉각 반응해야 함</p>

    <ul>
      <li>이 뜻은 추후 할당에 대해 대기가 불가능하다는 것이다</li>
    </ul>
  </li>
  <li>
    <p>free된 메모리에서만 할당이 가능하다</p>
  </li>
  <li>
    <p>block의 크기에 대해서 정렬 요구사항에 맞추어야 한다</p>

    <ul>
      <li>
        <p>리눅스 기준 아래와 같다</p>
      </li>
      <li>
        <p>x86 : 8byte, x86-64 : 16byte</p>
      </li>
    </ul>
  </li>
  <li>
    <p>free블록에 관해서만 조작이 가능하다</p>
  </li>
  <li>
    <p>일단 malloc할당 되었으면, 움직일 수 없다</p>

    <ul>
      <li>이 말은 압축이 불가능하다는 이야기</li>
    </ul>
  </li>
</ul>

<h3 id="용어-정리">용어 정리</h3>

<p><img src="/assets/img/blog/computerscience/blockdefinition.png" alt="블록 용어 정리" /></p>

<ul>
  <li>
    <p>Throughput : 시간당 완료된 요청의 갯수 (5000의 malloc할당과 5000의 free요청을 10초 안에 완수하면, 1000operations/second)</p>
  </li>
  <li>
    <p>Payload : 블럭 안에서 실제로 사용할 Data</p>
  </li>
  <li>
    <p>Overhead : 블럭 안에서 payload 제외한 나머지(header, footer, padding)</p>
  </li>
  <li>
    <p>Aggregate payload : 할당된 블럭들의 Data들의 총합</p>
  </li>
  <li>
    <p>최고 이용도(Peak utilization) : 할당기가 힙을 얼마나 효율적으로 사용하는지를 규정하는 많은 방법들 중 하나</p>

    <ul>
      <li>Pk는 현재 할당된 블록들의 데이터들의 합, Hk는 현재 힙의 크기</li>
    </ul>

    <p>-
\(U_k = \frac{\max_{i \le k} P_i}{H_k}\)</p>
  </li>
  <li>
    <p>내부 단편화(Internal fragmentation) : Overhead나 padding에 의해서 발생되는데, 블록 내부에서 메모리를 효율적으로 관리하지 못하는 것</p>
  </li>
</ul>

<p><img src="/assets/img/blog/computerscience/externalfragmentation.png" alt="외부 단편화" /></p>

<ul>
  <li>외부 단편화(External fragmentation) : 가용 블록의 합들은 충분하지만, 가용 블록에 할당할 적당한 크기가 없게 관리가 된것</li>
</ul>

<h2 id="명시적-리스트explicit-list에서의-refactoring">명시적 리스트(Explicit list)에서의 refactoring</h2>

<p>명시적 리스트를 구현하기 위해서 조금 복잡하게 구현했던 내용 개선에 대해서 얘기하려고 해</p>

<p>명시적 리스트를 구현하기 위해서는 가용 블록의 포인터 생성/변경 고려가 필요, 포인터 생성/변경 같은 경우 아래 사진과 같이 구현해야 함</p>

<p><img src="/assets/img/blog/computerscience/case4.png" alt="Case 4" /></p>

<p>Case 4 같은 경우에 포인터 8개의 생성/변경이 필요하기 때문에 아래와 같은 코드가 나옴</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">coalesce</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">prev_alloc</span> <span class="o">=</span> <span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
    <span class="kt">size_t</span> <span class="n">next_alloc</span> <span class="o">=</span> <span class="n">GET_ALLOC</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
    <span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_free_root</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_free_root_prev</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">next_free_blk_next</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">next_free_blk_prev</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_free_blk_next</span><span class="p">;</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_free_blk_prev</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="n">next_alloc</span><span class="p">)</span>               <span class="c1">// Case 1</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">free_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">prev_free_root</span> <span class="o">=</span> <span class="n">free_root</span><span class="p">;</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_root</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">prev_free_root</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">next_alloc</span><span class="p">)</span>         <span class="c1">// Case 2</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">free_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">prev_free_root</span> <span class="o">=</span> <span class="n">free_root</span><span class="p">;</span>
            <span class="n">prev_free_root_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">free_root</span><span class="p">);</span>
            <span class="n">next_free_blk_next</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
            <span class="n">next_free_blk_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">next_free_blk_prev</span><span class="p">,</span> <span class="n">next_free_blk_next</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">next_free_blk_next</span><span class="p">,</span> <span class="n">next_free_blk_prev</span><span class="p">);</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">prev_free_root</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_root_prev</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_alloc</span> <span class="o">&amp;&amp;</span> <span class="n">next_alloc</span><span class="p">)</span>         <span class="c1">// Case 3</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">free_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="n">prev_free_root</span> <span class="o">=</span> <span class="n">free_root</span><span class="p">;</span>
            <span class="n">prev_free_root_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">free_root</span><span class="p">);</span>
            <span class="n">prev_free_blk_next</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
            <span class="n">prev_free_blk_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">prev_free_blk_prev</span><span class="p">,</span> <span class="n">prev_free_blk_next</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_blk_next</span><span class="p">,</span> <span class="n">prev_free_blk_prev</span><span class="p">);</span>
            <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">prev_free_root</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
            <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_root_prev</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
            <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="p">}</span>
    <span class="k">else</span>                                        <span class="c1">// Case 4</span>
    <span class="p">{</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)))</span> <span class="o">+</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">)),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

        <span class="n">prev_free_root</span> <span class="o">=</span> <span class="n">free_root</span><span class="p">;</span>
        <span class="n">prev_free_root_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">free_root</span><span class="p">);</span>
        <span class="n">prev_free_blk_next</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
        <span class="n">prev_free_blk_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">PREV_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
        <span class="n">next_free_blk_next</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
        <span class="n">next_free_blk_prev</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">NEXT_BLKP</span><span class="p">(</span><span class="n">bp</span><span class="p">));</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">prev_free_blk_prev</span><span class="p">,</span> <span class="n">prev_free_blk_next</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_blk_next</span><span class="p">,</span> <span class="n">prev_free_blk_prev</span><span class="p">);</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">next_free_blk_prev</span><span class="p">,</span> <span class="n">next_free_blk_next</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">next_free_blk_next</span><span class="p">,</span> <span class="n">next_free_blk_prev</span><span class="p">);</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">prev_free_root</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">prev_free_root_prev</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>
        <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>동료의 의견도 있었고 Google AI Studio의 의견에 따라서 함수 구현함</p>

<p><img src="/assets/img/blog/computerscience/googleaistudio.png" alt="Google AI Studio" /></p>

<h3 id="refactoring-함수">Refactoring 함수</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// --- Helper 함수 (place, coalesce 에서 사용) ---</span>
<span class="c1">// Free list 맨 앞에 블록 추가 (LIFO)</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_to_free_list</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">free_root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// 리스트가 비어있을 때</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// 리스트에 블록이 있을 때</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">free_root</span><span class="p">);</span>   <span class="c1">// 현재 위치의 next를 기존 첫번째 free block</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>        <span class="c1">// 현재 위치의 prev를 NULL</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">free_root</span><span class="p">,</span> <span class="n">bp</span><span class="p">);</span>   <span class="c1">// 기존 첫번째 free block의 PREV를 현재 블록으로</span>
        <span class="n">free_root</span> <span class="o">=</span> <span class="n">bp</span><span class="p">;</span> <span class="c1">// 루트를 새 블록으로 업데이트</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Free list에서 블록 제거</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">remove_from_free_list</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">prev_free</span> <span class="o">=</span> <span class="n">PREV_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">next_free</span> <span class="o">=</span> <span class="n">NEXT_FREE</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">prev_free</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// bp가 리스트의 첫 번째 블록일 때</span>
        <span class="n">free_root</span> <span class="o">=</span> <span class="n">next_free</span><span class="p">;</span> <span class="c1">// 다음 블록을 루트로 설정</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="c1">// bp가 중간 또는 마지막 블록일 때</span>
        <span class="n">SET_NEXT_FREE</span><span class="p">(</span><span class="n">prev_free</span><span class="p">,</span> <span class="n">next_free</span><span class="p">);</span> <span class="c1">// 이전 블록의 NEXT를 다음 블록으로</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">next_free</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// bp가 마지막 블록이 아닐 때</span>
        <span class="n">SET_PREV_FREE</span><span class="p">(</span><span class="n">next_free</span><span class="p">,</span> <span class="n">prev_free</span><span class="p">);</span> <span class="c1">// 다음 블록의 PREV를 이전 블록으로</span>
    <span class="p">}</span>
    <span class="c1">// bp의 포인터는 초기화할 필요 없음 (어차피 할당되거나 병합될 것임)</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="개선된-case-4">개선된 Case 4</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">// Case 4: Merge with both previous and next blocks</span>
    <span class="k">else</span> <span class="p">{</span> <span class="c1">// (!prev_alloc &amp;&amp; !next_alloc)</span>
        <span class="n">remove_from_free_list</span><span class="p">(</span><span class="n">prev_blk</span><span class="p">);</span> <span class="c1">// Remove previous block</span>
        <span class="n">remove_from_free_list</span><span class="p">(</span><span class="n">next_blk</span><span class="p">);</span> <span class="c1">// Remove next block</span>
        <span class="n">size</span> <span class="o">+=</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">prev_blk</span><span class="p">))</span> <span class="o">+</span> <span class="n">GET_SIZE</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">next_blk</span><span class="p">));</span> <span class="c1">// Use HDRP for next block size</span>
        <span class="n">bp</span> <span class="o">=</span> <span class="n">prev_blk</span><span class="p">;</span> <span class="c1">// Move bp to the beginning of the merged block</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">HDRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
        <span class="n">PUT</span><span class="p">(</span><span class="n">FTRP</span><span class="p">(</span><span class="n">bp</span><span class="p">),</span> <span class="n">PACK</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span> <span class="c1">// Footer position is FTRP(next_blk)</span>
        <span class="n">add_to_free_list</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span> <span class="c1">// Add the final merged block to the list</span>
        <span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[C언어로 직접 Malloc을 구현해보자]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">링커(Linking)</title><link href="/blog/computersystem/linking/" rel="alternate" type="text/html" title="링커(Linking)" /><published>2025-04-21T00:00:00+00:00</published><updated>2025-04-21T00:00:00+00:00</updated><id>/blog/computersystem/linking</id><content type="html" xml:base="/blog/computersystem/linking/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#링커의-역할" id="markdown-toc-링커의-역할">링커의 역할</a>    <ul>
      <li><a href="#링킹을-왜-배워야-할까" id="markdown-toc-링킹을-왜-배워야-할까">링킹을 왜 배워야 할까?</a></li>
    </ul>
  </li>
  <li><a href="#정적-연결" id="markdown-toc-정적-연결">정적 연결</a></li>
  <li><a href="#목적파일" id="markdown-toc-목적파일">목적파일</a></li>
  <li><a href="#재배치-가능-목적파일with-elf--executable-and-linkable-format" id="markdown-toc-재배치-가능-목적파일with-elf--executable-and-linkable-format">재배치 가능 목적파일(with ELF : Executable and Linkable Format)</a></li>
  <li><a href="#실행-가능-목적파일의-로딩" id="markdown-toc-실행-가능-목적파일의-로딩">실행 가능 목적파일의 로딩</a>    <ul>
      <li><a href="#로더-실행" id="markdown-toc-로더-실행">로더 실행</a></li>
    </ul>
  </li>
</ul>

<p><strong>링킹(linking)</strong>은 여러 개의 코드와 데이터를 모아서 연결하여 메모리에 로드될 수 있고 실행될 수 있는 한 개의 파일로 만드는 작업이다.</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center"> </th>
      <th style="text-align: center">로더에 의해서 실행</th>
      <th style="text-align: center">응용프로그램에 의해서 실행</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">링커 수행 시기</td>
      <td style="text-align: center">로드 타임</td>
      <td style="text-align: center">실행 시</td>
    </tr>
  </tbody>
</table>

<h2 id="링커의-역할">링커의 역할</h2>

<p>링커는 독립적인 컴파일을 가능하게 한다. 이 뜻이 뭐냐하면, 큰 규모의 응용프로그램을 한 개의 소스 파일로 구성하는 대신에 컴파일할 수 있는 보다 관리할 만한 규모의 더 작은 모듈들로 나눌 수 있다. 그리고 이거를 별도로 수정할 수 있게 된다.</p>

<ul>
  <li>모듈 중에 한 개를 변경할 때, 이 파일만을 간단히 재컴파일하고 다른 파일들을 재컴파일할 필요 없이 이 응용을 다시 링크한다.</li>
</ul>

<h3 id="링킹을-왜-배워야-할까">링킹을 왜 배워야 할까?</h3>

<ul>
  <li>
    <p><strong>큰 규모의 프로그램을 개발</strong>할 때, 링킹을 사용하게 될 텐데, <strong>어떻게 링커가 참조를 핵결해 나가는지, 라이브러리가 무엇인지를 배워서 링커 에러를 해결할 수 있다.</strong></p>
  </li>
  <li>
    <p>언어의 <strong>변수 영역 규칙이 구현되었는지 이해</strong>하는데 도움이 된다. 예를 들어, <strong>전역변수와 지역변수의 차이</strong>는 무엇인가?</p>
  </li>
  <li>
    <p><strong>공유 라이브러리에 대해 이해</strong>할 수 있다.</p>
  </li>
</ul>

<p>더 여러가지가 있지만, 내 기준에서 중요할 것 같은 내용들만 뽑아왔다.</p>

<h2 id="정적-연결">정적 연결</h2>

<p><strong>재배치 가능한 목적파일(.o)들</strong>과 <strong>명령줄 인자들을 입력</strong>으로 받아들여서 로드될 수 있고 실행될 수 있는 완전히 링크된 실행 가능 목적파일을 출력으로 생성한다.</p>

<p>실행파일을 만들기 위해서 링커는 두 가지 주요 작업을 수행해야 함</p>

<ol>
  <li><strong>심볼 해석(symbol resolution)</strong> : 목적파일들은 심볼들을 정의하고 참조하며 여기서 각 심볼은 함수, 전역변수 또는 정적변수(즉, C언어에서 static으로 선언된 모든 변수들)에 대응된다</li>
</ol>

<ul>
  <li>심볼 해석의 <strong>목적</strong>은 <strong>각각의 심볼 참조를 정확하게 하나의 심볼 정의에 연결</strong>하는 것임</li>
</ul>

<ol>
  <li><strong>재배치(relocation)</strong> : 컴파일러와 어셈블러는 주소 0번지에서 시작하는 코드와 데이터 섹션들을 생성. 링커는 <strong>이 섹션들을 각 심볼 정의와 연결시켜서 재배치 하며, 이 심볼들로 가는 모든 참조들을 수정해서 이들이 이 메모리 위치를 가리키도록 한다</strong></li>
</ol>

<h2 id="목적파일">목적파일</h2>

<p>목적파일에는 세 가지 형태가 있어</p>

<ul>
  <li>
    <p>재배치 가능 목적파일(Relocatable object file) : 포맷에 컴파일 할 때 <strong>실행 가능 목적파일을 생성하기 위해 다른 재구성가능 목적파일들과 결합될 수 있는 바이너리 코드와 데이터를 포함</strong>한다</p>

    <ul>
      <li>.o 로 끝나는 파일들이 그 예이다</li>
    </ul>
  </li>
  <li>
    <p>실행 가능 목적파일(Executable object file) : 메모리에 직접 복사될 수 있고 <strong>실행될 수 있는 형태</strong>로 바이너리 코드와 데이터를 포함</p>
  </li>
  <li>
    <p>공유 목적파일(Shared object file) : 로드타임(Load time) 또는 런타임(Runtime)시에 동적으로 링크되고 메모리에 로드될 수 있는 특수한 유형의 <strong>재배치 가능 목적파일</strong>이다</p>
  </li>
</ul>

<p><strong>컴파일러와 어셈블러</strong>는 재배치 가능 목적파일을 생성하고 <strong>링커</strong>는 실행 가능한 목적파일을 생성함</p>

<h2 id="재배치-가능-목적파일with-elf--executable-and-linkable-format">재배치 가능 목적파일(with ELF : Executable and Linkable Format)</h2>

<ul>
  <li><strong>ELF</strong> : 리눅스 같은 유닉스 시스템에서 실행 파일이나 오브젝트 파일을 위한 <strong>표준 포맷</strong>이다(예 : .o 파일이나 a.out 파일)</li>
</ul>

<p>아래의 표는 ELF 재배치 가능 목적파일의 포맷을 보여준다</p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">┌</th>
      <th style="text-align: center">ELF header</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">s</td>
      <td style="text-align: center">.text</td>
    </tr>
    <tr>
      <td style="text-align: center">e</td>
      <td style="text-align: center">.rodata</td>
    </tr>
    <tr>
      <td style="text-align: center">c</td>
      <td style="text-align: center">.data</td>
    </tr>
    <tr>
      <td style="text-align: center">t</td>
      <td style="text-align: center">.bss</td>
    </tr>
    <tr>
      <td style="text-align: center">i</td>
      <td style="text-align: center">.symtab</td>
    </tr>
    <tr>
      <td style="text-align: center">o</td>
      <td style="text-align: center">.rel.text</td>
    </tr>
    <tr>
      <td style="text-align: center">n</td>
      <td style="text-align: center">.rel.data</td>
    </tr>
    <tr>
      <td style="text-align: center">s</td>
      <td style="text-align: center">.debug</td>
    </tr>
    <tr>
      <td style="text-align: center">└</td>
      <td style="text-align: center">.line</td>
    </tr>
    <tr>
      <td style="text-align: center">Describes object file sections</td>
      <td style="text-align: center">Section header table</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>ELF header : ELF 파일의 <strong>맨 처음에 위치한 아주 중요한 정보 블록</strong>으로써, “이 파일은 ELF 파일입니다”를 알려주고 “이 파일은 ELF 파일입니다” 문구는 운영체제나 링커가 확인. 이 파일을 생성한 워드 크기와 시스템의 바이트 순서를 나타내는 16바이트 배열로 시작함</p>

    <ul>
      <li>
        <p>나머지는 링커가 목적파일을 구문분석하고 해석하도록 하는 정보를 포함하고 있음</p>
      </li>
      <li>
        <p>여기에는 ELF header의 크기, 목적파일 타입(예: 재배치 가능, 실행 가능, 공유), 머신 타임(예: x86-64), section header table의 파일 오프셋, section header table의 크기와 엔트리 수가 들어 있다.</p>
      </li>
      <li>
        <p>여러 가지 섹션들의 위치와 크기는 section header table로 나타내며, 이 테이블은 목적파일의 각 섹션에 대해 고정된 크기의 엔트리를 가짐</p>
      </li>
    </ul>
  </li>
  <li>
    <p>.text : 컴파일된 프로그램의 머신 코드</p>
  </li>
  <li>
    <p>.rodata printf : 문장의 포맷 스트링, switch 문의 점프 테이블과 같은 읽기-허용 데이터</p>
  </li>
  <li>
    <p>.data : <strong>초기화된 C 전역변수 및 전역변수</strong>이며, 실제로 파일 안에 값이 저장됨<strong>(Disk 공간 차지)</strong></p>

    <ul>
      <li>
        <p>int a = 10; → Binary 파일에 기록됨 → a의 초기값 10이 포함된 형태로 .data 섹션에 저장</p>
      </li>
      <li>
        <p>만약 아래처럼 a가 지역 변수라면? 지역 변수는 스택에 들어가기 때문에, .data에 들어가지 않아</p>
        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">func</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// 지역 변수 👉 스택에 들어감 ❗</span>
<span class="p">}</span>
</code></pre></div>        </div>
      </li>
    </ul>
  </li>
  <li>
    <p>.bss : <strong>초기화되지 않은 C 전역변수와 정적변수 그리고 0으로 초기화된 전역변수 및 정적변수</strong>이며, 실제 공간을 차지하지 않고 단순히 위치를 표시해(Disk 공간 차지하지 않음)</p>

    <ul>
      <li>
        <p>int b; 또는 static int c; → 초기화되지 않은 전역/정적 변수로 .bss 공간에 해당</p>

        <ul>
          <li>b의 값 또는 c의 값이 쓰래기 값이면 어떻게 될까? 운영체제가 프로그램을 메모리에 올릴 때, .bss 영역에 있는 변수들은 자동으로 0으로 채움!</li>
        </ul>
      </li>
      <li>
        <p>int y = 0; → 0으로 초기화된 전역/정적 변수로 .bss 공간에 해당</p>
      </li>
    </ul>
  </li>
  <li>
    <p>rel.text : 링커가 이 목적파일을 다른 파일들과 연결할 때 수정되어야 하는 .text 섹션 내 위치들의 리스트</p>

    <ul>
      <li>일반적으로 외부 함수를 호출하거나 전역변수를 참조하는 인스트럭션들은 모두 수정 되어야 하고 이 수정을 위해서 위치들의 정보를 갖고 있는게 아닐까 싶다</li>
    </ul>
  </li>
  <li>
    <p>rel.data : 해당 모듈에 의해 정의되거나 참조되는 전역변수들에 대한 재배치 정보</p>

    <ul>
      <li>일반적으로 초기값이 전역변수 또는 외부에 정의된 함수의 주소인 초기화된 전역변수들 모두 수정되어야 한다</li>
    </ul>
  </li>
  <li>
    <p>.debug : 프로그램 내에서 정의도니 지역변수들과 typedef, 프로그램과 최초 C 소스 파일에서 정의되고 참조되는 전역변수들을 위한 엔트리를 갖는 <strong>디버깅 심볼 테이블</strong></p>

    <ul>
      <li>컴파일러 드라이버가 -g 옵션으로 불린 경우에 생성됨</li>
    </ul>
  </li>
  <li>
    <p>.line : 최초 C 소스 프로그램과 .text 섹션 내 머신 코드 인스트럭션 내 라인 번호들간의 매핑</p>

    <ul>
      <li>컴파일러 드라이버가 -g 옵션으로 불린 경우에 생성됨</li>
    </ul>
  </li>
  <li>
    <p>.strtab : .strtab과 .debug 섹션들 내에 있는 심볼 테이블과 섹션 헤더들에 있는 섹션 이름들을 위한 스트링 테이블. 스트링 테이블은 널 문자로 종료된 스트링의 배열</p>
  </li>
</ul>

<h2 id="실행-가능-목적파일의-로딩">실행 가능 목적파일의 로딩</h2>

<p>우리가 실행 가능 목적파일을 실행하기 위해 아래와 같은 명령어를 타입해</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>linux&gt; ./prog
</code></pre></div></div>

<p>그러면 이 실행 가능 목적파일이 어떻게 로딩될까?</p>

<ul>
  <li>
    <p><strong>prog</strong>는 내장 Shell 명령어가 아니야. 그래서 Shell은 prog가 실행 가능한 목적파일이라고 생각하고 Loader 라는 메모리 상주 운영체제 코드를 호출해. 호출해서 이 프로그램을 실행해</p>

    <ul>
      <li>
        <p>리눅스 프로그램은 <strong>execve</strong> 함수를 호출해서 Loader를 호출할 수 있어</p>
      </li>
      <li>
        <p>Loader는 Disk로부터 실행 가능한 목적파일 내의 코드와 데이터를 메모리로 복사하고 이 프로그램의 첫 번째 Instruction, 즉 Entry point로 Jump해서 프로그램을 실행해</p>
      </li>
      <li>
        <p><strong>위와 같이 프로그램을 메모리로 복사하고 실행하는 과정을 Loading</strong>이라함</p>
      </li>
    </ul>
  </li>
</ul>

<p>모든 실행 중인 리눅스 프로그램은 아래 사진과 같은 런타임 메모리 이미지를 가진다</p>

<p><img src="/assets/img/blog/computerscience/LinuxRuntimeMemory.png" alt="런타임 메모리 이미지" /></p>

<ul>
  <li>
    <p>리눅스 시스템에서 code segment는 주소 0x400000에서 시작</p>
  </li>
  <li>
    <p>뒤이어 data segment(Read/write segment)가 옴</p>

    <ul>
      <li>실제로는 code와 data segment 사이에 공간이 존재함</li>
    </ul>
  </li>
  <li>
    <p>Run-time heap은 data segment 다음에 따라오고 malloc 라이브러리를 호출해서 위로 성장</p>
  </li>
  <li>
    <p>이 다음에는 공유 모듈(shared libraries)들을 위해 예약된 영역이 존재</p>
  </li>
  <li>
    <p>사용자 스택은 가장 큰 합법적 사용자 주소(2^48-1) 아래에서 시작해서 더 작은 메모리 주소 방향인 아래로 성장</p>
  </li>
  <li>
    <p>스택 위의 영역은 운영체제의 메모리 상주 부분인 커널의 코드와 데이터를 위해 예약</p>
  </li>
</ul>

<h3 id="로더-실행">로더 실행</h3>

<p>로더가 실행되면 아래와 같은 workflow를 가진다</p>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">                               </span><span class="err">┌</span><span class="w"> </span><span class="err">가상</span><span class="w"> </span><span class="err">메모리┐</span><span class="w">    </span><span class="err">로더가</span><span class="w"> </span><span class="err">프로그램의</span><span class="w"> </span><span class="nv">Entry</span><span class="w"> </span><span class="nv">point</span><span class="err">로</span><span class="w"> </span><span class="nv">jump</span><span class="w">     </span><span class="o">_</span><span class="nv">start</span><span class="w"> </span><span class="err">함수가</span><span class="w"> </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="err">호출</span><span class="w">     </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="o">:</span><span class="w">
</span><span class="err">로더</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="err">파일</span><span class="w"> </span><span class="err">덩어리</span><span class="w"> </span><span class="o">-&gt;</span><span class="err">│</span><span class="nv">data</span><span class="w"> </span><span class="nv">segment</span><span class="err">│</span><span class="w"> </span><span class="o">-&gt;</span><span class="w">  </span><span class="err">┌────────────</span><span class="nv">crt1</span><span class="o">.</span><span class="nv">o</span><span class="err">────────────┐</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">  </span><span class="err">┌────────────</span><span class="nv">libc</span><span class="o">.</span><span class="nv">so</span><span class="err">────────────┐</span><span class="w">  </span><span class="o">-&gt;</span><span class="w">            </span><span class="o">-</span><span class="w"> </span><span class="err">실행</span><span class="w"> </span><span class="err">환경</span><span class="w"> </span><span class="err">초기화</span><span class="w">
                           </span><span class="err">복사│</span><span class="nv">code</span><span class="w"> </span><span class="nv">segment</span><span class="err">│</span><span class="w">    </span><span class="err">│</span><span class="w">        </span><span class="o">_</span><span class="nv">start</span><span class="w"> </span><span class="err">함수</span><span class="w"> </span><span class="err">실행</span><span class="w">        </span><span class="err">│</span><span class="w">     </span><span class="err">│</span><span class="w">   </span><span class="o">__</span><span class="nv">libc</span><span class="o">_</span><span class="nv">start</span><span class="o">_</span><span class="nv">main</span><span class="w"> </span><span class="err">함수</span><span class="w"> </span><span class="err">실행</span><span class="w">  </span><span class="err">│</span><span class="w">                </span><span class="o">-</span><span class="w"> </span><span class="err">사용자</span><span class="w"> </span><span class="err">수준의</span><span class="w"> </span><span class="nv">main</span><span class="w"> </span><span class="err">함수호출</span><span class="w">
                               </span><span class="err">└───────────┘</span><span class="w">     </span><span class="err">└──────────────────────────────┘</span><span class="w">       </span><span class="err">└──────────────────────────────┘</span><span class="w">                 </span><span class="o">-</span><span class="w"> </span><span class="nv">return</span><span class="err">값</span><span class="w"> </span><span class="err">처리</span><span class="w">
                                                                                                                                         </span><span class="o">-</span><span class="w"> </span><span class="err">필요한</span><span class="w"> </span><span class="err">경우</span><span class="w"> </span><span class="err">제어권을</span><span class="w"> </span><span class="err">커널로</span><span class="w"> </span><span class="err">넘겨줌</span><span class="w">
</span></code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="computersystem" /><summary type="html"><![CDATA[링킹(linking)은 여러 개의 코드와 데이터를 모아서 연결하여 메모리에 로드될 수 있고 실행될 수 있는 한 개의 파일로 만드는 작업이다.]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/ComputerSystem.png" /><media:content medium="image" url="/assets/img/blog/postimage/ComputerSystem.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">전위 순회(Pre-Order Traversal)와 후위 순회(Post-Order Traversal)의 연관성</title><link href="/blog/algorithm/pre-order-post-order/" rel="alternate" type="text/html" title="전위 순회(Pre-Order Traversal)와 후위 순회(Post-Order Traversal)의 연관성" /><published>2025-04-16T00:00:00+00:00</published><updated>2025-04-16T00:00:00+00:00</updated><id>/blog/algorithm/pre-order-post-order</id><content type="html" xml:base="/blog/algorithm/pre-order-post-order/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#전위-순회와-후위-순회의-구조적인-연관성" id="markdown-toc-전위-순회와-후위-순회의-구조적인-연관성">전위 순회와 후위 순회의 구조적인 연관성</a>    <ul>
      <li><a href="#표준-전위-순회-vs-변형-전위-순회" id="markdown-toc-표준-전위-순회-vs-변형-전위-순회">표준 전위 순회 vs 변형 전위 순회</a></li>
      <li><a href="#변형-전위-순회를-뒤집으면" id="markdown-toc-변형-전위-순회를-뒤집으면">변형 전위 순회를 뒤집으면?</a></li>
      <li><a href="#표준-전위-순회--변형-전위-순회--후위-순회-예제" id="markdown-toc-표준-전위-순회--변형-전위-순회--후위-순회-예제">표준 전위 순회 / 변형 전위 순회 / 후위 순회 예제</a></li>
      <li><a href="#c언어-예제" id="markdown-toc-c언어-예제">C언어 예제</a></li>
    </ul>
  </li>
</ul>

<p>C언어를 통해 재귀 없이 Stack 2개를 활용하여 후위순회를 진행하는 코드를 보고 전위순회와 후위순회의 구조적 연관성이 있겠다는 생각이 들었다. 왜냐하면, 1개의 스택은 전위순회의 구조를 바꾼 형태였고 나머지 스택 하나는 그 한개의 스택을 역순으로 출력하기 위해 존재 했었기 때문이다.</p>

<h2 id="전위-순회와-후위-순회의-구조적인-연관성">전위 순회와 후위 순회의 구조적인 연관성</h2>

<p>먼저 결론부터 얘기하자면, <strong>전위 순회의 구조를 살짝 바꾸고 나온 결과를 뒤집으면 후위 순회 순서와 같아짐</strong></p>

<h3 id="표준-전위-순회-vs-변형-전위-순회">표준 전위 순회 vs 변형 전위 순회</h3>

<ul>
  <li>
    <p>표준 전위 순회 : (Root) → (Left) → (Right)</p>
  </li>
  <li>
    <p>변형 전위 순회 : (Root) → (Right) → (Left)</p>
  </li>
</ul>

<h3 id="변형-전위-순회를-뒤집으면">변형 전위 순회를 뒤집으면?</h3>

<ul>
  <li>
    <p><strong>뒤집은</strong> 변형 전위 순회 : (Left) → (Right) → (Root)</p>
  </li>
  <li>
    <p>표준 후위 순회 : (Left) → (Right) → (Root)</p>
  </li>
</ul>

<h3 id="표준-전위-순회--변형-전위-순회--후위-순회-예제">표준 전위 순회 / 변형 전위 순회 / 후위 순회 예제</h3>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="w">        </span><span class="nv">A</span><span class="w">
       </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">
      </span><span class="nv">B</span><span class="w">   </span><span class="nb">C</span><span class="w">
     </span><span class="o">/</span><span class="w"> </span><span class="err">\</span><span class="w">   </span><span class="err">\</span><span class="w">
    </span><span class="nb">D</span><span class="w">   </span><span class="nb">E</span><span class="w">   </span><span class="nv">F</span><span class="w">
</span></code></pre></div></div>

<ul>
  <li>표준 전위 순회 (Root → Left → Right)
    <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">A</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">D</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">E</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">C</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">F</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>변형 전위 순회 (Root → Right → Left)
    <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">A</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">C</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">F</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">E</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">D</span><span class="w">
</span></code></pre></div>    </div>
  </li>
  <li>후위 순회 (Left → Right → Root)
    <div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">D</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">E</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">B</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">F</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nb">C</span><span class="w"> </span><span class="err">→</span><span class="w"> </span><span class="nv">A</span><span class="w">
</span></code></pre></div>    </div>
  </li>
</ul>

<h3 id="c언어-예제">C언어 예제</h3>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">postOrderIterativeS2</span><span class="p">(</span><span class="n">BSTNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">Stack</span> <span class="o">*</span><span class="n">stk1</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Stack</span><span class="p">));</span>
	<span class="n">Stack</span> <span class="o">*</span><span class="n">stk2</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Stack</span><span class="p">));</span>
	<span class="n">stk1</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">stk2</span><span class="o">-&gt;</span><span class="n">top</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">push</span><span class="p">(</span><span class="n">stk1</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">stk1</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">BSTNode</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">stk1</span><span class="p">);</span>
		<span class="n">push</span><span class="p">(</span><span class="n">stk2</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span>
			<span class="n">push</span><span class="p">(</span><span class="n">stk1</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">)</span>
			<span class="n">push</span><span class="p">(</span><span class="n">stk1</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">isEmpty</span><span class="p">(</span><span class="n">stk2</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">BSTNode</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">pop</span><span class="p">(</span><span class="n">stk2</span><span class="p">);</span>
		<span class="n">printf</span><span class="p">(</span><span class="s">"%d, "</span><span class="p">,</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">free</span><span class="p">(</span><span class="n">stk1</span><span class="p">);</span>
	<span class="n">free</span><span class="p">(</span><span class="n">stk2</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="algorithm" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/Algorithm.png" /><media:content medium="image" url="/assets/img/blog/postimage/Algorithm.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">크래프톤 정글에서 첫달을 보낸 후</title><link href="/blog/diary/first_month/" rel="alternate" type="text/html" title="크래프톤 정글에서 첫달을 보낸 후" /><published>2025-04-14T00:00:00+00:00</published><updated>2025-04-14T00:00:00+00:00</updated><id>/blog/diary/first_month</id><content type="html" xml:base="/blog/diary/first_month/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#0주차" id="markdown-toc-0주차">0주차</a>    <ul>
      <li><a href="#해요일" id="markdown-toc-해요일">해요일</a></li>
    </ul>
  </li>
  <li><a href="#1주차" id="markdown-toc-1주차">1주차</a></li>
  <li><a href="#2주차" id="markdown-toc-2주차">2주차</a></li>
  <li><a href="#3주차" id="markdown-toc-3주차">3주차</a></li>
  <li><a href="#4주차" id="markdown-toc-4주차">4주차</a></li>
</ul>

<p>벌써 1달이라는 시간이 지났다. 아무래도 블로그 운영이 취업 목적과도 연관이 있어서 꾸준히 배운것에 대해 포스팅은 진행했지만, 배운것 외에 내가 느낀점에 대해서는 포스팅하지 않았고 필요도 느끼지 못했다. 그런데, 결국에 배운것은 모두 GPT가 알려준 것이어서 블로그 포스팅이 의미없지 않냐는 다른 정글러분의 의견에 생각이 바뀌어서 정글 5개월 동안 1개월마다 회고록을 써보고자 한다. 먼저 시간대별로 느꼈던점을 기술하는것이 정리가 잘 될거 같아서 시간대별로 내가 느낀점을 적도록 하겠다.</p>

<h2 id="0주차">0주차</h2>

<p>처음 들어왔을때, 설렘 반 긴장 반의 감정으로 들어왔던것 같다. 나에게는 너무 큰 도전이었기에, 첫날에 나온 식사는 잘 넘어가지 않았다.</p>

<p>처음에 내주었던 과제는 웹 서비스 개발 프로젝트였고, 기획부터 해서 배포까지 하는것이 과제였다. 어떤 웹서비스를 구현할지 고민했고, 크래프톤 정글 프로그램상 일요일날에는 식사가 제공되지 않아서 이때 나가서 밥 같이 먹을 사람, 아님 취미를 같이 해볼 수 있도록 도와주는 웹 서비스를 구현하기로 팀원끼리 합의했다.</p>

<h3 id="해요일">해요일</h3>

<p><strong>일요일날은 해日와 관련이 있고, 또 뭔가를 하자는 의미에서 해요일</strong>이라고 우리의 웹 서비스를 구현하고자 했다. 해당 프로젝트는 이 블로그 Projects에 있으니 참고 가능하다.</p>

<p>팀원이 3명으로 이루어졌고 나 빼고 2명은 전공자셨기 때문에, 내가 과연 도움이 될까 싶었다. 아무래도 그분들보다 Python이든, html을 다뤄보지 않았기 때문이다. 어쨋든 시간은 3일 밖에 주어지지 않았고 도움이 되어야만 했다.</p>

<p>웹 서비스 구현할때, Tailwind CSS, JWT, Jinja 를 포함시켜서 구현을 해야 했다. 우리가 원해서는 아니었고 과제 세부사항으로써 의무였다. Jinja 같은 경우 어려워서 먼저 javascript에 ajax 사용해서 만든 코드를 GPT한테 Jinja 코드로 변환시켜 달라고 해서 구현을 했고, Tailwind CSS는 웹페이지에 있는것 따라하면서 구현을 했다.</p>

<p>현준이라는 정글러님이 디자인 감각이 좋으셔서 내가 만들었던 페이지를 개선시켜주셨다. 덕분에 프로젝트의 미적 부분이 많아 좋아졌다. 또한 성현 정글러님이 백엔드(Python)쪽을 빠르게 구현해 주셔서 페이지 하나하나 연결시키는게 빨랐고 덕분에 우리가 구현하고자 했던 웹 서비스를 모두 구현 시킬 수 있었다. 나는 front-end를 맡았고 Main page, My page, 구현과 회원가입때 e-mail OTP 구현같은 경우 front와 back 모두 맡았다.</p>

<p>최종적으로 시연까지 발표하니까 성취감을 느꼈고 동료애를 많이 느꼈다. 그러면서도 걱정이 들었던 것은 이 정도 강도를 5개월동안 유지못할 것 같다는 것이었다. 어쨌든 미래의 걱정은 제쳐두고 최종 발표 저녁때 삼겹살 파티를 쥐최해주셔서 맛있게 먹고 빨리 쉬러 들어갔다.</p>

<h2 id="1주차">1주차</h2>

<p>0주차가 끝나고 다시 새로운 팀원 배정이 이루어 지게 되었다. 1주차가 시작되면서 발제가 이루어졌고 발제때의 내용을 들어보니 다행히도 강도가 많이 내려갔다. 그런데, 이미 0주차때 많이 쏟아 부어서인지 0주차에 버금가는 집중력을 유지하게 되는 주였다. 아마 이 집중력은 이 글을 쓰는 5주차에도 계속 유지가 되었단 것을 알려주고 싶다.</p>

<p>1주차에는 Python 기초부터 다지기 시작했고 Baekjoon 문제를 풀어보는 주가 되었다. 하 난이도부터 중,상 난이도로 나누어서 모든 문제를 풀라는 과제를 내주셨고 이때 많은 문제를 풀어보면서 Python 언어와 많이 친숙해 질 수 있었다. 백준 문제들 중 입출력/조건문/반복문/배열/함수/문자열/수학/재귀함수/정렬/완전 탐색의 종류인 문제를 풀었다.</p>

<p>Python 외적으로는 <strong>Computer Systems A Programmer’s Perspective</strong> 책 1장을 읽었고 hello.c가 응용 목적 프로그램까지 어떻게 저장(컴파일)되는지 각 단계별로 간단하게 알게 되는 한주였다.</p>

<p>또한 시간 복잡도와 공간 복잡도에 대해서 배웠고 이걸 BigO로 어떻게 표현되는지에 대해서도 배웠다. 정렬 알고리즘에 대해서 많이 배우게 되는 한주였는데, 버블/단순 선택/단순 삽입/이진 삽입/셸/퀵/병합/힙 정렬에 대해서 배웠다.</p>

<p>첫주여서 그런지 조금 만만하게 생각했던 점이 있다. 하지만 목요일날에 봤던 시험을 만족스럽게 보지 못해서 반성하는 계기가 되었다.</p>

<h2 id="2주차">2주차</h2>

<p>첫주차에서 반성하는 계기를 통해서 2주차때는 조금 더 열심히 해보고자 하였다. 먼저 팀원들과의 코어타임을 조금 더 도움되게 바꾸기 위해 첫주차에서 어떻게 진행했는지 물어보았고 좋은 것들을 채택해 진행하기로 했다. 덕분에 매 코어타임이 모두에게 도움되는 시간이었고 이후부터 어떻게 공부할지, 그리고 어떻게 함께 지식을 공유해야 할지 배우게 되었다.</p>

<p>2주차에서 알고리즘 같은 경우 이분 탐색/분할 정복/스택/큐/우선순위 큐에 대해 배우게 되었는데, 지금 생각해보면 이때 열심히 공부했던 것이 빛을 발하게 된것 같다. 현재 C 언어에서 스택과 큐를 사용해 함수 구현하고 있는데, 2주차때 배웠던 내용들이 알고리즘의 중추였다고 느낀다. 여러 알고리즘이 있지만, 특히 스택과 큐, 그리고 우선순위 큐가 지금으로써 도움이 많이 된다.</p>

<p>Computer System 같은 경우 캐시 / 가상 메모리의 계층 / 운영체제의 대략적인 역할을 배우게 되었다. 스택 같은 경우 위에서 아래로, 큐 같은 경우 아래에서 위로 저장이 된다고 배웠고 이게 서로 만난다면 충돌이 날 수도 있으니 주의하라고 한점도 기억이 난다.</p>

<h2 id="3주차">3주차</h2>

<p>2주차에서 나름 공부를 잘했다고 느꼈고 이 느낀점 때문에 3주차에서는 조금 더 열심히 해볼 계기가 되었다. 첫날부터 리뷰할 시간 없이 코어타임을 저녁때 가지기로 했고, 이때 Computer System을 다루기로 했다. 짧은 시간이었지만, 집중력을 통해 <strong>인스트럭션들의 병렬성</strong>과 <strong>쓰레드의 동시성</strong>에 대해 설명할 수 있었고 이때 한 조원의 호기심으로 인해 Computer System 관하여 오래 논의를 나누었다.</p>

<p>그리고 알고리즘 관하여서는 처음으로 그래프(vetex, edge, node, arc)에 대해서 배우고 BFS, DFS, 위상정렬, 최단거리, 사이클 탐지, 최소 신장 트리, 자기 균형 이진 탐색 트리까지 많은 알고리즘을 할당 받아서 3주차도 집중을 놓치지 않고 모두 공부하였고, 물론 쉽진 않았다. 다행히도 다 할 수 있었단 것에 내 자신에게 고맙게 느끼는 한 주였다. 그리고 3주차에서는 다루는 내용도 많았지만, 중간 중간 팀원들이 새로운 지식을 알려줘서 더 발전하게 되는 한 주였다. 팀원들한테 고마움을 느낀다.</p>

<h2 id="4주차">4주차</h2>

<p>Python을 통해 알고리즘을 배우는 마지막 주 4주차에서는 많은 것을 얻어간것 같다. 알고리즘을 많이 배우진 않았지만, Computer System쪽에서 지식을 많이 얻게 되는 한 주였다. <strong>Computer Systems A Programmer’s Perspective</strong> 책 3장 전체를 다 보라는 과제가 있었고 아쉽게도 다 보진 못했지만, 레지스터에서 어떻게 인수를 저장하고 또 메모리에서 값을 받아오는 행위의 세부적인걸 알게 되었다.</p>

<p>알고리즘으로는 동적 프로그래밍과 그리디 알고리즘을 배웠다. 이상한게 2차원 배열의 움직임을 구현하는 것은 나에게 굉장히 어려웠는데, 시간이 해결을 해준건지 시험에서 나온 DP문제를 2차원 배열과 DPS 방식으로 풀게 되었다. 물론 백준 시간 초과가 나오게 되면서 문제를 풀었다고 할 수 없긴 했지만, 그래도 꾸준히 공부를 해왔던 것에 보람을 느끼게 되었다. 앞으로 난관을 마주하게 되더라도 이런 경험에서 나왔듯이 시간이 해결해줄 것이라고 믿고 앞으로 나아갈것 같다.</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="diary" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4%EC%A0%95%EA%B8%80.jpg" /><media:content medium="image" url="/assets/img/blog/postimage/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4%EC%A0%95%EA%B8%80.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">크래프톤 정글에서 두번째 달을 보낸 후</title><link href="/blog/diary/second-month/" rel="alternate" type="text/html" title="크래프톤 정글에서 두번째 달을 보낸 후" /><published>2025-04-14T00:00:00+00:00</published><updated>2025-04-14T00:00:00+00:00</updated><id>/blog/diary/second-month</id><content type="html" xml:base="/blog/diary/second-month/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#5주차" id="markdown-toc-5주차">5주차</a></li>
  <li><a href="#6주차" id="markdown-toc-6주차">6주차</a></li>
</ul>

<p>벌써 1달이라는 시간이 지났다. 아무래도 블로그 운영이 취업 목적과도 연관이 있어서 꾸준히 배운것에 대해 포스팅은 진행했지만, 배운것 외에 내가 느낀점에 대해서는 포스팅하지 않았고 필요도 느끼지 못했다. 그런데, 결국에 배운것은 모두 GPT가 알려준 것이어서 블로그 포스팅이 의미없지 않냐는 다른 정글러분의 의견에 생각이 바뀌어서 정글 5개월 동안 1개월마다 회고록을 써보고자 한다. 먼저 시간대별로 느꼈던점을 기술하는것이 정리가 잘 될거 같아서 시간대별로 내가 느낀점을 적도록 하겠다.</p>

<h2 id="5주차">5주차</h2>

<p>파이썬으로 알고리즘을 배우는 첫 달이 끝나고, 이제는 C언어로 컴퓨터에게 깊이 빠져드는 첫 주가 되었다. 과제로 주어진 것은 Linked List/Stack and Queue/Binary Tree/Binary Search Tree 알고리즘 기반으로 문제를 푸는 것이었다.</p>

<p>C언어를 잘 몰랐기에, 먼저 Youtube의 6시간짜리 C 언어 기초 동영상으로 시작을 했다. 졸려가는걸 버티면서 3~4시간쯤 보았을 때, 다른 정들러분들이 문제를 시작한걸 보고 남들보다 진도가 조금 뒤쳐진다는걸 깨달았다. 그래서 우선 기초는 여기까지 마무리하고 문제로 넘어갔다.</p>

<p>문제로 넘어간 뒤에 2시간 동안 코드해석 하는 데에만 쏟았는데, 이 2시간이 의미가 있었다. 언어 해석하는데에 수월해지는 시간이었고 문제를 바로 풀 수 있었다. 5주차를 마무리 하면서 쓰는 결론으로는 Binary Tree 빼고 모든 문제는 다 풀 수 있었다. 당연히 문제를 본인 스스로 다 풀지는 못하였지만, 내 스스로 50%정도는 스스로 풀 수 있었다.</p>

<p>팀원분들과 첫 Core-time을 가졌을때, 많은 것을 얻을 수 있었다. 두분 모두 열심히 준비를 해주셔서 한 주를 잘 시작할 수 있었다. 다만, 아쉽게도 불가피한 사정으로 인해서 두 분 모두 시간을 온전히 투자할 수 있는 상황이 아니었어서 중간에 흐지부지 했었던점이 조금 아쉬웠다. 그럼에도 불구하고 5주차 때 열심히 했어서 많이 도움이 되었다.</p>

<h2 id="6주차">6주차</h2>

<p>6주차에서는 C언어로 Red-Black Tree를 구현하는 과제가 주어졌다. 여태까지 미리 미리 보아두라고 했었지만, 그러지 않았기 때문에, 나에게는 불똥이 떨어진 셈이다. 그나마 다행이었던 것은 모두 Red-Black Tree에 대해서 많이 알지 못했던 것이다. 그래서 같이 시작하면 됐다.</p>

<p>불똥이 떨어졌기 때문에, 트리에 대한 이해를 빠르게 해야만 했다. 첫날에 Red-Black Tree에 대해서 개념을 먼저 다지자고 팀원들과 얘기했고, 빠르게 공부를 시작했다. 아쉽게도 첫날에는 삽입에 대해서만 개념을 다루었고 그 다음날에 삭제까지 개념을 다지면서 마무리가 되었다.</p>

<p>개념을 다지고 이제 C언어로 구현을 해야 하는데, 막막한 느낌이 없지 않아 있었고 알고리즘(Introduction to ALGORITHMS)책을 통해 시작할 수 있게 되었다. 해당 책을 통해 많은 도움을 받았고 직접 구현하기 보다는 이미 짜여진 코드를 이해하는게 더 중요하다고 생각이 되었다. 그 이유에 대해서는, 처음으로 트리를 구현하는 것이었기 때문에, 처음부터 RBTree를 구현하는 것은 많은 시간을 쓸거라고 생각했고, 다른 과제들 또한 있었기 때문에 타협을 본 셈이다.</p>

<p>C언어로 RBTree 구현을 모두 마치고 CS:APP 책 8장과 9장을 읽어야 했다. 결론적으로 다 읽지는 못하였지만, 8장에서 예외처리를 위한 시그널과 9장에서 가상 메모리를 쓰는 이유에 대해 배울 수 있게 되었다. 팀원들과 가졌던 Core-time에서 내가 알고 있던 내용과 팀원들이 알고있던 내용에 다른점이 존재했다. 내가 알고 있던 내용이 맞았고 정정을 해주었던 점이 기억에 남는다. 앞으로도 깊게 파고드는 습관을 유지하면서 공부하고자 하는 계기를 만들었다. 그럼에도 불구하고, 과제를 모두 마치지 못한 첫 주가 되었고 많이 아쉬웠다. 완수를 못한점에 대해 만회하고자 차주부터 열심히 하고자 한다.</p>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="diary" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4%EC%A0%95%EA%B8%80.jpg" /><media:content medium="image" url="/assets/img/blog/postimage/%ED%81%AC%EB%9E%98%ED%94%84%ED%86%A4%EC%A0%95%EA%B8%80.jpg" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">gcc(GNU Compiler Collection)</title><link href="/blog/c/gcc/" rel="alternate" type="text/html" title="gcc(GNU Compiler Collection)" /><published>2025-04-13T00:00:00+00:00</published><updated>2025-04-13T00:00:00+00:00</updated><id>/blog/c/gcc</id><content type="html" xml:base="/blog/c/gcc/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#gcc란" id="markdown-toc-gcc란">gcc란?</a></li>
  <li><a href="#gcc의-기본-사용법" id="markdown-toc-gcc의-기본-사용법">gcc의 기본 사용법</a>    <ul>
      <li><a href="#가장-기본적인-사용" id="markdown-toc-가장-기본적인-사용">가장 기본적인 사용</a></li>
      <li><a href="#실행" id="markdown-toc-실행">실행</a></li>
    </ul>
  </li>
  <li><a href="#컴파일-단계의-gcc-내부-동작" id="markdown-toc-컴파일-단계의-gcc-내부-동작">컴파일 단계의 gcc 내부 동작</a></li>
  <li><a href="#자주-쓰는-옵션들" id="markdown-toc-자주-쓰는-옵션들">자주 쓰는 옵션들</a></li>
  <li><a href="#기타-유용한-gcc-관련-도구들" id="markdown-toc-기타-유용한-gcc-관련-도구들">기타 유용한 gcc 관련 도구들</a>    <ul>
      <li><a href="#makefile이란" id="markdown-toc-makefile이란">Makefile이란?</a>        <ul>
          <li><a href="#구조예제" id="markdown-toc-구조예제">구조(예제)</a></li>
          <li><a href="#사용-방법" id="markdown-toc-사용-방법">사용 방법</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#docker에서-c-파일을-컴파일하고-실행하기" id="markdown-toc-docker에서-c-파일을-컴파일하고-실행하기">Docker에서 C 파일을 컴파일하고 실행하기</a>    <ul>
      <li><a href="#구조간단-예제" id="markdown-toc-구조간단-예제">구조(간단 예제)</a></li>
      <li><a href="#실행간단-예제" id="markdown-toc-실행간단-예제">실행(간단 예제)</a></li>
      <li><a href="#구조복잡한-예제-makefile-추가-사용" id="markdown-toc-구조복잡한-예제-makefile-추가-사용">구조(복잡한 예제, Makefile 추가 사용)</a></li>
      <li><a href="#실행복잡한-예제-makefile-추가-사용" id="markdown-toc-실행복잡한-예제-makefile-추가-사용">실행(복잡한 예제, Makefile 추가 사용)</a></li>
    </ul>
  </li>
  <li><a href="#자주-쓰는-dockerfile-팁" id="markdown-toc-자주-쓰는-dockerfile-팁">자주 쓰는 Dockerfile 팁</a></li>
  <li><a href="#정리" id="markdown-toc-정리">정리</a></li>
</ul>

<h2 id="gcc란">gcc란?</h2>

<p>gcc는 GNU Compiler Collection의 약자로, 원래는 C 언어 <strong>컴파일러(GNU C Compiler)</strong>로 시작했지만 지금은 C, C++, Objective-C, Fortran, Ada, Go 등 다양한 언어를 지원하는 컴파일러 모음이야</p>

<ul>
  <li>
    <p>C 언어 컴파일러로 가장 유명하고, 리눅스에서 표준처럼 사용돼</p>
  </li>
  <li>
    <p>윈도우에서도 MinGW, WSL, 또는 MSYS2 등을 통해 사용할 수 있어</p>
  </li>
  <li>
    <p>오픈소스이고 성능도 좋기 때문에 많은 시스템과 프로젝트에서 쓰이고 있어</p>
  </li>
</ul>

<h2 id="gcc의-기본-사용법">gcc의 기본 사용법</h2>

<h3 id="가장-기본적인-사용">가장 기본적인 사용</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc hello.c <span class="nt">-o</span> hello
</code></pre></div></div>

<ul>
  <li>
    <p>hello.c : 소스 파일</p>
  </li>
  <li>
    <p>o hello : 출력 파일 이름을 hello로 설정</p>
  </li>
</ul>

<h3 id="실행">실행</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>./hello
</code></pre></div></div>

<h2 id="컴파일-단계의-gcc-내부-동작">컴파일 단계의 gcc 내부 동작</h2>

<p>C 코드를 실행 파일로 만들기 위해 gcc는 다음 네 가지 단계를 거쳐:</p>

<ol>
  <li>전처리(Preprocessing) :</li>
</ol>

<ul>
  <li>#include, #define 등의 전처리 지시문 처리</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-E</span> hello.c <span class="nt">-o</span> hello.i
</code></pre></div></div>

<ol>
  <li>컴파일(Compilation) :</li>
</ol>

<ul>
  <li>C 코드를 어셈블리어로 변환</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-S</span> hello.i <span class="nt">-o</span> hello.s
</code></pre></div></div>

<ol>
  <li>어셈블(Assembly) :</li>
</ol>

<ul>
  <li>어셈블리어 코드를 기계어로 변환 (객체 파일 .o)</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-c</span> hello.s <span class="nt">-o</span> hello.o
</code></pre></div></div>

<ol>
  <li>링크(Linking) :</li>
</ol>

<ul>
  <li>라이브러리와 함께 실행 파일을 생성</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc hello.o <span class="nt">-o</span> hello
</code></pre></div></div>

<p>✅ 위 단계를 한 줄 명령어로 묶은 게 그냥 gcc hello.c -o hello 라고 보면 돼!</p>

<h2 id="자주-쓰는-옵션들">자주 쓰는 옵션들</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">옵션</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">-o <file></file></td>
      <td style="text-align: center">출력 파일 이름 지정</td>
    </tr>
    <tr>
      <td style="text-align: center">-wall</td>
      <td style="text-align: center">모든 경고 출력</td>
    </tr>
    <tr>
      <td style="text-align: center">-g</td>
      <td style="text-align: center">디버깅 정보 포함 (gdb로 디버깅할 때 필요)</td>
    </tr>
    <tr>
      <td style="text-align: center">-O0, -O1, -O2, -O3</td>
      <td style="text-align: center">최적화 수준 설정</td>
    </tr>
    <tr>
      <td style="text-align: center">-std=c99, -std=c11 등</td>
      <td style="text-align: center">C 표준 지정</td>
    </tr>
    <tr>
      <td style="text-align: center">-c</td>
      <td style="text-align: center">링크하지 않고 객체 파일까지만 생성</td>
    </tr>
    <tr>
      <td style="text-align: center">-I<dir></dir></td>
      <td style="text-align: center">헤더 파일 포함 디렉토리 지정</td>
    </tr>
    <tr>
      <td style="text-align: center">-L<dir></dir></td>
      <td style="text-align: center">라이브러리 디렉토리 지정</td>
    </tr>
    <tr>
      <td style="text-align: center">-l<lib></lib></td>
      <td style="text-align: center">라이브러리 링크 (-lm은 수학 라이브러리 libm.so를 의미)</td>
    </tr>
  </tbody>
</table>

<ol>
  <li>예제 : 디버깅용 컴파일
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-g</span> hello.c <span class="nt">-o</span> hello
</code></pre></div>    </div>
  </li>
  <li>예제 : 최적화 적용
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-O2</span> hello.c <span class="nt">-o</span> hello
</code></pre></div>    </div>
  </li>
  <li>예제 : 여러 파일 컴파일
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc main.c utils.c <span class="nt">-o</span> myprogram
</code></pre></div>    </div>
  </li>
  <li>예제 : 객체 파일 따로 만들기
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gcc <span class="nt">-c</span> main.c <span class="nt">-o</span> main.o
gcc <span class="nt">-c</span> utils.c <span class="nt">-o</span> utils.o
gcc main.o utils.o <span class="nt">-o</span> myprogram
↑여러 객체 파일들을 하나의 실행파일로 합치는 과정<span class="o">(</span>함수 참조 등 이 단계에서 해결됨, 예 : main.c가 utils.c의 함수 호출<span class="o">)</span>
</code></pre></div>    </div>
  </li>
</ol>

<ul>
  <li>4번 예제 같은 경우, 저 3개의 코드를 실행한 후, utils.c 만 수정한다면, 아래처럼 코드 실행이 필요함</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>utils.c 수정됨
↓
gcc <span class="nt">-c</span> utils.c
↓ 
gcc main.o utils.o <span class="nt">-o</span> myprogram<span class="o">(</span>링크<span class="o">)</span>
</code></pre></div></div>

<h2 id="기타-유용한-gcc-관련-도구들">기타 유용한 gcc 관련 도구들</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">도구</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">make</td>
      <td style="text-align: center">컴파일 자동화 도구(Makefile 사용)</td>
    </tr>
    <tr>
      <td style="text-align: center">gdb</td>
      <td style="text-align: center">GNU debugger</td>
    </tr>
    <tr>
      <td style="text-align: center">valgrind</td>
      <td style="text-align: center">메모리 누수 검사</td>
    </tr>
    <tr>
      <td style="text-align: center">objdump, nm, readelf</td>
      <td style="text-align: center">바이너리 분석 도구들</td>
    </tr>
  </tbody>
</table>

<h3 id="makefile이란">Makefile이란?</h3>

<p>Makefile은 C 프로젝트 빌드 자동화 도구인 make 명령어의 설정 파일이야. 컴파일 명령을 일일이 타이핑 안 해도 <strong>make</strong>만 치면 자동으로 빌드해줘!</p>

<h4 id="구조예제">구조(예제)</h4>

<p>디렉토리 구조</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">myproject</span><span class="o">/</span>
<span class="err">├──</span> <span class="nt">main</span><span class="nc">.c</span>
<span class="err">├──</span> <span class="nt">utils</span><span class="nc">.c</span>
<span class="err">├──</span> <span class="nt">utils</span><span class="nc">.h</span>
<span class="err">├──</span> <span class="nt">Makefile</span>
</code></pre></div></div>

<p>C 예시 파일(main.c)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">"utils.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print_hello</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>C 예시 파일(utils.c)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">print_hello</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello from utils!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>C 예시 파일(utils.h)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifndef UTILS_H
#define UTILS_H
</span>
<span class="kt">void</span> <span class="nf">print_hello</span><span class="p">();</span>

<span class="cp">#endif
</span></code></pre></div></div>

<p>Makefile 예시</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 변수 설정
</span><span class="nv">CC</span> <span class="o">=</span> gcc
<span class="nv">CFLAGS</span> <span class="o">=</span> <span class="nt">-Wall</span> <span class="nt">-g</span>

<span class="c"># 타겟: 의존 파일들
# 명령 (앞에 tab 필수!)
</span><span class="nl">all</span><span class="o">:</span> <span class="nf">main</span>

<span class="nl">main</span><span class="o">:</span> <span class="nf">main.o utils.o</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nt">-o</span> main main.o utils.o

<span class="nl">main.o</span><span class="o">:</span> <span class="nf">main.c utils.h</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nt">-c</span> main.c

<span class="nl">utils.o</span><span class="o">:</span> <span class="nf">utils.c utils.h</span>
	<span class="nv">$(CC)</span> <span class="nv">$(CFLAGS)</span> <span class="nt">-c</span> utils.c

<span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="k">*</span>.o main
</code></pre></div></div>

<h4 id="사용-방법">사용 방법</h4>

<ul>
  <li>bash에서 아래 실행</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>make        <span class="c"># main 실행파일 빌드</span>
make clean  <span class="c"># 중간파일 삭제</span>
</code></pre></div></div>

<ul>
  <li>gdb로 디버깅하기(C 프로그램을 한 줄씩 실행해보거나 변수 추적), 위에 Makefile 보면 아래와 같은 코드가 보일거야</li>
</ul>

<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">CFLAGS</span> <span class="o">=</span> <span class="nt">-Wall</span> <span class="nt">-g</span>
</code></pre></div></div>

<ul>
  <li>디버깅 실행은 bash에서</li>
</ul>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>gdb ./main
</code></pre></div></div>

<h2 id="docker에서-c-파일을-컴파일하고-실행하기">Docker에서 C 파일을 컴파일하고 실행하기</h2>

<h3 id="구조간단-예제">구조(간단 예제)</h3>

<p>C 예시 파일(hello.c)</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">"Hello, Dockerized C!</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Dockerfile 예시</p>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp"># 1. gcc가 포함된 베이스 이미지 사용
</span><span class="n">FROM</span> <span class="n">gcc</span><span class="o">:</span><span class="n">latest</span>

<span class="cp"># 2. 작업 디렉토리 설정
</span><span class="n">WORKDIR</span> <span class="o">/</span><span class="n">usr</span><span class="o">/</span><span class="n">src</span><span class="o">/</span><span class="n">app</span>

<span class="cp"># 3. 현재 디렉토리의 파일을 컨테이너로 복사
</span><span class="n">COPY</span> <span class="p">.</span> <span class="p">.</span>

<span class="cp"># 4. hello.c 파일 컴파일
</span><span class="n">RUN</span> <span class="n">gcc</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span> <span class="n">hello</span><span class="p">.</span><span class="n">c</span>

<span class="cp"># 5. 컨테이너 실행 시 hello 실행
</span><span class="n">CMD</span> <span class="p">[</span><span class="s">"./hello"</span><span class="p">]</span>
</code></pre></div></div>

<h3 id="실행간단-예제">실행(간단 예제)</h3>

<ol>
  <li>도커 이미지 빌드
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> my-c-program <span class="nb">.</span>
</code></pre></div>    </div>
  </li>
  <li>컨테이너 실행
    <div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker run <span class="nt">--rm</span> my-c-program
</code></pre></div>    </div>
  </li>
</ol>

<ul>
  <li>출력 결과</li>
</ul>

<div class="language-mathematica highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">Hello</span><span class="o">,</span><span class="w"> </span><span class="nv">Dockerized</span><span class="w"> </span><span class="nb">C</span><span class="o">!</span><span class="w">
</span></code></pre></div></div>

<h3 id="구조복잡한-예제-makefile-추가-사용">구조(복잡한 예제, Makefile 추가 사용)</h3>

<p>디렉토리 구조</p>
<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">my-c-project</span><span class="o">/</span>
<span class="err">├──</span> <span class="nt">main</span><span class="nc">.c</span>
<span class="err">├──</span> <span class="nt">utils</span><span class="nc">.c</span>
<span class="err">├──</span> <span class="nt">utils</span><span class="nc">.h</span>
<span class="err">├──</span> <span class="nt">Makefile</span>
<span class="err">├──</span> <span class="nt">Dockerfile</span>
</code></pre></div></div>

<p>Dockerfile 예시</p>
<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> gcc:latest</span>

<span class="k">WORKDIR</span><span class="s"> /app</span>

<span class="k">COPY</span><span class="s"> . .</span>

<span class="k">RUN </span>make

<span class="k">CMD</span><span class="s"> ["./app"]</span>
</code></pre></div></div>

<p>Makefile 예시</p>
<div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nl">all</span><span class="o">:</span> <span class="nf">app</span>

<span class="nl">app</span><span class="o">:</span> <span class="nf">main.o utils.o</span>
	gcc <span class="nt">-o</span> app main.o utils.o

<span class="nl">main.o</span><span class="o">:</span> <span class="nf">main.c utils.h</span>
	gcc <span class="nt">-c</span> main.c

<span class="nl">utils.o</span><span class="o">:</span> <span class="nf">utils.c utils.h</span>
	gcc <span class="nt">-c</span> utils.c

<span class="nl">clean</span><span class="o">:</span>
	<span class="nb">rm</span> <span class="nt">-f</span> <span class="k">*</span>.o app
</code></pre></div></div>

<h3 id="실행복잡한-예제-makefile-추가-사용">실행(복잡한 예제, Makefile 추가 사용)</h3>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>docker build <span class="nt">-t</span> my-make-c-app <span class="nb">.</span>
docker run <span class="nt">--rm</span> my-make-c-app
</code></pre></div></div>

<h2 id="자주-쓰는-dockerfile-팁">자주 쓰는 Dockerfile 팁</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">용도</th>
      <th style="text-align: center">예시</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">디버깅용 빌드</td>
      <td style="text-align: center">RUN gcc -g -o hello hello.c</td>
    </tr>
    <tr>
      <td style="text-align: center">최적화 빌드</td>
      <td style="text-align: center">RUN gcc -02 hello hello.c</td>
    </tr>
    <tr>
      <td style="text-align: center">빌드 캐시 활용</td>
      <td style="text-align: center">COPY hello.c → Run gcc … 순서 중요</td>
    </tr>
    <tr>
      <td style="text-align: center">헤더/라이브러리 추가</td>
      <td style="text-align: center">apt-get install로 필요 패키지 추가</td>
    </tr>
  </tbody>
</table>

<h2 id="정리">정리</h2>

<ul>
  <li>
    <p>gcc는 컴파일러의 왕이자, 오픈소스 생태계의 심장</p>
  </li>
  <li>
    <p>그냥 C 코드 실행파일 만드는 툴이 아니라, 시스템 프로그래밍, 임베디드, 운영체제 개발까지 두루 쓰여</p>
  </li>
  <li>
    <p>옵션을 자유자재로 다루면 성능 개선이나 디버깅도 더 수월해져</p>
  </li>
</ul>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="c" /><category term="gcc" /><category term="GNU" /><category term="Compiler" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/C.png" /><media:content medium="image" url="/assets/img/blog/postimage/C.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry><entry><title type="html">가상화(Virtualization)</title><link href="/blog/c/virtualization/" rel="alternate" type="text/html" title="가상화(Virtualization)" /><published>2025-04-13T00:00:00+00:00</published><updated>2025-04-13T00:00:00+00:00</updated><id>/blog/c/virtualization</id><content type="html" xml:base="/blog/c/virtualization/"><![CDATA[<ul class="large-only" id="markdown-toc">
  <li><a href="#가상화의-종류" id="markdown-toc-가상화의-종류">가상화의 종류</a>    <ul>
      <li><a href="#전통적인-vm" id="markdown-toc-전통적인-vm">전통적인 VM</a></li>
      <li><a href="#컨테이너docker" id="markdown-toc-컨테이너docker">컨테이너(Docker)</a></li>
    </ul>
  </li>
  <li><a href="#왜-가상화가-필요한-걸까" id="markdown-toc-왜-가상화가-필요한-걸까">왜 가상화가 필요한 걸까?</a></li>
  <li><a href="#가상화의-장점" id="markdown-toc-가상화의-장점">가상화의 장점</a></li>
  <li><a href="#가상화의-단점" id="markdown-toc-가상화의-단점">가상화의 단점</a></li>
  <li><a href="#c언어-할때-우리가-docker-사용하는-이유" id="markdown-toc-c언어-할때-우리가-docker-사용하는-이유">C언어 할때 우리가 Docker 사용하는 이유</a>    <ul>
      <li><a href="#개발-환경-일관성-유지" id="markdown-toc-개발-환경-일관성-유지">개발 환경 일관성 유지</a></li>
      <li><a href="#빌드-자동화--테스트-자동화" id="markdown-toc-빌드-자동화--테스트-자동화">빌드 자동화 &amp; 테스트 자동화</a></li>
      <li><a href="#실행-환경과-호환-문제-해결" id="markdown-toc-실행-환경과-호환-문제-해결">실행 환경과 호환 문제 해결</a></li>
      <li><a href="#학생--강의--과제-제출용" id="markdown-toc-학생--강의--과제-제출용">학생 / 강의 / 과제 제출용</a></li>
      <li><a href="#보안성" id="markdown-toc-보안성">보안성</a></li>
    </ul>
  </li>
</ul>

<p>하드웨어 자원을 소프트웨어적으로 추상화해서, 여러 개의 독립된 시스템처럼 사용하는 기술 <strong>가상화(Virtualization)</strong>에 대해 알아볼게</p>

<p>가상화를 통해 하나의 물리 컴퓨터 위에서</p>

<ul>
  <li>
    <p>여러 운영처제(OS)</p>
  </li>
  <li>
    <p>여러 어플리케이션 환경</p>
  </li>
</ul>

<p>을 독립적이고 격리된 상태로 실행할 수 있도록 해줘</p>

<h2 id="가상화의-종류">가상화의 종류</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">VM(Virtual Machine)</th>
      <th style="text-align: center">Docker(Container)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">OS 포함</td>
      <td style="text-align: center">각 VM마다 Guest OS 포함</td>
      <td style="text-align: center">커널 공유, OS는 없음</td>
    </tr>
    <tr>
      <td style="text-align: center">부팅 속도</td>
      <td style="text-align: center">느림(분 단위)</td>
      <td style="text-align: center">매우 빠름(초 단위)</td>
    </tr>
    <tr>
      <td style="text-align: center">성능</td>
      <td style="text-align: center">비교적 낮음</td>
      <td style="text-align: center">거의 네이티브 수준</td>
    </tr>
    <tr>
      <td style="text-align: center">자원 사용</td>
      <td style="text-align: center">무거움(OS 단위로 메모리 사용)</td>
      <td style="text-align: center">가벼움(커널 공유하기 때문)</td>
    </tr>
    <tr>
      <td style="text-align: center">격리성</td>
      <td style="text-align: center">강력함</td>
      <td style="text-align: center">비교적 약함(같은 커널 공유)</td>
    </tr>
    <tr>
      <td style="text-align: center">이미지 크기</td>
      <td style="text-align: center">수 GB</td>
      <td style="text-align: center">수 MB ~ GB</td>
    </tr>
    <tr>
      <td style="text-align: center">사용 사례</td>
      <td style="text-align: center">전체 OS 시뮬레이션, 강한 격리 필요시</td>
      <td style="text-align: center">마이크로서비스, CI/CD, 빠른 배포</td>
    </tr>
  </tbody>
</table>

<h3 id="전통적인-vm">전통적인 VM</h3>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span> <span class="nt">물리</span> <span class="nt">하드웨어</span> <span class="o">]</span>
       <span class="err">↓</span>
<span class="o">[</span> <span class="nt">호스트</span> <span class="nt">OS</span> <span class="o">]</span>
       <span class="err">↓</span>
<span class="o">[</span> <span class="nt">하이퍼바이저</span> <span class="o">(</span><span class="nt">Hypervisor</span><span class="o">)</span> <span class="o">]</span>
       <span class="err">↓↓↓↓↓</span>
 <span class="err">┌──────────────┐</span>  <span class="err">┌──────────────┐</span>  <span class="err">┌──────────────┐</span>
 <span class="err">│</span>   <span class="nt">VM</span> <span class="err">1</span>       <span class="err">│</span>  <span class="err">│</span>   <span class="nt">VM</span> <span class="err">2</span>       <span class="err">│</span>  <span class="err">│</span>   <span class="nt">VM</span> <span class="err">3</span>       <span class="err">│</span>
 <span class="err">│</span> <span class="nt">Guest</span> <span class="nt">OS</span>     <span class="err">│</span>  <span class="err">│</span> <span class="nt">Guest</span> <span class="nt">OS</span>     <span class="err">│</span>  <span class="err">│</span> <span class="nt">Guest</span> <span class="nt">OS</span>     <span class="err">│</span>
 <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>  <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>  <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>
 <span class="err">└──────────────┘</span>  <span class="err">└──────────────┘</span>  <span class="err">└──────────────┘</span>
</code></pre></div></div>

<ul>
  <li>
    <p>하드웨어 위에 Hypervisor 설치</p>
  </li>
  <li>
    <p>각 VM마다 운영체제(Guest OS) 전체를 포함</p>
  </li>
  <li>
    <p>리소스 무거움</p>
  </li>
</ul>

<h3 id="컨테이너docker">컨테이너(Docker)</h3>

<div class="language-css highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">[</span> <span class="nt">물리</span> <span class="nt">하드웨어</span> <span class="o">]</span>
       <span class="err">↓</span>
<span class="o">[</span> <span class="nt">호스트</span> <span class="nt">OS</span> <span class="o">(</span><span class="nt">Linux</span> <span class="nt">등</span><span class="o">)</span> <span class="o">]</span>
       <span class="err">↓</span>
<span class="o">[</span> <span class="nt">Docker</span> <span class="nt">Engine</span> <span class="o">]</span>
       <span class="err">↓↓↓↓↓</span>
 <span class="err">┌──────────────┐</span>  <span class="err">┌──────────────┐</span>  <span class="err">┌──────────────┐</span>
 <span class="err">│</span> <span class="nt">Container</span> <span class="err">1</span>  <span class="err">│</span>  <span class="err">│</span> <span class="nt">Container</span> <span class="err">2</span>  <span class="err">│</span>  <span class="err">│</span> <span class="nt">Container</span> <span class="err">3</span>  <span class="err">│</span>
 <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>  <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>  <span class="err">│</span> <span class="nt">App</span> <span class="o">+</span> <span class="nt">Libs</span>   <span class="err">│</span>
 <span class="err">└──────────────┘</span>  <span class="err">└──────────────┘</span>  <span class="err">└──────────────┘</span>
</code></pre></div></div>

<ul>
  <li>
    <p>컨테이너들은 호스트 OS의 커널을 공유</p>
  </li>
  <li>
    <p>애플리케이션 + 라이브러리만 포함된 컨테이너 단위로 실행</p>
  </li>
  <li>
    <p>불필요한 OS가 없음 → 가볍고 빠름</p>
  </li>
  <li>
    <p>자원 사용이 효율적</p>
  </li>
</ul>

<h2 id="왜-가상화가-필요한-걸까">왜 가상화가 필요한 걸까?</h2>

<p><strong>리소스 효율화</strong></p>

<ul>
  <li>
    <p>서버 1대를 여러 대처럼 나눠서 사용 가능</p>
  </li>
  <li>
    <p>하드웨어 낭비 줄일 수 있음</p>
  </li>
</ul>

<p><strong>격리성(Isolation)</strong></p>

<ul>
  <li>
    <p>서로 다른 환경을 완전히 분리</p>
  </li>
  <li>
    <p>한 앱이 죽어도 다른 앱에 영향 없음</p>
  </li>
</ul>

<p><strong>테스트/배포 자동화</strong></p>

<ul>
  <li>개발 → 테스트 → 배포까지 동일한 환경 유지 가능 (특히 Docker)</li>
</ul>

<p><strong>보안성</strong></p>

<ul>
  <li>서로 다른 사용자/프로세스를 독립적으로 운영 가능</li>
</ul>

<h2 id="가상화의-장점">가상화의 장점</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">장점</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">자원 효율성</td>
      <td style="text-align: center">물리 서버 하나로 여러 작업 가능</td>
    </tr>
    <tr>
      <td style="text-align: center">유연성</td>
      <td style="text-align: center">필요한 환경만 골라서 빠르게 만들 수 있음</td>
    </tr>
    <tr>
      <td style="text-align: center">테스트에 용이</td>
      <td style="text-align: center">다양한 OS, 설정 실험 가능</td>
    </tr>
    <tr>
      <td style="text-align: center">격리성 보장</td>
      <td style="text-align: center">하나가 망가져도 다른 프로세스에는 영향 X</td>
    </tr>
    <tr>
      <td style="text-align: center">배포 자동화</td>
      <td style="text-align: center">Dockerfile로 같은 환경을 어디서든 재현 가능</td>
    </tr>
  </tbody>
</table>

<h2 id="가상화의-단점">가상화의 단점</h2>

<table>
  <thead>
    <tr>
      <th style="text-align: center">단점</th>
      <th style="text-align: center">설명</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">성능 오버헤드</td>
      <td style="text-align: center">특히 VM은 OS 전체를 돌리므로 무거움</td>
    </tr>
    <tr>
      <td style="text-align: center">복잡도 증가</td>
      <td style="text-align: center">관리, 설정, 보안 측면에서 신경 쓸 게 많음</td>
    </tr>
    <tr>
      <td style="text-align: center">네트워크/디스크 이슈</td>
      <td style="text-align: center">가상화 계층이 개입되면 속도 손해 가능성</td>
    </tr>
    <tr>
      <td style="text-align: center">Docker : 커널 공유</td>
      <td style="text-align: center">호스트 커널에 의존 → 커널 레벨 취약점에 취약</td>
    </tr>
  </tbody>
</table>

<h2 id="c언어-할때-우리가-docker-사용하는-이유">C언어 할때 우리가 Docker 사용하는 이유</h2>

<h3 id="개발-환경-일관성-유지">개발 환경 일관성 유지</h3>

<ul>
  <li>
    <p>시스템마다 컴파일러 버전, 라이브러리, 경로 다름 → 내 컴퓨터에서는 되지만, 다른 컴퓨터에선느 안될 수 있음</p>
  </li>
  <li>
    <p>Docker는 Dockerfile에 환경을 정의해두면 → 어디서든 똑같은 환경에서 C 코드 실행 가능</p>
  </li>
</ul>

<div class="language-Dockerfile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">FROM</span><span class="s"> gcc:latest</span>
<span class="k">COPY</span><span class="s"> . /app</span>
<span class="k">WORKDIR</span><span class="s"> /app</span>
<span class="k">RUN </span>gcc main.c <span class="nt">-o</span> main
<span class="k">CMD</span><span class="s"> ["./main"]</span>
</code></pre></div></div>

<p>이렇게 하면, 어디서든 gcc main.c 빌드 환경이 같아짐</p>

<h3 id="빌드-자동화--테스트-자동화">빌드 자동화 &amp; 테스트 자동화</h3>

<ul>
  <li>
    <p>Makefile, Cmake 빌드 시스템을 컨테이너에 넣어서 → 코드 푸시하면 자동 빌드가 가능해짐</p>
  </li>
  <li>
    <p>CI/CD (예 : Github Actions, Jenkins)와 연동 쉬움</p>
  </li>
</ul>

<h3 id="실행-환경과-호환-문제-해결">실행 환경과 호환 문제 해결</h3>

<ul>
  <li>
    <p>예를 들어, 코드가 리눅스에서만 돌아간다? → 맥북이나 윈도우에서도 Docker로 리눅스 환경 돌리면 끝!</p>
  </li>
  <li>
    <p>특정 라이브러리나 커널 기능이 필요한 프로젝트일 때 → 해당 환경을 Docker로 재현 가능능</p>
  </li>
</ul>

<h3 id="학생--강의--과제-제출용">학생 / 강의 / 과제 제출용</h3>

<ul>
  <li>
    <p>실습 환경 다르면 문제 생기니까 Docker로 통일하면 편해</p>
  </li>
  <li>
    <p>교수님 팀원한테 “이 Dockerfile 돌리면 됩니다”라고 주면 끝!</p>
  </li>
</ul>

<h3 id="보안성">보안성</h3>

<ul>
  <li>악성 코드 실험, 위험한 시스템 호출 시 Docker에서 격리된 환경에서 안전하게 테스트 가능</li>
</ul>]]></content><author><name>Kwansoo Kim</name><email>albatrers@gmail.com</email></author><category term="blog" /><category term="c" /><category term="C" /><category term="가상화" /><category term="Virtualization" /><summary type="html"><![CDATA[]]></summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="/assets/img/blog/postimage/C.png" /><media:content medium="image" url="/assets/img/blog/postimage/C.png" xmlns:media="http://search.yahoo.com/mrss/" /></entry></feed>