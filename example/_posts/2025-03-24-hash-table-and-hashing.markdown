---
layout: post
title:  "해시 테이블(Hash table), 해시법(Hashing)"
date:   2025-03-24
hide_last_modified: true
---

데이터를 키(key)와 값(value)의 쌍으로 저장하는 자료구조인 딕셔너리(dict)를 배워보자. 

해시 테이블에 대해서 먼저 보여주자면, 아래는 그냥 13개의 원소를 갖고 있는는 리스트이고
~~~python
a=[5, 6, 14, 20, 29, 34, 37, 51, 69, 75]
~~~
## 아래는 헤시 테이블이야

| 키 | 5 | 6 | 14 | 20 | 29 | 34 | 37 | 51 | 69 | 75 |
|:---:|:---:|:---:|
| 해시값(13으로 나눈 나머지) | 5 | 6 | 1 | 7 | 3 | 8 | 11 | 12 | 4 | 10 |

만약 위 테이블에 35라는 수를 추가하고 싶을때, 35와 35를 13으로 나눈 나머지인 9가 같이 저장돼

| 키 | 5 | 6 | 14 | 20 | 29 | 34 | 35 | 37 | 51 | 69 | 75 |
|:---:|:---:|:---:|
| 해시값(13으로 나눈 나머지) | 5 | 6 | 1 | 7 | 3 | 9 | 8 | 11 | 12 | 4 | 10 |

이렇게 되면 정렬이 안깨지면서 원소 이동도 필요 없게 되는거지

이렇게 키를 해시값으로 변환하는 과정을 해시 함수(Hash function)라고 하고 해시 테이블에서 만들어진 원소를 버킷(bucket)이라고 한대

### 해시 테이블의 특징은 아래와 같아

- 데이터를 저장할 떄, 키(key: name 느낌)를 해시 함수에 넣어서 나온 결과값(해시값 : Alice 느낌)을 기반으로 저장 위치를 정해

- 덕분에 데이터를 빠르게 검색, 삽입, 삭제가 가능 

- 평균 시간 복잡도는 O(1)

- 다양한 자료형을 값으로 쓸 수 있어

- 키의 값은 중복될 수 없어서, 같은 값을 넣으면 기존 값이 덮어씌워짐

## 해시 충돌

그렇다면, 다른 가정을 한번 해보자 위 테이블에 18을 추가할때, 나머지인 5가 이미 있잖아? 그런데 괜찮아 왜냐하면 1:1 대응이 아니어도 되거든. 예를 들어, 이름 : 철수 와 이름, 관수 같은 느낌이지. 1:1이 아닌 n:1로 가져가면 돼. 이렇게 버킷이 중복되는 현상을 충돌(collision)이야

2가지 방법으로 대처가 가능해

- 체인법 : 해시값이 같은 원소를 연결 리스트로 관리

- 오픈 주소법 : 빈 버킷을 찾을 때까지 해시를 반복

### 체인법(Chain)

그러면 체인법을 먼저 알아보자. 체인법은 해시값이 같은 데이터를 체인 모양의 연결 리스트로 연결하는 방법이라고 하며, 오픈 해시법(Open hashing)이라고도 한대.

그냥 같은 해시값/버킷에 리스트 구조로 여러 개의 데이터를 저장한다 생각하면 되고, 이 리스트가 너무 길어지면 성능 저하가 발생하니 주의하자

체인법으로 해시 함수 구현해보기 위해 차근차근 예제를 보자
~~~python
from __future__ import annotations
from typing import Any, Type
import hashlib

class Node:
    """해시를 구성하는 노드"""

    def __init__(self, key: Any, value: Any, next: Node) -> None:
        """초기화"""
        self.key   = key    # 키
        self.value = value  # 값
        self.next  = next   # 뒤쪽 노드를 참조
~~~

Node 클래스는 나도 모르지만, 여기서 배워보자. Node 클래스는 개별 버킷을 나타내고 아래와 같이 3개의 필드가 있어. 키 값에 해시 함수를 적용해 해시값을 구한대.

- key : 키(임의의 자료형)
- value : 값(임의의 자료형)
- next : 뒤쪽 노드를 참조(Node형)


~~~python
class ChainedHash:
    """체인법을 해시 클래스 구현"""

    def __init__(self, capacity: int) -> None:
        """초기화"""
        self.capacity = capacity             # 해시 테이블의 크기를 지정
        self.table = [None] * self.capacity  # 해시 테이블(리스트)을 선언

    def hash_value(self, key: Any) -> int:
        """해시값을 구함"""
        if isinstance(key, int):
            return key % self.capacity
        return(int(hashlib.sha256(str(key).encode()).hexdigest(), 16) % self.capacity)
~~~
ChainedHash 클래스는 필드 2개로만 구성이 돼

- capacity : 해시 테이블의 크기(배열 table의 원소 수)를 가리키고

- table : 해시 테이블을 저장하는 list형 배열을 가리켜

## 컴퓨터 시스템은 하드웨어와 시스템 소프트웨어로 구성된다. 두 시스템이 함께 작동되며, 응용프로그램을 실행한다.


먼저 시스템에 관한 공부의 시작은 printf("Hello, world\n"); 를 저장하는 프로그램이 프로그래머에 의해 만들어지고, 시스템에서 실행되고, 단순한 메시지를 출력하고, 종료될 때까지의 수명주기를 추적하는 것으로 시작이 된다.

아래는 모르는 용어 정리이다.

| 소스 프로그램 | 원시 코드 | 사람이 읽을 수 있음 |
|:---:|:---:|:---:|
| 목적 프로그램 | 컴퓨터가 실행할 수 있는 코드 | 기계어 |


| 소스 프로그램 | hello.c라는 txt파일로 저장 | 기계어 |

바이트는 8비트 단위로, 1비트는 0 또는 1로 표시된다.

각 바이트는 프로그램의 텍스트 문자를 나타낸다고 하는데, 모든 텍스트를 담을 수 있을까 궁금했다. 1비트는 2^0 으로 2^8승은 256이기 때문에 충분히 담을 수 있을거 같다.

아스키 문자들로만 이루어진 파일은 텍스트(Text) 파일이고 다른 모든 파일들은 바이너리(Binary) 파일이라고 한다.

hello 프로그램은 인간이 이해하고 읽을 수 있기 때문에 고급 C프로그램으로 일생이 시작되고 다른 프로그램들에 의해 저급 기계어 인스트럭션들로 변역이 돼. 그 후 인스트럭션들은 실행가능 목적 프로그램이라고 하는 형태로 합쳐져서 바이너리 디스크 파일로 저장된다.

### 아래는 hello 파일이 어떻게 저장되는지의 라이프 사이클을 정리했다. 각 단계는 더 세부적인 과정들이 있는데, 일단은 생략

| hello.c              | 전처리 단계(pre-processing)                                                                                          |
|:---:                 |:---:                                                                                                                |
| Source program(text) | 컴파일하기 전에 처리하는 단계로 C언어의 중요한 역할, 결과는 소스 코드는 컴파일러가 이해할 수 있는 순수한 C 코드 형태로 정리됨 |

| hello.i                         | 컴파일 단계 |
|:---:                            |:---:                                                                                   |
| Modified source program(tex)    | 컴파일러(ccl)는 텍스트 파일 .i를 hello.s로 번역하며 이 파일에는 어셈블리어 프로그램이 저장됨 | 

| hello.s                | 어셈블리 단계                                                                                                              |
|:---:                   |:---:                                                                                                                      |
| Assembly program(text) | 어셈블러(as)가 heelo.s를 기계어 인스트럭션으로 번역하고 재배치가능 목적프로그램의 형태로 묶어서 hell.o로 라는 목적파일에 결과 저장 |

| hello.o                | 링크 단계 | hello |
|:---:                   |:---: |:---: |
| Relocatable object programs(binary) | printf 함수는 C 컴파일러에서 제공하는 표준 C 라이브러리에 있다. 그래서 별도의 목적파일에 있으며, hello.o 파일과 어떤 형태로 결햅되어야 하기 때문에 링커(ld)가 통합작업을 수행한다. 그 결과로 hello 파일은 실행가능 목적파일(실행파일)로 메모리에 적재된다. |Executable object program(binary) |


## 버스

시스템 내를 관통하는 전기적 배선군. 그냥 통로라고 생각하면 좋을거 같다. 바이트 단위로 데이터를 전송하며 오늘날 대부분의 컴퓨터들은 4바이트 또는 8바이트 워드 크기를 갖는다.

## 입출력 장치

시스템과 외부세계의 연결을 담당. 키보드나 모니터 같은거라고 생각하면 됨. I/O(input/output) 버스를 통해 연결됨

## 메인 메모리

프로그램을 실행하는 동안의 데이터와 프로그램을 모두 저장하는 임시 저장 장치. DRAM으로 구성됨. 연속적인 바이트들의 배열을 이루며 0부터 시작해 고유의 인덱스를 갖고 있다.

## 프로세서

메인 메모리에 저장된 instruction들을 해독(실행)하는 엔진. Program counter가 가리키는 메모리로 부터 instruction을 읽어오고, 이 instruction에서 비트들을 해석하여 instruction이 지정하는 간단한 동작을 실행하고, PC를 다음 instructino위치로 update 한다. 새로운 instruction은 같을수도 있다.

### 메인 메모리, 레지스터 파일, 수식/논리 처리기(ALU) 주위를 순환한다.

instruction 요청에 따라 CPU가 실행하는 작업의 예를 아래 나열하였다

**적재(Load): 메인 메모리에서 레지스터에 한 바이트 또는 워드를 이전 값에 덮어씌우는 방식으로 복사한다**

**저장(Store): 레지스터에서 메인 메모리로 한 바이트 또는 워드를 이전 값에 덮어씌우는 방식으로 복사한다**

**작업(Operarte): 두 레지스터의 값을 수식/논리 처리기(ALU)로 복사하고 두 개의 워드로 수식연산을 수행한 뒤 , 결과를 덮어쓰기 방식으로 레지스터에 저장한다**

**점프(Jump): instruction 자신으로부터 한개의 워드를 추출하고 이걸을 PC에 덮어쓰기 방식으로 복사한다**


컴퓨터 특성상 저장을 많이 할수 있는 디스크나 메인 메모리, 그에 반해 많이 저장할수 없지만 빠르게 읽을 수 있는 레지스터나 캐시가 존재한다. 캐시 중 L1 캐시와 L2 캐시가 있는데, 이들은 SRAM(Static Random Access Memory)라는 하드웨 기술을 이용해 구현된다.

메모리 계층구조라는것이 존재하는데, 이것의 주요 아이디어는 한 레벨의 저장장치가 다음 하위레벨 저장장치의 캐시 역할을 한다는 것이다

## 운영 체제

운영 체제는 응용 프로그램과 하드웨어 사이에 있어서 응용 프로그램대로 하드웨어가 작동하도록 한다.

- 컨텍스트(Context) : 운영체제는 프로세스가 실행하는 데 필요한 모든 상태정보의 변화를 추적한다. 컨텍스트라고 부르는 상태정보는 PC, 레지스터 파일, 메인 메모리의 현재 값을 포함

- 문맥전환(context switching) : 현재 프로세스에서 다른 새로운 프로세스로 제어를 옮기려고 할 때 현재 프로세스의 컨텍스트를 저장하고 새 프로세스의 컨텍스트를 복원시킴. 이런 과정을 실행하여 제어권을 새 프로세스로 넘겨줌

- 시스템 콜 : 제어권을 운영체제로 넘기는 것

- 커널 : 하나의 프로세스에서 다른 프로세스로의 전환은 운영체제 커널에 의해 관리되고 메모리에 상주함, 코드와 자료구조의 집합이라 하는데 무슨 소리지...

## 쓰레드(Thread)

쓰레드는 해당 프로세스의 컨텍스트에서 실행되며 동일한 코드와 전역 데이터를 공유한다.

다수의 프로세스들보다 데이터의 공유가 더 쉬운점, 프로세스보다 더 효율적인 점 떄문에 프로그래밍 모델로써 중요성이 커지고 있다.

## 가상 메모리

가상 메모리는 각 프로세스들이 메인 메모리 전체를 독점적으로 사용하고 있는 것 같은 환상을 제공하는 추상화이다. 각 프로세스는 가상주소 공간이라고 하는 균일한 메모리의 모습을 갖게 된다.

### 가상주소 공간의 취상위 영역은 모든 프로세스들이 공통으로 사용하는 운영체제의 코드와 데이터를 위한공간

- 커널 가상 메모리 : 주소공간의 맨 윗부분은 커널을 위해 예약되어 있다. 응용프로그램들은 이 영역의 내용을 읽거나 쓰는 것이 금지되어 있으며, 마찬가지로 커널 코드 내에 정의된 함수를 집접 호출하는 것도 금지되어 있다.

- 스택(Stack) : 사용자 가상메모리 공간의 맨 위에 컴파일러가 함수 호출을 구현하기 위해 사용하는 사용자 스택이 위치한다. 힙과 마찬가지로 사용자 스택은 프로그램이 실행되는 동안에 동적으로 늘어났다 줄어들었다 한다. 특히, 함수를 호출할 때마다 스택이 커지며, 함수에서 리턴될 떄는 줄어든다.

- 공유 라이브러리 : 주소공간의 중간 부근에 C 표준 라이브러리나 수학 라이브러리와 같은 공유 라이브러의 코드와 데이터를 저장하는 영역이 있다. 공유 라이브러리 개념은 강력하지만 다소 어렵다.

- 힙(Heap) : 코드와 데이터 영역 다음으로 런타입 힙이 따라온다. 크기(주소)가 고정되어 있는 코드, 데이터 영역과 달리, 힙은 프로세스가 실행되면서 C 표준함수인 malloc이나 free를 호출하면서 런타임에 동적으로 그 크기가 늘었다 줄었다 한다.  

- 프로그램 코드와 데이터 : 코드는 모든 프로세스들이 같은 고정 주소에서 시작하며, 다음에 C 전역변수에 대응되는 데이터 위치들이 따라온다. 코드와 데이터 영역은 실행가능 목적파일인 hello로부터 직접 초기화된다.

### 가상주소 하위 영역은 사용자 프로세스의 코드와 데이터를 저장

가상주소 위쪽으로 갈수록 주소가 증가한다

가상메모리가 작동하기 위해서는 프로세스가 만들어내는 모든 주소를 하드웨어로 변역하는 등의 하드웨어와 운영체제 소프트웨어 간의 복잡한 상효작용이 필요하다. 기본적인 아이디어는 프로세스의 가상메모리의 내용을 디스크에 저장하고 메인 메모리를 디스크의 캐시로 사용하는 것이다.

## 파일
파일은 연속된 바이트들이다. 모든 입출력장치는 파일로 모델링하고 시스템의 모든 입출력은 시스템 콜들을 이용해 파일을 읽고 쓰는 형태로 이루어진다. 신기한 것은 파일 개념이 있어서 사용하고 있는 특정 디스크의 기술에 대해서 몰라도 사용이 가능하다.

***큐(Queue) 함수***