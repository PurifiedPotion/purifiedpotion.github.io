---
layout: post
title:  "해시 테이블(Hash table), 해시법(Hashing)"
date:   2025-03-24
hide_last_modified: true
---

긁어모음, 뒤죽박죽이라는 의미를 가진 해시라는 단어가 파이썬에서는 어떻게 쓰일까.
데이터를 키(key)와 값(value)의 쌍으로 저장하는 자료구조인 딕셔너리(dict) 또는 해시(hashing)를 배워보자. 

해시 테이블에 대해서 먼저 보여주자면, 아래는 그냥 13개의 원소를 갖고 있는는 리스트이고
~~~python
a=[5, 6, 14, 20, 29, 34, 37, 51, 69, 75]
~~~
## 아래는 헤시 테이블이야

| 키 | 5 | 6 | 14 | 20 | 29 | 34 | 37 | 51 | 69 | 75 |
|:---:|:---:|:---:|
| 해시값(13으로 나눈 나머지) | 5 | 6 | 1 | 7 | 3 | 8 | 11 | 12 | 4 | 10 |

만약 위 테이블에 35라는 수를 추가하고 싶을때, 35와 35를 13으로 나눈 나머지인 9가 같이 저장돼

| 키 | 5 | 6 | 14 | 20 | 29 | 34 | 35 | 37 | 51 | 69 | 75 |
|:---:|:---:|:---:|
| 해시값(13으로 나눈 나머지) | 5 | 6 | 1 | 7 | 3 | 9 | 8 | 11 | 12 | 4 | 10 |

이렇게 되면 정렬이 안깨지면서 원소 이동도 필요 없게 되는거지

이렇게 키를 해시값으로 변환하는 과정을 해시 함수(Hash function)라고 하고 해시 테이블에서 만들어진 원소를 버킷(bucket)이라고 한대

### 해시 테이블의 특징은 아래와 같아

- 데이터를 저장할 떄, 키(key: name 느낌)를 해시 함수에 넣어서 나온 결과값(해시값 : Alice 느낌)을 기반으로 저장 위치를 정해

- 덕분에 데이터를 빠르게 검색, 삽입, 삭제가 가능 

- 평균 시간 복잡도는 O(1)

- 다양한 자료형을 값으로 쓸 수 있어

- 키의 값은 중복될 수 없어서, 같은 값을 넣으면 기존 값이 덮어씌워짐

## 해시 충돌

그렇다면, 다른 가정을 한번 해보자 위 테이블에 18을 추가할때, 나머지인 5가 이미 있잖아? 그런데 괜찮아 왜냐하면 1:1 대응이 아니어도 되거든. 예를 들어, 이름 : 철수 와 이름, 관수 같은 느낌이지. 1:1이 아닌 n:1로 가져가면 돼. 이렇게 버킷이 중복되는 현상을 충돌(collision)이야

2가지 방법으로 대처가 가능해

- 체인법 : 해시값이 같은 원소를 연결 리스트로 관리

- 오픈 주소법 : 빈 버킷을 찾을 때까지 해시를 반복

만약 충돌이 나지 않게 된다면, 검색/추가/삭제의 시간 복잡도는 모두 O(1)이야. 그렇다고 해시 테이블을 크게 만들면 메모리를 낭비하니 이것도 주의하자.

해시 충돌을 예방하고자 할때 해시 테이블의 크기는 소수로 하자

### 체인법(Chain)

그러면 체인법을 먼저 알아보자. 체인법은 해시값이 같은 데이터를 체인 모양의 연결 리스트로 연결하는 방법이라고 하며, 오픈 해시법(Open hashing)이라고도 한대.

그냥 같은 해시값/버킷에 리스트 구조로 여러 개의 데이터를 저장한다 생각하면 되고, 이 리스트가 너무 길어지면 성능 저하가 발생하니 주의하자.

또한, 해시 함수가 해시 테이블 크기보다 작거나 같은 정수를 고르게 생성해야 해. 그래서 해시 테이블의 크기는 소수를 선호한대, 나눠서 값이 잘 안 떨어지니까?

체인법으로 해시 함수 구현해보기 위해 차근차근 예제를 보자

~~~python
from __future__ import annotations
from typing import Any, Type
import hashlib

class Node:
    """해시를 구성하는 노드"""

    def __init__(self, key: Any, value: Any, next: Node) -> None:
        """초기화"""
        self.key   = key    # 키
        self.value = value  # 값
        self.next  = next   # 뒤쪽 노드를 참조
~~~

Node 클래스는 나도 모르지만, 여기서 배워보자. Node 클래스는 개별 버킷을 나타내고 아래와 같이 3개의 필드가 있어. 키 값에 해시 함수를 적용해 해시값을 구한대.

- key : 키(임의의 자료형)
- value : 값(임의의 자료형)
- next : 뒤쪽 노드를 참조(Node형)


~~~python
class ChainedHash:
    """체인법을 해시 클래스 구현"""

    def __init__(self, capacity: int) -> None:
        """초기화"""
        self.capacity = capacity             # 해시 테이블의 크기를 지정
        self.table = [None] * self.capacity  # 해시 테이블(리스트)을 선언

    def hash_value(self, key: Any) -> int:
        """해시값을 구함"""
        if isinstance(key, int):
            return key % self.capacity
        return(int(hashlib.sha256(str(key).encode()).hexdigest(), 16) % self.capacity)
~~~
ChainedHash 클래스는 필드 2개로만 구성이 돼

- capacity : 해시 테이블의 크기(배열 table의 원소 수)를 가리키고

- table : 해시 테이블을 저장하는 list형 배열을 가리켜

위의 __init__함수 같은 경우 원소 수가 capacity(배열 table의 원소 수)인 list형의 배열 table을 생성하고 모든 원소를 None으로 한다는 얘기야. 해시 테이블의 각 버킷은 맨 앞부터 table[0], table[1], ..., table[capacity-1] 순으로 접근할 수 있다.

지금은 table의 모든 원소는 None이고 버킷은 capacity 만큼 있다.

### hash_value() : 해시 함수 만들기인데, 위 처음에 설명한거처럼 이해해

그런데, key가 int형인 경우와 아닌 경우에 따라서 함수가 변해

- key가 int : key를 해시의 크기 capacity로 나눈 나머지를 해시값

- key != int : 문자열/리스트/클래스형 등은 나눌 수 없기 때문에, 아래 표와 같이 표준 라이브러리로 형 변환을 해야 해시값을 얻을 수가 있어.

| sha256 알고리즘 | hashlib 모듈에서 제공되며, 주어진 바이트 문자열의 해시값을 구하는 해시 알고림의 생성자 |
|:---:|:---:|
| encode() 함수 | hashlib.sha256에 바이트 문자열의 인수를 전달하면, key를 str형 문자열로 변환한 뒤 그 문자열을 encode() 함수에 전달하여 바이트 문자열을 생성한다|
| hexdigest() 함수 | sha256 알고리즘에서 해시값을 16진수 문자열로 꺼냄 |
| int() 함수 | hexdigest() 함수로 꺼낸 문자열을 16진수 int형으로 변환 |

#### 키로 원소를 검색하는 search() 함수

