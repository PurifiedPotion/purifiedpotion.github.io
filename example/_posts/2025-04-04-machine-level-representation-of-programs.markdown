---
layout: post
title:  "프로그램의 기계수준 표현(Machine-Level Representation of Programs)"
date:   2025-04-04
hide_last_modified: true
---

* toc  
{:toc .large-only}

컴퓨터는 데이터를 처리하고, 메모리를 관리하고, 저장장치에 데이터를 읽거나 쓰고, 네트워크를 통해 통신하는 등의 하위 동작들을 인코딩한 연속된 바이트인 기계어 코드를 실행한다. 

## 프래그로머로써 왜 어셈블리어를 배워야 할까? 

최신 최적화 컴파일러가 만들어 낸 코드는 대부분 잘 훈련된 어셈블리어 프래그로머가 손으로 작성한 것과 유사한 효율성을 갖는다. 그 말은 잘 훈련된 프로그래머의 어셈블리어가 최신 최적화 컴파일러가 만들어 낸 코드만큼의 효율성을 갖는다는 얘기다. 어셈블리어 코드를 읽고 이해할 수 있으면, 컴파일러의 최적화 성능을 알 수 있으며, 코드에 내재된 비효율성을 분석할 수 있다

## 기계수준 코드

기계수준 프로그래밍에 중요한 특징 두가지가 있어

- 1. 기계수준 프로그램의 형식과 동작은 인스트럭션 집합구조(Instruction set architecture) 즉, "ISA"에 의해 정의된다

- 2. 기계수준 프로그램이 사용하는 주소는 가상주소이며, 메모리가 매우 큰 바이트 배열인 것처럼 보이게 하는 메모리 모델 제공

그리고 프로세서 내부 구조에 대해서 설명할게

- ***프로그램 카운터***(일반적으로 PC라고 하며, x86-64에서는 %rip라고 함)는 실행할 다음 인스트럭션의 메모리 주소를 가리킴

- ***정수 레지스터*** 파일은 64비트 값을 저장하기 위한 16개의 이름을 붙인 위치를 갖는다. 이들 레지스터는 주소(C언어의 포인터에 해당하는)나 정수 데이터를 저장할 수 있다. 일부 레지스터는 프로그램의 중요한 상태를 추적하는데 사용할 수 있으며, 다른 레지스터들은 함수의 리턴 값뿐만 아니라 프로시저의 지역변수와 인자 같은 임시 값을 저장하는 데 사용한다

- ***조건코드 레지스터***들은 가장 최근에 실행한 산술 또는 논리 인스트럭션에 관한 상태 정보를 저장한다. 이들은 if나 while문을 구현할 때 필요한 제어나 조건에 따른 데이터 흐름의 변경을 구현하기 위해 사용된다

- ***벡터 레지스터***들의 집합은 하나 이상의 정수나 부동소수점 값들을 각각 저장할 수 있다

### 프로그램 메모리

프로그램 메모리는 프로그램의 실행 기계어 코드, 운영체제를 위한 일부 정보, 프로시저 호출과 리턴을 관리하는 런타임 스택, 사용자에 의해 할당된(예를 들어 malloc 라이브러리 함수를 사용해서) 메모리 블록들을 포함하고 있다

## 코드 예제

----

## 정보 접근하기

인스트럭션들은 16개의 레지스터 하위 바이트들에 저장된 다양한 크기의 데이터에 대해 연산할 수 있다. 바이트수준 연산들은 가장 덜 중요한 바이트에 대해 연산을 할 수 있으며, 16비트 연산들은 가장 덜 중요한 2바이트에 접근하고, 32비트 연산은 덜 중요한 4바이트에, 64비트 연산은 레지스터 전체에 접근할 수 있다.

### 오퍼랜드 식별자(Operand specifier)

대부분의 인스트럭션은 하나 이상의 오퍼랜드를 가진다. 오퍼랜드는 연산을 수행할 소스(source)값과 그 결과를 저장할 목적지(destination)의 위치를 명시한다.

## 데이터 이동 예제

| 명령어 접미사 | 크기 | 예시 레지스터 |
|:---:|:---:|:---:|
| b (byte) | 8 비트 | %al, %bl |
| w (word) | 16 비트 | %ax, %bx |
| l (long) | 32 비트 | %eax, %ebx |
| q (quad) | 64 비트 | %rax, %rbx |

### 자료형 변환 (Type Casting)

#### 작은 타입 → 큰 타입 (확장)

예 : char(8bit) → int(32bit)

같은 경우 두 가지 방식으로 확장 가능 : 

- Zero extension (0으로 채움) : 부호 없는 확장

- Sign extenstion (부호비트 복사) : 부호 있는 확장

~~~assembly
; 예: 8비트 AL 레지스터 → 32비트 EAX로 확장

movzx eax, al     ; zero-extension: AL을 EAX로 확장
movsx eax, al     ; sign-extension: AL을 EAX로 확장 (AL이 음수면 1로 채움)
~~~

#### 큰 타입 → 작은 타입 (축소)

예 : int(32bit) → char(8bit)

이건 단순히 상위 비트를 버림. 잘못하면 값이 잘릴 수 있음

~~~assembly
mov al, bl       ; 단순 복사 → 상위 비트 무시
~~~

### 정수형 확장

자료형 변환과 확장되는데 다사 정리하자면 :

| 종류 | 설명 | 어셈블리어 명령어 |
|:---:|:---:|:---:|
| Zero Extension | 상위 비트를 0으로 채움 | MOVZX |
| Sign Extension | 상위 비트를 부호 비트로 채움 | MOVSX |

- C언어에서 unsigned char → int 변환하면 zero-extension

- signed char → int은 sign-extension 됨

### 부호성과 크기의 변환

부호성(sign)은 같은 비트 패턴이라도 해석 방법이 다름

| 이진수 | 부호 있음(signed) | 부호 없음(unsigned) |
|:---:|:---:|:---:|
| 11111111 (8bit) | -1 | 255 |
| 10000000 | -128 | 128 |

예시 : 이런 식으로, 같은 al = 0xFF 값을 어떻게 해석하냐에 따라 완전히 다른 결과가 나와.
~~~assembly
mov al, -1         ; al = 0xFF (-1)
movzx eax, al      ; eax = 0x000000FF (255) ← zero-extension
movsx eax, al      ; eax = 0xFFFFFFFF (-1) ← sign-extension
~~~

#### 그러면 부호성은 언제 사용하냐?

- 함수 호출 시 작은 자료형을 큰 레지스터에 넣을 때

- 시스템 콜에 인자 전달할 때 정수형 확장 필수

- 부호 있는 비교 (cmp) vs 부호 없는 비교 (cmp + ja/jb 등)에서 차이 발생

- imul, mul 등 부호 여부에 따라 다른 명령어 사용

### 자료형, 정수형 확장, 부호성과 크기의 변환 요약

| 개념 | 설명 |
|:---:|:---:|
| 자료형 없음 | 어셈블리는 타입보다 "크기"와 "부호 여부"에 집중 |
| Zero-extension | unsigned 확장. 상위 비트를 0으로 채움 |
| Sign-extension | signed 확장. 부호 비트를 상위에 복사 |
| 축소(Casting down) | 상위 비트 잘림 (주의 필요) |
| 부호 해석 | 같은 비트라도 signed/unsigned로 다르게 해석됨 |
| 주요 명령어 | mov, movzx, movsx, cmp, imul, mul |