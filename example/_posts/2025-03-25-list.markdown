---
layout: post
title:  "리스트(List)"
date:   2025-03-26
hide_last_modified: true
---

* toc  
{:toc .large-only}

데이터에 순서를 매겨 늘어놓은 자료구조를 ***리스트*** 라고 해. 여기서는 ***연결 리스트***, ***포인터를 이용한 연결 리스트***, ***커서를 이용한 연결 리스트***, ***원형 이중 연결 리스트***에 대해서 다뤄볼거야

## 연결 리스트

구조가 단순한 리스트이며, 아래 그림을 보면 A가 B에게, B가 C에게 차례대로 연락하는 비상 연락망 같은 구조야. 이런 구조에서는 건너뛰거나 뒤돌아 앞 사람에게 연락이 안되지

![연결 리스트 기본 구조](/assets/img/blog/computerscience/연결%20리스트의%20기본%20구조.png)

연결 리스트 각각의 원소를 노드(node)라고 해. 노드 안에는 데이터와 뒤쪽 노드를 가리키는(참조) 포인터(pointer)가 존재해.

- 맨 앞에 있는 노드를 ***머리 노드(head node)***

- 맨 끝에 있는 ***꼬리 노드(tail node)***

- 노드 바로 앞에 있는 노드를 ***앞쪽 노드(predecessor node)***

- 노드 바로 뒤쪽에 있는 노드를 ***뒤쪽 노드(successor node)***

### 배열로 연결 리스트 만들기

![배열로 연결 리스트 만들기](/assets/img/blog/computerscience/배열로연결리스트만들기.png)

위에서 설명했던 연결 리스트를 아래 구현해 봤어. 

- 뒤쪽 노드를 꺼내고 싶다면, 첫번째부터 시작해서 뒤쪽 노드 꺼내기를 이용해 인덱스 1씩 증가시켜서 원소에 접근할수 있어.

- 사진처럼 55의 데이터를 12와 33사이에 넣고 싶다면, 뒤쪽 노드를 하나씩 이동시켜야해. 원소 삭제도 마찬가지로 배열 안의 원소들을 이동시켜야해. 고로 ***데이터 삽입/삭제에 용이하지 않단 것이지***


## 포인터로 연결 리스트 만들기

배열 연결 리스트에서는 인덱스를 1씩 증가시키는 방식을 채택했지만, 이거는 노드마다 뒤쪽 노드를 가리키는 포인터가 포함되도록 구현하는 연결 리스트야. 대신에 클래스 Node를 사용해야해

- 데이터 삽입시, 노드용 인스턴스 생성

- 데이터 삭제시, 노드용 인스턴스 삭제

여기서 Node는 자신과 같은 클래스형의 인스턴스를 참조하기위한 참조용 필드 next를 보유해. 이와 같은 자신과 같은 클래스의 인스턴스를 참조하는 필드가 있는 구조를 ***자기 참조(self-referential)***형이라 해

![같은 클래스의 참조](/assets/img/blog/computerscience/같은클래스의참조.png)

위 사진을 보면, 뒤쪽 포인터 next에는 뒤쪽 노드에 대한 참조를 저장해. 만약 꼬리 노드라면, 뒤쪽 포인터 next에는 None이 저장돼

그러면 이제 포인터로 연결 리스트를 구현하는 함수에 대해서 알아보자

### 노드 클래스 __init__() 함수

노드 클래스 Node의 필드에는 2개가 있어

- data : 데이터(데이터라고 데이터가 아니야! 데이터에 대한 참조일뿐)

- next : 뒤쪽 포인터(뒤쪽 노드에 대한 참조)

예제 : __init__() 함수, 전달받은 data와 next를 해당 필드에 대입. 이때 주목 노드를 보면 next야, next를 생략하면 None으로 들어가.
~~~python
class Node:
    """연결 리스트용 노드 클래스"""

    def __init__(self, data: Any = None, next: Node = None):
        """초기화"""
        self.data = data  # 데이터
        self.next = next  # 뒤쪽 포인터
~~~

### LinkedList 클래스 __init__(), __len__() 함수, + 그 외

LinkedList 클래스 필드에는 3가지가 있어

- no : 리스트에 등록된 노드의 개수

- head : 머리 노드에 대한 참조

- current : 현재 주목하고 있는 노드에 대한 참조, 포인터이기도 해

예제 : __init__() 함수, 노드가 하나도 없는 빈 연결 리스트 생성, 머리 노드를 참조하기 위한 Node형 필드 head에 None 입력한다. 그 이유는 아직 아무 데이터가 없기 때문
~~~python
class LinkedList:
    """연결 리스트 클래스"""

    def __init__(self) -> None:
        """초기화"""
        self.no = 0          # 노드의 개수
        self.head = None     # 머리 노드
        self.current = None  # 주목 노드
~~~

예제 : __len__() 함수, 연결리스트의 개수를 반환하는 함수
~~~python
    def __len__(self) -> int:
        """연결 리스트의 노드 개수를 반환"""
        return self.no
~~~

좀더 나아가 보자, 아래거를 이해하면 Node에 대해서 이해력도 높아질거야

만약에 연결 리스트가 비어 있다면? (no == 0)함수를 사용해도 되겠지만, head가 없을것이기 때문에 아래와 같은 함수로 확인이 가능해
~~~python
head is None
~~~

노드가 1개만일때는? head 말고 더 없을테니까 head의 next값은 참조하고 있는게 없을거야. 그러면 아래와 같아지겠지
~~~python
head.next is None
~~~

그렇다면 노드가 2개일때는? 헤드 뒤에 뒤쪽 노드(successor node) 가 존재할테고 그 노드의 next값은 None이겠지?
~~~python
head.next.next is None
~~~

### LinkedList 클래스 search(), __contains__() 함수

검색 같은 경우 선형 검색(처음부터 차례대로 검색)을 사용

예제 : search() 함수
~~~python
    def search(self, data: Any) -> int:
        """data와 값이 같은 노드를 검색"""
        cnt = 0
        ptr = self.head
        while ptr is not None:
            if ptr.data == data:
                self.current = ptr
                return cnt
            cnt += 1
            ptr = ptr.next
        return -1
~~~

검색이 성공하면, cnt를 반환하고 검색이 실패하면 -1을 반환한다.

예제 : __contains__() 함수
~~~python
    def __contains__(self, data: Any) -> bool:
        """연결 리스트에 data가 포함되어 있는가?"""
        return self.search(data) >= 0
~~~

위 search 함수 사용하는데, self 에 data와 같은 같이 있는지 판단, True or False 반환

### LinkedList 클래스 add_first(), add_last() 함수

예제 : add_first() 함수
~~~python
    def add_first(self, data: Any) -> None:
        """맨 앞에 노드를 삽입"""
        ptr = self.head  # 삽입 전의 머리 노드
        self.head = self.current = Node(data, ptr)
        self.no += 1
~~~

- A포인터에 현재!머리 노드를 저장

- 현재! 머리 노드에 노드(date, ptr(A포인터로써 원래의 머리노드를 참조))가 추가된다.

예제 : add_last() 함수
~~~python
    def add_last(self, data: Any):
        """맨 끝에 노드를 삽입"""
        if self.head is None :    # 리스트가 비어 있으면
            self.add_first(data)  # 맨앞에 노드 삽입
        else:
            ptr = self.head
            while ptr.next is not None:
                ptr = ptr.next  # while문을 종료할 때 ptr은 꼬리 노드를 참조
            ptr.next = self.current = Node(data, None)
            self.no += 1
~~~

- 먼저 리스트가 비어있는지 확인

- ptr is None을 찾을때까지 순차적으로 노드를 탐색

- prt이 None을 갖고있는 ptr.next를 찾았을때, 추가할 노드의 정보(next : None으로)를 대입한다.

- LinkedList의 number를 1추가

### LinkedList 클래스 remove_first(), remove_last() 함수