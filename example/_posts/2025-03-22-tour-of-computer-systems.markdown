---
layout: post
title:  "컴퓨터 시스템으로의 여행"
date:   2025-03-22
hide_last_modified: true
---

나는 크래프톤 정글에 들어와서 CS 교육과정을 듣고있다. CS 교육을 위해 4권의 책을 받았고 이중 하나의 책 이름이 "컴퓨터 시스템"이다. 이 책은 독자가 컴퓨터 시스템의 기반과 시스템 응용프로그램에 미치는 영향을 이해하는 "파워 프로그래머"가 되게끔 알려주는 책이다. 여기서 핵심적인 부분들을 정리하고 내가 또 나중에 볼 수 있도록 한다.

## 컴퓨터 시스템은 하드웨어와 시스템 소프트웨어로 구성된다. 두 시스템이 함께 작동되며, 응용프로그램을 실행한다.


먼저 시스템에 관한 공부의 시작은 printf("Hello, world\n"); 를 저장하는 프로그램이 프로그래머에 의해 만들어지고, 시스템에서 실행되고, 단순한 메시지를 출력하고, 종료될 때까지의 수명주기를 추적하는 것으로 시작이 된다.

아래는 모르는 용어 정리이다.

| 소스 프로그램 | 원시 코드 | 사람이 읽을 수 있음 |
|:---:|:---:|:---:|
| 목적 프로그램 | 컴퓨터가 실행할 수 있는 코드 | 기계어 |


| 소스 프로그램 | hello.c라는 txt파일로 저장 | 기계어 |

바이트는 8비트 단위로, 1비트는 0 또는 1로 표시된다.

각 바이트는 프로그램의 텍스트 문자를 나타낸다고 하는데, 모든 텍스트를 담을 수 있을까 궁금했다. 1비트는 2^0 으로 2^8승은 256이기 때문에 충분히 담을 수 있을거 같다.

아스키 문자들로만 이루어진 파일은 텍스트(Text) 파일이고 다른 모든 파일들은 바이너리(Binary) 파일이라고 한다.

hello 프로그램은 인간이 이해하고 읽을 수 있기 때문에 고급 C프로그램으로 일생이 시작되고 다른 프로그램들에 의해 저급 기계어 인스트럭션들로 변역이 돼. 그 후 인스트럭션들은 실행가능 목적 프로그램이라고 하는 형태로 합쳐져서 바이너리 디스크 파일로 저장된다.

| 전처리 단계 | 컴파일 단계 | 어셈블리 단계 | 링크 단계 |
|:---:|:---:|:---:|:---:|
| 소스 프로그램 | hello.c라는 txt파일로 저장 | 기계어 | 기계어 |

## 버스

시스템 내를 관통하는 전기적 배선군. 그냥 통로라고 생각하면 좋을거 같다. 바이트 단위로 데이터를 전송하며 오늘날 대부분의 컴퓨터들은 4바이트 또는 8바이트 워드 크기를 갖는다.

## 입출력 장치

시스템과 외부세계의 연결을 담당. 키보드나 모니터 같은거라고 생각하면 됨. I/O(input/output) 버스를 통해 연결됨

## 메인 메모리

프로그램을 실행하는 동안의 데이터와 프로그램을 모두 저장하는 임시 저장 장치. DRAM으로 구성됨. 연속적인 바이트들의 배열을 이루며 0부터 시작해 고유의 인덱스를 갖고 있다.

## 프로세서

메인 메모리에 저장된 instruction들을 해독(실행)하는 엔진. Program counter가 가리키는 메모리로 부터 instruction을 읽어오고, 이 instruction에서 비트들을 해석하여 instruction이 지정하는 간단한 동작을 실행하고, PC를 다음 instructino위치로 update 한다. 새로운 instruction은 같을수도 있다.

### 메인 메모리, 레지스터 파일, 수식/논리 처리기(ALU) 주위를 순환한다.

instruction 요청에 따라 CPU가 실행하는 작업의 예를 아래 나열하였다

**적재(Load): 메인 메모리에서 레지스터에 한 바이트 또는 워드를 이전 값에 덮어씌우는 방식으로 복사한다**
**저장(Store): 레지스터에서 메인 메모리로 한 바이트 또는 워드를 이전 값에 덮어씌우는 방식으로 복사한다**
**작업(Operarte): 두 레지스터의 값을 수식/논리 처리기(ALU)로 복사하고 두 개의 워드로 수식연산을 수행한 뒤 , 결과를 덮어쓰기 방식으로 레지스터에 저장한다**
**점프(Jump): instruction 자신으로부터 한개의 워드를 추출하고 이걸을 PC에 덮어쓰기 방식으로 복사한다**


컴퓨터 특성상 저장을 많이 할수 있는 디스크나 메인 메모리, 그에 반해 많이 저장할수 없지만 빠르게 읽을 수 있는 레지스터나 캐시가 존재한다. 캐시 중 L1 캐시와 L2 캐시가 있는데, 이들은 SRAM(Static Random Access Memory)라는 하드웨 기술을 이용해 구현된다.

메모리 계층구조라는것이 존재하는데, 이것의 주요 아이디어는 한 레벨의 저장장치가 다음 하위레벨 저장장치의 캐시 역할을 한다는 것이다

## 운영 체제

운영 체제는 응용 프로그램과 하드웨어 사이에 있어서 응용 프로그램대로 하드웨어가 작동하도록 한다.

- 컨텍스트(Context) : 운영체제는 프로세스가 실행하는 데 필요한 모든 상태정보의 변화를 추적한다. 컨텍스트라고 부르는 상태정보는 PC, 레지스터 파일, 메인 메모리의 현재 값을 포함

- 시스템 콜 : 제어권을 운영체제로 넘기는 것

- 커널 : 하나의 프로세스에서 다른 프로세스로의 전환은 운영체제 커널에 의해 관리되고 메모리에 상주함, 코드와 자료구조의 집합이라 하는데 무슨 소리지...

## 쓰레드(Thread)

쓰레드는 해당 프로세스의 컨텍스트에서 실행되며 동일한 코드와 전역 데이터를 공유한다.

다수의 프로세스들보다 데이터의 공유가 더 쉬운점, 프로세스보다 더 효율적인 점 떄문에 프로그래밍 모델로써 중요성이 커지고 있다.

## 가상 메모리

가상 메모리는 각 프로세스들이 메인 메모리 전체를 독점적으로 사용하고 있는 것 같은 환상을 제공하는 추상화이다. 각 프로세스는 가상주소 공간이라고 하는 균일한 메모리의 모습을 갖게 된다.

### 가상주소 공간의 취상위 영역은 모든 프로세스들이 공통으로 사용하는 운영체제의 코드와 데이터를 위한공간

- 커널 가상 메모리 : 주소공간의 맨 윗부분은 커널을 위해 예약되어 있다. 응용프로그램들은 이 영역의 내용을 읽거나 쓰는 것이 금지되어 있으며, 마찬가지로 커널 코드 내에 정의된 함수를 집접 호출하는 것도 금지되어 있다.

- 스택(Stack) : 사용자 가상메모리 공간의 맨 위에 컴파일러가 함수 호출을 구현하기 위해 사용하는 사용자 스택이 위치한다. 힙과 마찬가지로 사용자 스택은 프로그램이 실행되는 동안에 동적으로 늘어났다 줄어들었다 한다. 특히, 함수를 호출할 때마다 스택이 커지며, 함수에서 리턴될 떄는 줄어든다.

- 공유 라이브러리 : 주소공간의 중간 부근에 C 표준 라이브러리나 수학 라이브러리와 같은 공유 라이브러의 코드와 데이터를 저장하는 영역이 있다. 공유 라이브러리 개념은 강력하지만 다소 어렵다.

- 힙(Heap) : 코드와 데이터 영역 다음으로 러나임 힙이 따라온다. 크기(주소)가 고정되어 있는 코드, 데이터 영역과 달리, 힙은 프로세스가 실행되면서 C 표준함수인 malloc이나 free를 호출하면서 런타임에 동적으로 그 크기가 늘었다 줄었다 한다.  

- 프로그램 코드와 데이터 : 코드는 모든 프로세스들이 같은 고정 주소에서 시작하며, 다음에 C 전역변수에 대응되는 데이터 위치들이 따라온다. 코드와 데이터 영역은 실행가능 목적파일인 hello로부터 직접 초기화된다.

### 가상주소 하위 영역은 사용자 프로세스의 코드와 데이터를 저장

가상주소 위쪽으로 갈수록 주소가 증가한다

가상메모리가 작동하기 위해서는 프로세스가 만들어내는 모든 주소를 하드웨어로 변역하는 등의 하드웨어와 운영체제 소프트웨어 간의 복잡한 상효작용이 필요하다. 기본적인 아이디어는 프로세스의 가상메모리의 내용을 디스크에 저장하고 메인 메모리를 디스크의 캐시로 사용하는 것이다.

## 파일
파일은 연속된 바이트들이다. 모든 입출력장치는 파일로 모델링하고 시스템의 모든 입출력은 시스템 콜들을 이용해 파일을 읽고 쓰는 형태로 이루어진다.

***큐(Queue) 함수***