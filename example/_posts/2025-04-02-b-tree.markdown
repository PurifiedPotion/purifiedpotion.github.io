---
layout: post
title:  "B-Tree & B+Tree"
date:   2025-04-02
hide_last_modified: true
---

* toc  
{:toc .large-only}

이진 트리(Binary Tree)보다 더 많은 데이터를 한 노드에 저장할 수 있는 B-Tree에 대해서 알아볼거야. B-Tree는 데이터베이스나 파일 시스템 등에서 자주 사용되는 균형 잡힌 트리 구조이고 디스크 접근 횟수를 최소화하는 데에 특화되어 있어.

## B-Tree란?

***B-Tree(Balanced Tree)***는 일반적인 이진 탐색 트리보다 더 많은 자식을 가질 수 있는 트리 구조야. 트리의 높이를 줄이고, 디스크 접근을 줄여서 성능을 높이는 데 목적이 있어.

## B-Tree 핵심 개념

- 각 노드는 여러 개의 키(key)와 자식 포인터를 가짐

- 모든 리프 노드는 같은 깊이에 있음 → 균형 잡힌 구조

- 내부 노드와 리프 노드 구분

- 트리의 차수(order) M에 따라 ***아래와 같은 규칙*** 있음

## B-Tree의 규칙

| B-Tree의 규칙 (차수 M일 때) |
|:---:|
| 1. 최대 자식 수: 하나의 노드는 최대 M개의 자식을 가짐 |
| 2. 최소 자식 수: 루트 노드를 제외한 모든 노드는 최소 ⌈M/2⌉개의 자식을 가짐 |
| 3. 키 개수: 한 노드는 최소 ⌈M/2⌉ - 1개 이상, 최대 M - 1개의 키를 가짐 |
| 4. 정렬 유지: 노드 내부의 키들은 오름차순으로 정렬되어 있음 |
| 5. 자식 분기 기준: 키 값에 따라 자식 노드로 분기 (이진 탐색처럼) |

## B-Tree 예시 (차수 M=4)

~~~less
[10 | 20]       ← 루트 노드 (키 2개, 자식 3개)
 /   |   \
A   B    C
~~~

- A는 10 보다 작은 값들

- B는 10 ~ 20 사이 값들

- C는 20 보다 큰 값들

## B-Tree 삽입과 삭제

- 삽입 시 : 키가 가득 찬 노드는 분한(split) → 부모로 승격

- 삭제 시 : 키가 너무 적으면 ***병합(merge)*** 또는 ***차용(redistribute)***

## 어디서 쓰이나?

- 데이터베이스 인덱스(MySQL의 InnoDB도 B+Tree 기반)

- 파일 시스템 (NTFS, HFS+ 등)

- 디스크 기반 구조에 적합(한 번의 디스크 접근으로 여러 키 확인 가능)

## B-Tree vs B+Tree

| 항목 | B-Tree | B+Tree |
|:---:|:---:|:---:|
| 키 저장 | 모든 노드 | 리프 노드만 저장 |
| 내부 노드 | (key, value) 쌍 | key만 존재 (value 없음) |
| 탐색 속도 | 상대적으로도 느릴 수 있음 | 빠름 (리프 노드에만 키 존재) |
| 범위 탐색 | 비효율적일 수 있음 | 연결 리스트 구조로 효율적 |

위 표를 보면 B+Tree가 효율적인거 같지? 그러면 B+Tree에 대해서도 배워보자

## B+Tree란?

B-Tree에서 범위 검색을 더 빠르게 하기 위해 개선한 자료구조야. 특히 데이터베이스 인덱스에서 자주 사용되고, MySQL InnoDB 같은 엔진에서도 핵심 구조로 쓰여

B+Tree는 B-Tree의 확장 버전으로, 다음과 같은 특징이 있어:

- 데이터는 모두 리프 노드에만 저장됨

- 내부 노드는 오직 탐색을 위한 키만 존재

- 리프 노드들은 연결 리스트로 연결되어 있음 → 범위 검색에 특화

## B+Tree의 구조 (차수 M 기준)

- 내부 노드: 최대 M - 1개의 키, 최대 M개의 자식 포인터

- 리프 노드: 최대 M - 1개의 (key, value) 쌍

- 리프 노드들은 왼쪽 → 오른쪽으로 연결 리스트처럼 연결

## B+Tree의 예시 (차수 M=4)

~~~less
       [20 | 40]
       /   |   \
     A     B    C

리프 노드들:
A: [5, 10, 15] →  
B: [20, 25, 30] →  
C: [40, 45, 50]
~~~

- 내부 노드는 분기 기준만 저장 (데이터 없음)

- 리프 노드들은 정렬된 순서 + 연결 리스트 구조

## B+Tree 삽입 & 삭제

- 삽입: 리프 노드에 key/value 삽입 → 오버플로우 시 분할, 부모에 key 전파

- 삭제: 리프 노드에서 제거 → 언더플로우 시 병합 또는 차용

※ 내부 노드는 여전히 분기 기준만 저장하기 때문에 삽입/삭제 시에도 데이터 재배치는 리프에서만 발생

## B+Tree의 장점

- 범위 검색이 빠르다 → 리프 노드에서 오른쪽으로 쭉 읽으면 됨

- 디스크 I/O 효율적 → 한 번 로딩에 여러 key 처리

- 인덱스 스캔 최적 → WHERE age BETWEEN 20 AND 40 같은 쿼리에 특화

## 한 줄 요약

B+Tree는 검색과 범위 조회가 빠르고 효율적인 B-Tree의 실전 버전이다