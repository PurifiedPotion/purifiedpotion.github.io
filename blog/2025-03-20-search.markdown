---
layout: post
title:  "검색(Search)"
date:   2025-03-20
hide_last_modified: true
---
검색 알고리즘 같은 경우 마냥 빠르게 되는것으로만 고려하면 안된다. 데이터의 추가/삭제 같은 작업이 수행될때 들어가는 비용까지 종합적으로 평가해야한다.

검색 알고리즘의 예제들을 아래 나열해 봤다.

### 선형 검색(Linear search)

예제 : 찾고자 하는 데이터를 정렬된 데이터에서 하나하나 검색을 수행함
~~~python
i = 0
while True:
    if i == len(a):
        # 검색 실패
    if a[i] == key:
        # 검색 성공(찾은 원소의 인덱스는 i)
    i += 1
~~~
또는 아래처럼 선형 검색을 받아와서 사용해도 된다.
~~~python
from ssearch_while import seq_search

seq_search(list : 데이터 집합, x : 찾고자 하는 인수(정수, float, 문자열))
~~~

선형 검색 같은 경우 무한루프 방지를 위해 count 변수를 둔다. count 변수 같은 경우 존재하면 계속 계산이 들어가게 되는데, 그걸 방지하고자 보초법이 등장한다.

보초법이 뭐냐, 데이터 집합 끝에 검색하고자 하는 값을 추가 후 해당 값을 찾으면 루프가 종료되게끔 하는 것이다.
아래 예제를 한번 보자

### 선형 검색(Linear search) with 보초법(Sentinel method)

예제 :
~~~python
def seq_search(dat: Data, key: any):
    """Data에서 key와 일치하는 원소를 선형 검색(보초법)"""
    a = copy.deepcopy(dat) #dat를 복사
    a.append(key)          #보초 key를 추가

    i = 0
    while True:
        if a[i] == key:
            break
        i += 1
    return -1 if i == len(dat) else i
~~~


### 이진 검색(Binary search)

예제 : 이진 검색같은 경우 정렬된 데이터에서만 적용이 가능하며, 정수뿐만 아니고 문자열 또는 실수에도 사용이 가능하다. 다만, 실수에 사용시 부동소수점 오차를 방지를 위한 epsilon 을 사용하는것이 좋다.
~~~python
def dfs(path, depth, n):
    if depth == n:
        print(path)
        return
    
    for i in range(1, n+1):
        if i not in path:  # 중복 방지
            dfs(path + [i], depth + 1, n)

dfs([], 0, 3)
~~~


### 이진 검색

예제 : N-Queen 문제 (8x8 체스판에서 퀸 8개 배치)
~~~python
def is_valid(board, row, col):
    for i in range(row):
        if board[i] == col or abs(board[i] - col) == abs(i - row):
            return False
    return True

def solve_n_queens(n, board=[], row=0):
    if row == n:
        print(board)
        return
    
    for col in range(n):
        if is_valid(board, row, col):
            solve_n_queens(n, board + [col], row + 1)

solve_n_queens(4)
~~~

이렇게 완전 탐색의 경우의 수를 알아보았다. 그렇다면 탐색 방법의 특징과 시간 복잡도를 알아보자. 아래 표를 참고하면 된다.

| 탐색 방법 | 설명 | 시간 복잡도 |
|:---:|:---:|:---:|
| 완전탐색 | 모든 경우 탐색 | O(N!) (순열) |
| 백트래킹 | 가지치기 최적화 | O(N!) (최적화됨) |
| BFS/DFS | 그래프 탐색 | O(V+E) |
| 이진 탐색 | 정렬된 데이터에서 탐색 | O(log N) |

완전탐색 특성상 유용하지 않을것 같지만 앞으로 나열하는 경우에는 유용할수도 있겠다. 작은 범위의 모든 경우를 확인할 때, 정확한 최적해를 구해야 할 때, 모든 조합을 확인해야 할때(ex: 비밀번호 크래킹)나 백트래킹 적용 정 접근할때