---
layout: post
title:  "포인터(pointer), & 연산자와 * 연산자"
date:   2025-04-04
categories: [algorithm, C]
tags: [포인터, pointer, 연산자]
hide_last_modified: true
---

* toc  
{:toc .large-only}

## 포인터(pointer)란?

포인터는 '어떤 변수의 메모리 주소'를 저장하는 변수야.

~~~c
int a = 10;
int *p;
p = &a;
~~~
- a는 정수형 변수이고 값은 10이야

- &a는 a의 메모리 주소를 의미해

- p는 포인터 변수로, 정수형 변수의 주소를 저장할 수 있어. 그래서 int*p;라고 선언해

- p = &a;는 a의 주소를 p에 저장한다는 뜻이야

## & 연산자 (주소 연산자)

&는 변수의 주소를 얻는 연산자야

~~~c
int a = 5;
printf("%p", &a);  // 변수 a의 주소를 출력함
~~~

&a 는 a의 메모리 주소를 반환해

## * 연산자 (역참조 연산자 또는 간접 참조 연산자)

* 는 두 가지 용도로 쓰여

### 포인터 선언

~~~c
int *p;
~~~

- p는 int형 값을 가리키는 포인터야

### 역참조(Dereferencing)

~~~c
int a = 10;
int *p = &a;

printf("%d", *p);  // 10 출력
~~~

- *p는 p가 가리키는 주소에 저장된 값을 의미

- 즉, *p는 a와 같아!

### 시각화 (마인드 이미지)

~~~csharp
int a = 10;

   [a]
주소: 0x100
값:   10

int *p = &a;

   [p]
주소: 0x200  (p의 주소)
값:   0x100  (a의 주소)

*p => 10
~~~

- p는 0x100이라는 값을 가지고 있다 (즉, a의 주소를 저장).

- *p는 0x100 주소에 있는 값을 참조한다, 즉 a의 값 10

- 마지막으로 p 자체도 메모리에 저장되기 때문에, p의 주소도 있어

***쉽게 정리***
~~~c
printf("%p\n", &a); // a의 주소 (예: 0x100)
printf("%p\n", p);  // p가 가리키는 주소 (=&a) → 0x100
printf("%d\n", *p); // p가 가리키는 주소의 값 → 10
printf("%p\n", &p); // p 자체의 주소 (예: 0x200)
~~~

## 마무리 

| 연산자 | 의미 | 예시 | 설명 |
|:---:|:---:|:---:|:---:|
| & | 주소값 반환 | &a | 변수 a의 주소값 |
| * | 역참조 / 값에 접근 | *p | 포인터 p가 가리키는 값 |
| * | 포인터 선언 시 사용 | int *p | 정수를 가리키는 포인터 선언 |