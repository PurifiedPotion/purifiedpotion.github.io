<!DOCTYPE html>
<html lang="ko">







<head>
  






  
    
<!-- Begin Jekyll SEO tag v2.8.0 -->
<title>PintOS 1주차 thread 구현 | PurifiedPotion’s Blog</title>
<meta name="generator" content="Jekyll v3.10.0" />
<meta property="og:title" content="PintOS 1주차 thread 구현" />
<meta name="author" content="Kwansoo Kim" />
<meta property="og:locale" content="ko_KR, en_US" />
<meta name="description" content="이 글에서는 PintOS 첫주차에 thread 구현에 관련하여서 다루겠다." />
<meta property="og:description" content="이 글에서는 PintOS 첫주차에 thread 구현에 관련하여서 다루겠다." />
<meta property="og:site_name" content="PurifiedPotion’s Blog" />
<meta property="og:image" content="/assets/img/blog/postimage/ComputerSystem.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-05-15T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="/assets/img/blog/postimage/ComputerSystem.png" />
<meta property="twitter:title" content="PintOS 1주차 thread 구현" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Kwansoo Kim"},"dateModified":"2025-05-15T00:00:00+00:00","datePublished":"2025-05-15T00:00:00+00:00","description":"이 글에서는 PintOS 첫주차에 thread 구현에 관련하여서 다루겠다.","headline":"PintOS 1주차 thread 구현","image":"/assets/img/blog/postimage/ComputerSystem.png","mainEntityOfPage":{"@type":"WebPage","@id":"/blog/computersystem/pintos-thread/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"/assets/img/PurifiedPotion.png"},"name":"Kwansoo Kim"},"url":"/blog/computersystem/pintos-thread/"}</script>
<!-- End Jekyll SEO tag -->


  

  



  <meta name="color-scheme" content="dark light">



  <meta name="theme-color" content="rgb(200,200,200)">


<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<meta http-equiv="x-ua-compatible" content="ie=edge">

<meta name="mobile-web-app-capable" content="yes">

<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-title" content="PurifiedPotion's Blog">
<meta name="apple-mobile-web-app-status-bar-style" content="default">

<meta name="application-name" content="PurifiedPotion's Blog">

<meta name="generator" content="Hydejack v9.2.1" />


<link rel="alternate" href="/blog/computersystem/pintos-thread/" hreflang="ko-kr, en-us">

<link type="application/atom+xml" rel="alternate" href="/feed.xml" title="PurifiedPotion&apos;s Blog" />


<link rel="shortcut icon"    href="/assets/icons/favicon.ico">
<link rel="apple-touch-icon" href="/assets/icons/icon-192x192.png">

<link rel="manifest" href="/assets/site.webmanifest">

<link rel="dns-prefetch" href="https://fonts.googleapis.com"><link rel="dns-prefetch" href="https://fonts.gstatic.com">



<link rel="preload" href="/assets/img/swipe.svg" as="image" id="_hrefSwipeSVG">

<link rel="dns-prefetch" href="/assets/js/search-worker-9.2.1.js" as="worker" id="_hrefSearch">





<script>((r,a)=>{function d(e,t,n,o){e.addEventListener?e.addEventListener(t,n,o):e.attachEvent?e.attachEvent("on"+t,n):e["on"+t]=n}r.loadJS=function(e,t){var n=a.createElement("script"),e=(n.src=e,t&&d(n,"load",t,{once:!0}),a.scripts[0]);return e.parentNode.insertBefore(n,e),n},r._loaded=!1,r.loadJSDeferred=function(e,t){var n=a.createElement("script");function o(){r._loaded=!0,t&&d(n,"load",t,{once:!0});var e=a.scripts[0];e.parentNode.insertBefore(n,e)}return n.src=e,r._loaded?o():d(r,"load",o,{once:!0}),n},r.setRel=r.setRelStylesheet=function(e){d(a.getElementById(e),"load",function(){this.rel="stylesheet"},{once:!0})}})(window,document);
!function(a){"use strict";var b=function(b,c,d){function e(a){return h.body?a():void setTimeout(function(){e(a)})}function f(){i.addEventListener&&i.removeEventListener("load",f),i.media=d||"all"}var g,h=a.document,i=h.createElement("link");if(c)g=c;else{var j=(h.body||h.getElementsByTagName("head")[0]).childNodes;g=j[j.length-1]}var k=h.styleSheets;i.rel="stylesheet",i.href=b,i.media="only x",e(function(){g.parentNode.insertBefore(i,c?g:g.nextSibling)});var l=function(a){for(var b=i.href,c=k.length;c--;)if(k[c].href===b)return a();setTimeout(function(){l(a)})};return i.addEventListener&&i.addEventListener("load",f),i.onloadcssdefined=l,l(f),i};"undefined"!=typeof exports?exports.loadCSS=b:a.loadCSS=b}("undefined"!=typeof global?global:this);
!function(a){if(a.loadCSS){var b=loadCSS.relpreload={};if(b.support=function(){try{return a.document.createElement("link").relList.supports("preload")}catch(b){return!1}},b.poly=function(){for(var b=a.document.getElementsByTagName("link"),c=0;c<b.length;c++){var d=b[c];"preload"===d.rel&&"style"===d.getAttribute("as")&&(a.loadCSS(d.href,d,d.getAttribute("media")),d.rel=null)}},!b.support()){b.poly();var c=a.setInterval(b.poly,300);a.addEventListener&&a.addEventListener("load",function(){b.poly(),a.clearInterval(c)}),a.attachEvent&&a.attachEvent("onload",function(){a.clearInterval(c)})}}}(this);
!function(w) {
  w._baseURL = '/';
  w._publicPath = '/assets/js/';
  w._noPushState = false;
  w._noDrawer = false;
  w._noNavbar = false;
  w._noToc = false;
  w._noSearch = false;
  w._advertise = false;
  w._search = {
    DATA_URL: '/assets/sitedata.json?no-cache',
    STORAGE_KEY: 'mini-search/',
    INDEX_KEY: 'index--2025-05-18T14:49:00+00:00',
  };
  w._clapButton = true;
}(window);</script>


<script async src="/assets/bower_components/MathJax/es5/tex-mml-chtml.js" id="_MathJax"></script>


<!--[if gt IE 8]><!---->

  




<link rel="stylesheet" href="/assets/css/hydejack-9.2.1.css" id="_stylePreload">
<link rel="stylesheet" href="/assets/icomoon/style.css" id="_iconsPreload">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto+Slab:700%7CNoto+Sans:400,400i,700,700i&display=swap" id="_fontsPreload">



  <style id="_pageStyle">

html{--accent-color: rgb(200,200,200);--accent-color-faded: rgba(200,200,200,0.5);--accent-color-highlight: rgba(200,200,200,0.1);--accent-color-darkened: #b5b5b5;--theme-color: rgb(200,200,200);--dark-mode-body-bg: #2d2d2d;--dark-mode-border-color: #393939}

</style>


<!--<![endif]-->





</head>

<body class="no-break-layout">
  
<script>
  window._sunrise = 6;
  window._sunset =  18;
  ((e,s)=>{var d="light-mode",a="dark-mode",o=(new Date).getHours();"matchMedia"in e&&e.matchMedia("(prefers-color-scheme)")||(e=(o=o<=e._sunrise||o>=e._sunset?a:d)==a?d:a,s.body.classList.add(o),s.body.classList.remove(e))})(window,document);

</script>



<hy-push-state
  id="_pushState"
  replace-selector="#_main"
  link-selector="a[href]:not([href^='/assets/']):not(.external):not(.no-push-state)"
  script-selector="script"
  duration="500"
  hashchange
>
  
  
  <div id="_navbar" class="navbar fixed-top">
  <div class="content">
    <span class="sr-only">Jump to:</span>
    <div class="nav-btn-bar">
      <a id="_menu" class="nav-btn no-hover" href="#_drawer--opened">
        <span class="sr-only">Navigation</span>
        <span class="icon-menu"></span>
      </a>
      <div class="nav-span"></div>
    </div>
  </div>
</div>
<hr class="sr-only" hidden />

  <main
  id="_main"
  class="content layout-post"
  role="main"
>
  <nav id="breadcrumbs" class="screen-only"><ul>
  
  
    <li><a href="/">home</a></li>
    
      <li>
        
          <span>/</span>
          
          
          <a href="/blog/">blog</a>
        
      </li>
    
      <li>
        
          <span>/</span>
          
          
          <a href="/blog/computersystem/">computersystem</a>
        
      </li>
    
      <li>
        
          <span>/</span>
          <span>pintos-thread</span>
        
      </li>
    
  
</ul></nav>
  










<article id="post-blog-computersystem-pintos-thread" class="page post mb6" role="article">
  <header>
    <h1 class="post-title flip-project-title">
      
        PintOS 1주차 thread 구현
      
    </h1>

    <div class="post-date">
      
      <span class="ellipsis mr1">
        <time datetime="2025-05-15T00:00:00+00:00">15 May 2025</time> in <span>Blog</span> / <a href="/computersystem/" class="flip-title">COMPUTER SYSTEM</a> 
      </span>
      
    </div>

    
    
      
        <div class="img-wrapper lead aspect-ratio sixteen-nine flip-project-img">
          


<img
  
    src="/assets/img/blog/postimage/ComputerSystem.png"
  
  alt="PintOS 1주차 thread 구현"
  
  
  width="864"
  height="486"
  loading="lazy"
/>

        </div>
      
      
    

    



  
    <p class="note-sm" >
      이 글에서는 PintOS 첫주차에 thread 구현에 관련하여서 다루겠다.

    </p>
  


  </header>

  
    <ul class="large-only" id="markdown-toc">
  <li><a href="#alarm-clock---busy-waiting-에서-sleepwakeup-방식으로의-변경" id="markdown-toc-alarm-clock---busy-waiting-에서-sleepwakeup-방식으로의-변경">Alarm Clock - Busy Waiting 에서 Sleep/Wakeup 방식으로의 변경</a>    <ul>
      <li><a href="#busy-waiting이란" id="markdown-toc-busy-waiting이란">Busy Waiting이란?</a>        <ul>
          <li><a href="#busy-waiting의-문제점" id="markdown-toc-busy-waiting의-문제점">Busy Waiting의 문제점</a></li>
          <li><a href="#busy-waiting을-없애면" id="markdown-toc-busy-waiting을-없애면">Busy Waiting을 없애면?</a></li>
          <li><a href="#그래서-효율이-왜-좋아지나" id="markdown-toc-그래서-효율이-왜-좋아지나">그래서 효율이 왜 좋아지나?</a></li>
          <li><a href="#간단한-예시" id="markdown-toc-간단한-예시">간단한 예시</a></li>
          <li><a href="#요약" id="markdown-toc-요약">요약</a></li>
        </ul>
      </li>
    </ul>
  </li>
  <li><a href="#busy-waiting-에서-sleepwakeup-방식으로의-병경-return" id="markdown-toc-busy-waiting-에서-sleepwakeup-방식으로의-병경-return">Busy Waiting 에서 Sleep/Wakeup 방식으로의 병경 return</a></li>
  <li><a href="#priority-scheduling---preemption기능과-priority-donation-우선순위-기능-구현" id="markdown-toc-priority-scheduling---preemption기능과-priority-donation-우선순위-기능-구현">Priority Scheduling - Preemption기능과 Priority Donation 우선순위 기능 구현</a>    <ul>
      <li><a href="#preemption" id="markdown-toc-preemption">Preemption</a></li>
      <li><a href="#preemption-구현" id="markdown-toc-preemption-구현">Preemption 구현</a></li>
      <li><a href="#synchronization" id="markdown-toc-synchronization">Synchronization</a></li>
      <li><a href="#donation" id="markdown-toc-donation">Donation</a>        <ul>
          <li><a href="#one-donation" id="markdown-toc-one-donation">One Donation</a></li>
          <li><a href="#nested-donation" id="markdown-toc-nested-donation">Nested Donation</a></li>
          <li><a href="#multiple-donation" id="markdown-toc-multiple-donation">Multiple Donation</a></li>
        </ul>
      </li>
      <li><a href="#priority-donation-구현" id="markdown-toc-priority-donation-구현">Priority Donation 구현</a></li>
    </ul>
  </li>
  <li><a href="#주의사항" id="markdown-toc-주의사항">주의사항</a></li>
</ul>

<p>이번 주차부터 PintOS 프로젝트가 시작 되었다. OS를 만드는 프로젝트이다 보니, 두려움이 있었지만, 다행히도 구현하기 위한 자료들이 hint를 많이 줘서 구현하는 데에는 크게 문제가 없었다. 다만 마지막 multiple donation에 관련한 코드들에 대해서는 조금 애먹는 부분이 있었다. 여기서는 Alarm Clock, Priority Scheduling에 대해서 다룰것이다. 그러면 thread 구현 처음부터 시작하겠다.</p>

<h2 id="alarm-clock---busy-waiting-에서-sleepwakeup-방식으로의-변경">Alarm Clock - Busy Waiting 에서 Sleep/Wakeup 방식으로의 변경</h2>

<p>현재 thread 같은 경우 busy Waiting 방식으로 구동되고 있다.</p>

<h3 id="busy-waiting이란">Busy Waiting이란?</h3>

<p>아래 그림처럼 어떤 리소스를 기달리 때 CPU를 계속 사용하면서 반복적으로 검사(polling)하는 방식이야.</p>

<p><img src="/assets/img/blog/computerscience/busywaiting.png" alt="Busy-waiting" /></p>

<h4 id="busy-waiting의-문제점">Busy Waiting의 문제점</h4>

<ul>
  <li>
    <p>CPU 낭비 : 프로그램이 실제로는 ‘기다리기만’하고 있음에도 CPU를 100% 사용한다는 점.</p>
  </li>
  <li>
    <p>다른 작업 불가 : 기다리는 동안 CPU가 다른 프로세스(또는 스레드)를 수행할 수가 없음.</p>
  </li>
  <li>
    <p>에너지 비효율 : 특히 모바일, 서버 환경에서는 불필요한 전력 소모를 일으킨다.</p>
  </li>
</ul>

<h4 id="busy-waiting을-없애면">Busy Waiting을 없애면?</h4>

<p>OS는 Busy Waiting 대신 <strong>“Blocking” (or “Sleep”)</strong>이라는 기법을 사용함.</p>

<ul>
  <li>
    <p>기다려야 할 일이 생기면 CPU를 반납하고, 자신은 Sleep 상태로 들어간다.</p>
  </li>
  <li>
    <p>CPU는 바로 다른 프로세스를 실행할 수 있게 됨.</p>
  </li>
  <li>
    <p>이벤트가 발생하면 OS가 해당 프로세스를 다시 깨운다(Wakeup).</p>
  </li>
  <li>
    <p>이 방법을 “Interrupt-driven” 방식이라고도 해.</p>
  </li>
</ul>

<h4 id="그래서-효율이-왜-좋아지나">그래서 효율이 왜 좋아지나?</h4>

<p><strong>→ CPU 사용률, 시스템 자원 효율, 에너지 소모 관점 모두 개선되기 때문</strong></p>

<table>
  <thead>
    <tr>
      <th style="text-align: center">항목</th>
      <th style="text-align: center">Busy Waiting</th>
      <th style="text-align: center">Blocking</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td style="text-align: center">CPU 사용</td>
      <td style="text-align: center">기다리는 동안 100%</td>
      <td style="text-align: center">기다릴 때 0% (다른 작업 실행)</td>
    </tr>
    <tr>
      <td style="text-align: center">웅답성</td>
      <td style="text-align: center">나쁨(CPU를 계속 점유)</td>
      <td style="text-align: center">좋음(필요할 때만 CPU 점유)</td>
    </tr>
    <tr>
      <td style="text-align: center">에너지 소모</td>
      <td style="text-align: center">높음</td>
      <td style="text-align: center">낮음</td>
    </tr>
    <tr>
      <td style="text-align: center">시스템 처리량</td>
      <td style="text-align: center">낮음</td>
      <td style="text-align: center">높음</td>
    </tr>
  </tbody>
</table>

<ul>
  <li>
    <p>시스템 전체로 보면 훨씬 많은 프로세스가 공정하게 실행될 수 있게 됨.</p>
  </li>
  <li>
    <p>사용자가 체감하는 반응성도 좋아진다.</p>
  </li>
  <li>
    <p>서버 입장에서도 <strong>병렬 처리량(throughput)</strong>이 훨씬 올라간다.</p>
  </li>
</ul>

<h4 id="간단한-예시">간단한 예시</h4>

<p>만약 100개의 프로세스가 어떤 이벤트를 기다린다고 해보자.</p>

<ul>
  <li>
    <p>Busy Waiting이면 100개 모두 CPU를 쓰려고 하니까,</p>

    <ul>
      <li>CPU가 1개일 경우 전혀 다른 일을 못 해.</li>
    </ul>
  </li>
  <li>
    <p>Blocking이면,</p>

    <ul>
      <li>
        <p>99개는 잠자고, 필요한 프로세스만 CPU를 쓴다.</p>
      </li>
      <li>
        <p>CPU는 다른 요처도 병행 처리할 수 있어.</p>
      </li>
    </ul>
  </li>
</ul>

<h4 id="요약">요약</h4>

<p><strong>Busy Waiting을 없애고 Blocking으로 바꾸면,</strong></p>

<ul>
  <li>
    <p>CPU 낭비 없이</p>
  </li>
  <li>
    <p>동시에 여러 작업을 잘 처리할 수 있게 되고</p>
  </li>
  <li>
    <p>에너지도 절약하고</p>
  </li>
  <li>
    <p>사용자 응답성(인터렉티브성)도 좋아진다.</p>
  </li>
</ul>

<h2 id="busy-waiting-에서-sleepwakeup-방식으로의-병경-return">Busy Waiting 에서 Sleep/Wakeup 방식으로의 병경 return</h2>

<p>그러면 어떤 구조로 바꾸어야 할까? 아래와 같이 sleep_list를 하나 만들어서 wakeup_tick(alarm 시간)만큼 쉬게 할 thread를 넣어주고, wakeup_tick이 도달하면 ready_list에 넣어주는 구조로 바꾸어야 한다.</p>

<p><img src="/assets/img/blog/computerscience/sleepwakeup.png" alt="Sleep-Wakeup" /></p>

<p>그러기 위해선 sleep_list 구조체를 ready_list와 동일하게 thread.c 파일 상단에 선언해주고 global_tick(sleep_list의 최소 wakeup_tick값)을 선언해 주었다. 여기서 처음에 INT64_MAX값으로 선언한 이유는, global_tick은 sleep_list에 들어가서 깨울 thread가 있는지 확인하기 위함인데, 일단은 아무것도 없을때, 확인하러 들어가지 않게끔 하려고 MAX로 선언하였다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">int64_t</span> <span class="n">global_tick</span> <span class="o">=</span> <span class="n">INT64_MAX</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">list</span> <span class="n">ready_list</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">list</span> <span class="n">sleep_list</span><span class="p">;</span>
</code></pre></div></div>

<p>thread_init이 될때, sleep_list가 초기화 되면서 list로써의 기능을 할 수 있게 list_init함수를 써주었다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">thread_init</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">intr_get_level</span> <span class="p">()</span> <span class="o">==</span> <span class="n">INTR_OFF</span><span class="p">);</span>

	<span class="cm">/* Reload the temporal gdt for the kernel
	 * This gdt does not include the user context.
	 * The kernel will rebuild the gdt with user context, in gdt_init (). */</span>
	<span class="k">struct</span> <span class="n">desc_ptr</span> <span class="n">gdt_ds</span> <span class="o">=</span> <span class="p">{</span> <span class="c1">// x86 에서 세그먼트 테이블 정의</span>
		<span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span> <span class="p">(</span><span class="n">gdt</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">address</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">gdt</span>
	<span class="p">};</span>
	<span class="n">lgdt</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">gdt_ds</span><span class="p">);</span>

	<span class="cm">/* Init the globla thread context */</span>
	<span class="n">lock_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">tid_lock</span><span class="p">);</span> <span class="c1">// 쓰레드 tid 할당 락 (세마포어로 되어있음)</span>
	<span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">);</span> <span class="c1">// 쓰레드 ready 리스트</span>
	<span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">);</span> <span class="c1">// 쓰레드 sleep 리스트</span>
	<span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">destruction_req</span><span class="p">);</span> <span class="c1">//삭제 예약된 스레드들의 리스트</span>

	<span class="cm">/* Set up a thread structure for the running thread. */</span>
	<span class="n">initial_thread</span> <span class="o">=</span> <span class="n">running_thread</span> <span class="p">();</span>
	<span class="n">init_thread</span> <span class="p">(</span><span class="n">initial_thread</span><span class="p">,</span> <span class="s">"main"</span><span class="p">,</span> <span class="n">PRI_DEFAULT</span><span class="p">);</span>
	<span class="n">initial_thread</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">THREAD_RUNNING</span><span class="p">;</span>
	<span class="n">initial_thread</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">allocate_tid</span> <span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>sleep_list에서 깨울 thread의 기준이 되는 wakeup_tick을 struct thread에 추가해준다</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="kr">thread</span> <span class="p">{</span>
	<span class="cm">/* Owned by thread.c. */</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>                          <span class="cm">/* Thread identifier. */</span>
	<span class="k">enum</span> <span class="n">thread_status</span> <span class="n">status</span><span class="p">;</span>          <span class="cm">/* Thread state. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>                      <span class="cm">/* Name (for debugging purposes). */</span>
	<span class="kt">int64_t</span> <span class="n">wakeup_tick</span><span class="p">;</span>				<span class="c1">// 깨울시간</span>
	<span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>                       <span class="cm">/* Priority. */</span>
	<span class="kt">int</span> <span class="n">original_priority</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list</span> <span class="n">donations</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_elem</span> <span class="n">d_elem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock</span> <span class="o">*</span><span class="n">wait_on_lock</span><span class="p">;</span>

	<span class="cm">/* Shared between thread.c and synch.c. */</span>
	<span class="k">struct</span> <span class="n">list_elem</span> <span class="n">elem</span><span class="p">;</span>              <span class="cm">/* List element. */</span>
<span class="p">};</span>
</code></pre></div></div>

<p>위 과정을 진행하였으면, 이제 timer_sleep에서 Busy Waiting을 Sleep/Wakeup 구조로 바꿀 때가 되었다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">timer_sleep</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">ticks</span><span class="p">)</span> <span class="p">{</span>
	<span class="kt">int64_t</span> <span class="n">start</span> <span class="o">=</span> <span class="n">timer_ticks</span> <span class="p">();</span>

	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">intr_get_level</span> <span class="p">()</span> <span class="o">==</span> <span class="n">INTR_ON</span><span class="p">);</span>
	<span class="c1">// while (timer_elapsed (start) &lt; ticks)</span>
	<span class="c1">// 	thread_yield ();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timer_elapsed</span><span class="p">(</span><span class="n">start</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ticks</span><span class="p">)</span> 
		 <span class="n">thread_sleep</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">ticks</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위에서 thread_sleep으로 넘어가니, thread_sleep에서도 구조를 바꿔줘야 한다.</p>

<p>wakeup_tick에 ticks값이 저장되도록 하고, sleep_list에 정렬 삽입을 통해 깨울 시간이 임박한것이 제일 앞에 오게끔 한다. 그런 후 updat_global_tick 함수 같은 경우 편의상 추가했는데, 이 함수를 통해서 global_tick이 sleep_list에서 최소값으로 갱신되게끔 한다. 함수 내용은 아래에 추가하였다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">thread_sleep</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">ticks</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thread_current</span><span class="p">()</span> <span class="o">!=</span> <span class="n">idle_thread</span><span class="p">){</span>
		<span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span><span class="p">();</span>
		<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="n">thread_current</span><span class="p">();</span>
		<span class="n">cur</span><span class="o">-&gt;</span><span class="n">wakeup_tick</span> <span class="o">=</span> <span class="n">ticks</span><span class="p">;</span>

		<span class="c1">// 정렬 삽입</span>
		<span class="n">list_insert_ordered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">,</span> <span class="n">cmp_wakeup_tick</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="c1">// global tick 갱신</span>
		<span class="n">update_global_tick</span><span class="p">();</span>


		<span class="n">thread_block</span><span class="p">();</span> <span class="c1">// block 상태로 변경</span>
		<span class="n">intr_set_level</span><span class="p">(</span><span class="n">old_level</span><span class="p">);</span> <span class="c1">// 인터럽트 disable 해제</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="c1">// 추가 함수 : 깨어날 순으로 오름차순 정렬 함수</span>
<span class="n">cmp_wakeup_tick</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">list_elem</span> <span class="o">*</span><span class="n">a_</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">list_elem</span> <span class="o">*</span><span class="n">b_</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span> <span class="n">UNUSED</span><span class="p">){</span> 
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">a_</span><span class="p">,</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">b_</span><span class="p">,</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">wakeup_tick</span> <span class="o">&lt;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">wakeup_tick</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_global_tick</span><span class="p">()</span> <span class="p">{</span> <span class="c1">// 추가 함수 : global_ticks 작은 값으로 초기화</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">)){</span>
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">a</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">),</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
	<span class="n">global_tick</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">wakeup_tick</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">else</span><span class="p">{</span>
		<span class="n">global_tick</span> <span class="o">=</span> <span class="n">INT64_MAX</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>timer_interrupt에서는 global_tick을 확인해주는 check_global_tick 함수를 통해서 wakeup_thread가 실행되게끔 한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Timer interrupt handler. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="c1">// timer_interrupt 가 일어났을때 확인할 것 !</span>
<span class="n">timer_interrupt</span> <span class="p">(</span><span class="k">struct</span> <span class="n">intr_frame</span> <span class="o">*</span><span class="n">args</span> <span class="n">UNUSED</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ticks</span><span class="o">++</span><span class="p">;</span>
	<span class="n">thread_tick</span> <span class="p">();</span> <span class="c1">// running 스레드의 cpu 사용량 업데이트</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_global_tick</span><span class="p">(</span><span class="n">ticks</span><span class="p">))</span>
		<span class="n">wakeup_thread</span> <span class="p">(</span><span class="n">ticks</span><span class="p">);</span> <span class="c1">// 깨울친구 찾아가기</span>
<span class="p">}</span>

<span class="n">bool</span>
<span class="nf">check_global_tick</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">ticks</span><span class="p">){</span>
	<span class="k">return</span> <span class="n">ticks</span> <span class="o">&gt;=</span> <span class="n">global_tick</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> 
<span class="nf">wakeup_thread</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">target_ticks</span><span class="p">){</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_elem</span> <span class="o">*</span><span class="n">target_ele</span> <span class="o">=</span> <span class="n">list_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sleep_list</span><span class="p">);</span>
		<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">target</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">target_ele</span><span class="p">,</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="o">-&gt;</span><span class="n">wakeup_tick</span> <span class="o">&lt;=</span> <span class="n">target_ticks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_remove</span><span class="p">(</span><span class="n">target_ele</span><span class="p">);</span>
			<span class="n">thread_unblock</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">//갱신</span>
	<span class="n">update_global_tick</span><span class="p">();</span> 
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 수정한다면, 아래와 같이 결과가 나온다.</p>

<p><img src="/assets/img/blog/computerscience/alarmresult.png" alt="Alarm-result" /></p>

<h2 id="priority-scheduling---preemption기능과-priority-donation-우선순위-기능-구현">Priority Scheduling - Preemption기능과 Priority Donation 우선순위 기능 구현</h2>

<p>구현에 앞서, Preemption과 Priority Donation 기능에 대해 설명하겠다.</p>

<h3 id="preemption">Preemption</h3>

<p>Preemption이란 선취권이라는 뜻으로 여기서는 ready_list에 thread가 들어갈 때, 현재 작동중인 running_thread와의 priority를 비교했을 때, running_thread보다 높다면 running_thread를 재우고 ready_list에서 제일 높은 priority를 갖는 thread를 running 시키겠다는 의미이다.</p>

<h3 id="preemption-구현">Preemption 구현</h3>

<p>먼저 thread_create() 될때, priority가 설정되면서 ready_list에 넣어진다. 그렇지만, 여기서 ready_list에 넣어진 후 위에서 언급한 기능 추가를 위해 thread_ready_check()함수를 썼다. 이 함수는 현재 작동중인 thread의 priority와 thread_create되는 thread의 priority를 비교하고 그 조건에 따라서 thread_yield()되는 함수이다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">tid_t</span>
<span class="nf">thread_create</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">,</span>
		<span class="n">thread_func</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">aux</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>

	<span class="c1">// 새로운 스레드를 생성할 때 커널 스택 할당</span>
	<span class="c1">// 실행할 함수로 start_process를 등록</span>
	<span class="c1">// 이 스레드를 ready_list에 추가함</span>

	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">function</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Allocate thread. */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">palloc_get_page</span> <span class="p">(</span><span class="n">PAL_ZERO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">TID_ERROR</span><span class="p">;</span>

	<span class="cm">/* Initialize thread. */</span>
	<span class="n">init_thread</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">priority</span><span class="p">);</span>
	<span class="n">tid</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">=</span> <span class="n">allocate_tid</span> <span class="p">();</span>

	<span class="cm">/* Call the kernel_thread if it scheduled.
	 * Note) rdi is 1st argument, and rsi is 2nd argument. */</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">rip</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">kernel_thread</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">rdi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">function</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">R</span><span class="p">.</span><span class="n">rsi</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">aux</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">ds</span> <span class="o">=</span> <span class="n">SEL_KDSEG</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">es</span> <span class="o">=</span> <span class="n">SEL_KDSEG</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">ss</span> <span class="o">=</span> <span class="n">SEL_KDSEG</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">cs</span> <span class="o">=</span> <span class="n">SEL_KCSEG</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">eflags</span> <span class="o">=</span> <span class="n">FLAG_IF</span><span class="p">;</span>

	<span class="cm">/* Add to run queue. */</span>
	<span class="n">thread_unblock</span> <span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="n">thread_ready_check</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">thread_ready_check</span> <span class="p">(</span><span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">){</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">thread_current</span><span class="p">()</span> <span class="o">!=</span> <span class="n">idle_thread</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">thread_current</span> <span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span>
		<span class="n">thread_yield</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>thread_unblock 함수에서는 priority 기준으로 ready_list에 들어가게끔 수정해준다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">thread_unblock</span> <span class="p">(</span><span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span><span class="p">;</span>

	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">is_thread</span> <span class="p">(</span><span class="n">t</span><span class="p">));</span>

	<span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span> <span class="p">();</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">==</span> <span class="n">THREAD_BLOCKED</span><span class="p">);</span>
	<span class="n">list_insert_ordered</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">,</span> <span class="n">cmp_priority</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">THREAD_READY</span><span class="p">;</span>
	<span class="n">intr_set_level</span> <span class="p">(</span><span class="n">old_level</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>현재 thread가 priority가 낮은 이유로 thread_yield가 된다고 했을 때, 이때도 마찬가지로 ready_list에 정렬되어서 들어가게 수정했다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">thread_yield</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">thread_current</span> <span class="p">();</span>
	<span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span><span class="p">;</span>

	<span class="n">ASSERT</span> <span class="p">(</span><span class="o">!</span><span class="n">intr_context</span> <span class="p">());</span>

	<span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span> <span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">curr</span> <span class="o">!=</span> <span class="n">idle_thread</span><span class="p">)</span>
		<span class="n">list_insert_ordered</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">,</span> <span class="n">cmp_priority</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">do_schedule</span> <span class="p">(</span><span class="n">THREAD_READY</span><span class="p">);</span>
	<span class="n">intr_set_level</span> <span class="p">(</span><span class="n">old_level</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>thread_set_priority 함수는 도중에 running_thread의 priority를 바꾸는 함수인데, 이때 ready_list의 최대 priority보다 낮게 변경되면, 이때도 preemption을 위해 아래와 같이 thread_ready_check()함수를 추가해 줬다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Sets the current thread's priority to NEW_PRIORITY. */</span>
<span class="kt">void</span>
<span class="nf">thread_set_priority</span> <span class="p">(</span><span class="kt">int</span> <span class="n">new_priority</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">thread_current</span> <span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">new_priority</span><span class="p">;</span>
	<span class="c1">// list_sort(&amp;ready_list, cmp_priority, NULL);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">))</span>
		<span class="n">thread_ready_check</span><span class="p">(</span><span class="n">list_entry</span><span class="p">(</span><span class="n">list_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">),</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위 3가지 함수를 고치면, preemption구현은 완료된 상태이다.</p>

<h3 id="synchronization">Synchronization</h3>

<p>그렇다면, 위에서 언급한 semaphore, condition variable, lock에 대해서 설명하자면, <a href="../../computersystem/lock-semaphore-condition" class="heading flip-title">동기화 기법 3대장 : Lock/Semaphore/Condition Variable</a>에 나와 있다.</p>

<h3 id="donation">Donation</h3>

<p>Donation도 마찬가지로 개념은 <a href="../../computersystem/donation" class="heading flip-title">Donation</a>에 나와 있다. 개념 외적으로, 여기서 구현할 Donation에 대해 알려주겠다.</p>

<h4 id="one-donation">One Donation</h4>

<p>가장 기본적인 Donation으로, lock이 된 semaphore의 waiter리스트에 있는 thread중 priority가 제일 높은 값으로 donation되는것이다.</p>

<p><img src="/assets/img/blog/computerscience/donationone.png" alt="Donation One" /></p>

<h4 id="nested-donation">Nested Donation</h4>

<p>아래 사진처럼, lock을 갖고 있는 thread가 또 다른 lock의 waiter일때의 경우에 적용되는데, priority가 제일 높은 thread 기준으로 요청하고 있는 lock쪽으로 donation이 되는 원리이다.</p>

<p><img src="/assets/img/blog/computerscience/nesteddonation.png" alt="Nested Donation" /></p>

<h4 id="multiple-donation">Multiple Donation</h4>

<p>하나의 thread가 여러개의 lock을 갖고 있을때의 경우이다. 이런 경우에는, 모든 lock에 대한 waiter중 제일 높은 priority가 donation되는것이다. 제일 높은 priority를 내준 thread에게 lock 권한을 넘겨주면, 알래 사진 기준으로 T1의 priority는 T4보다 낮은 제일 높은 priority를 갖게 되고 일할 권한은 T4가 가지게 된다.</p>

<p><img src="/assets/img/blog/computerscience/multipledonation.png" alt="Multiple Donation" /></p>

<p>다른 예를 들어보자, 아래 그림을 보았을때, T3가 T4에게 lock을 넘겨준 후의 얘기이다. 보면, T3의 priority는 계속 높기 때문에, T4는 일을 아직 하지 못한다. T3가 T6가 요청한 lock을 넘겨주고 T6가 모든일을 마쳤을 경우에만, T4가 일을 할 수 있다.</p>

<p><img src="/assets/img/blog/computerscience/multipledonated.png" alt="Multiple Donation" />
<img src="/assets/img/blog/computerscience/t3stillrunning.png" alt="Multiple Donation" /></p>

<h3 id="priority-donation-구현">Priority Donation 구현</h3>

<p>먼저 thread의 구조체에 donations list, donations list에 넣을 d_elem, 특정 lock에 기다리고 있다는 것을 명시하기 위한 *wait_on_lock을 추가해줘야 한다. 그리고 priority가 계속 변하고 되돌아오기 위해 original_priority를 추가해 줬다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="kr">thread</span> <span class="p">{</span>
	<span class="cm">/* Owned by thread.c. */</span>
	<span class="n">tid_t</span> <span class="n">tid</span><span class="p">;</span>                          <span class="cm">/* Thread identifier. */</span>
	<span class="k">enum</span> <span class="n">thread_status</span> <span class="n">status</span><span class="p">;</span>          <span class="cm">/* Thread state. */</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>                      <span class="cm">/* Name (for debugging purposes). */</span>
	<span class="kt">int64_t</span> <span class="n">wakeup_tick</span><span class="p">;</span>				<span class="c1">// 깨울시간</span>
	<span class="kt">int</span> <span class="n">priority</span><span class="p">;</span>                       <span class="cm">/* Priority. */</span>
	<span class="kt">int</span> <span class="n">original_priority</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list</span> <span class="n">donations</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_elem</span> <span class="n">d_elem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock</span> <span class="o">*</span><span class="n">wait_on_lock</span><span class="p">;</span>


	<span class="cm">/* Shared between thread.c and synch.c. */</span>
	<span class="k">struct</span> <span class="n">list_elem</span> <span class="n">elem</span><span class="p">;</span>              <span class="cm">/* List element. */</span>
<span class="p">}</span>
</code></pre></div></div>

<p>위에서 추가해준 donations list를 초기화해 주고, original_priority를 priority로 저장한다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">void</span>
<span class="nf">init_thread</span> <span class="p">(</span><span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">priority</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">t</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">PRI_MIN</span> <span class="o">&lt;=</span> <span class="n">priority</span> <span class="o">&amp;&amp;</span> <span class="n">priority</span> <span class="o">&lt;=</span> <span class="n">PRI_MAX</span><span class="p">);</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">memset</span> <span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span> <span class="o">*</span><span class="n">t</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">THREAD_BLOCKED</span><span class="p">;</span>
	<span class="n">strlcpy</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">tf</span><span class="p">.</span><span class="n">rsp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span> <span class="n">t</span> <span class="o">+</span> <span class="n">PGSIZE</span> <span class="o">-</span> <span class="k">sizeof</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">priority</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">THREAD_MAGIC</span><span class="p">;</span>
	<span class="n">list_init</span> <span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">donations</span><span class="p">));</span> <span class="c1">// 쓰레드 donations리스트</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">original_priority</span> <span class="o">=</span> <span class="n">priority</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이제 조금 복잡해진다. Multiple donation과 Nested donation이 같이 나오니 주의깊게 보자. 먼저 lock-&gt;holder가 없다면 바로 lock을 얻을 수 있기 때문에, 그 반대인 lock-&gt;holder가 있으면 donation이 될 수 있게끔 mult_donation함수를 실행시킨다. 여기서 mult_donation은 One donation 기능도 포함되어 있다. mult_donation을 통해 donations list에 들어가는데, 각 lock에 대해서 priority가 최대인 thread의 d_elem이 들어갈 수 있게끔 함수를 짰다.</p>

<p>mult_donation 함수가 끝날때쯤 nested_donation이 조건부로 실행된다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">lock_acquire</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">lock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="o">!</span><span class="n">intr_context</span> <span class="p">());</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="o">!</span><span class="n">lock_held_by_current_thread</span> <span class="p">(</span><span class="n">lock</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">holder</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">mult_donation</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">sema_down</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">semaphore</span><span class="p">);</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">holder</span> <span class="o">=</span> <span class="n">thread_current</span> <span class="p">();</span>
	<span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">wait_on_lock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">mult_donation</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="n">lock_holder</span> <span class="o">=</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">holder</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span><span class="p">;</span>

	<span class="n">ASSERT</span> <span class="p">(</span><span class="o">!</span><span class="n">intr_context</span> <span class="p">());</span>

	<span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span> <span class="p">();</span>

	<span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">wait_on_lock</span> <span class="o">=</span> <span class="n">lock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">semaphore</span><span class="p">.</span><span class="n">waiters</span><span class="p">))</span>
		<span class="n">list_insert_ordered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock_holder</span><span class="o">-&gt;</span><span class="n">donations</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">d_elem</span><span class="p">,</span> <span class="n">cmp_priority_d_elem</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_elem</span> <span class="o">*</span><span class="n">elem</span> <span class="o">=</span> <span class="n">list_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">semaphore</span><span class="p">.</span><span class="n">waiters</span><span class="p">);</span>
		<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">list_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">d_elem</span><span class="p">);</span>
			<span class="n">list_insert_ordered</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock_holder</span><span class="o">-&gt;</span><span class="n">donations</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">d_elem</span><span class="p">,</span> <span class="n">cmp_priority_d_elem</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock_holder</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="n">lock_holder</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lock_holder</span><span class="o">-&gt;</span><span class="n">wait_on_lock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">nested_donation</span><span class="p">(</span><span class="n">lock_holder</span><span class="o">-&gt;</span><span class="n">wait_on_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">intr_set_level</span> <span class="p">(</span><span class="n">old_level</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">nested_donation</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">holder</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
	<span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">holder</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">&lt;</span> <span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span>
		<span class="p">{</span>
			<span class="n">lock</span><span class="o">-&gt;</span><span class="n">holder</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>

			<span class="k">if</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">holder</span><span class="o">-&gt;</span><span class="n">wait_on_lock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">nested_donation</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">holder</span><span class="o">-&gt;</span><span class="n">wait_on_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>lock_release에서는 donations 리스트가 없으면 original_priority로 변경되게끔 하였고, donations 리스트가 있고 그 donations리스트에 lock되어있는 semaphore의 waiter가 있으면 donations리스트에서 waiter를 빼준다. 그리고 자신의 priority를 최대값으로 맞추기 위한 작업을 진행해 준다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">lock_release</span> <span class="p">(</span><span class="k">struct</span> <span class="n">lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">lock</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span> <span class="p">(</span><span class="n">lock_held_by_current_thread</span> <span class="p">(</span><span class="n">lock</span><span class="p">));</span>
	
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">holder</span><span class="o">-&gt;</span><span class="n">donations</span><span class="p">))</span>
	<span class="p">{</span>
		<span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">original_priority</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">else</span>
	<span class="p">{</span>
		<span class="k">enum</span> <span class="n">intr_level</span> <span class="n">old_level</span><span class="p">;</span>
		<span class="n">ASSERT</span> <span class="p">(</span><span class="o">!</span><span class="n">intr_context</span> <span class="p">());</span>

		<span class="n">old_level</span> <span class="o">=</span> <span class="n">intr_disable</span> <span class="p">();</span>
		
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">semaphore</span><span class="p">.</span><span class="n">waiters</span><span class="p">))</span>
		<span class="p">{</span>
			<span class="k">struct</span> <span class="n">list_elem</span> <span class="o">*</span><span class="n">elem</span> <span class="o">=</span> <span class="n">list_begin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">semaphore</span><span class="p">.</span><span class="n">waiters</span><span class="p">);</span>
			<span class="k">struct</span> <span class="kr">thread</span> <span class="o">*</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
			<span class="n">list_remove</span><span class="p">(</span><span class="o">&amp;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">d_elem</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">struct</span> <span class="n">list_elem</span> <span class="o">*</span><span class="n">donation_elem</span> <span class="o">=</span> <span class="n">list_max</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">donations</span><span class="p">,</span> <span class="n">cmp_priority</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">donation_max</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">donation_elem</span><span class="p">,</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">d_elem</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">original_priority</span> <span class="o">&gt;</span> <span class="n">donation_max</span><span class="p">)</span>
			<span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">original_priority</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">donation_max</span><span class="p">;</span>

		<span class="n">intr_set_level</span> <span class="p">(</span><span class="n">old_level</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">holder</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sema_up</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">semaphore</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>마지막으로 도중에 priority를 바꾸는 함수 thread_set_priority()를 고쳐주어야 하는데, 아래와 같이 구현했다.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>
<span class="nf">thread_set_priority</span> <span class="p">(</span><span class="kt">int</span> <span class="n">new_priority</span><span class="p">)</span> 
<span class="p">{</span>
	<span class="n">thread_current</span> <span class="p">()</span><span class="o">-&gt;</span><span class="n">original_priority</span> <span class="o">=</span> <span class="n">new_priority</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_priority</span> <span class="o">&gt;</span> <span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span><span class="p">)</span>
		<span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">new_priority</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">donations</span><span class="p">)){</span>
		<span class="n">thread_current</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">priority</span> <span class="o">=</span> <span class="n">new_priority</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="c1">// list_sort(&amp;ready_list, cmp_priority, NULL);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">))</span>
		<span class="n">thread_ready_check</span><span class="p">(</span><span class="n">list_entry</span><span class="p">(</span><span class="n">list_front</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ready_list</span><span class="p">),</span> <span class="k">struct</span> <span class="kr">thread</span><span class="p">,</span> <span class="n">elem</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div>

<p>이렇게 다 구현을 한다면, 아래와 같은 결과를 볼 수 있다.</p>

<p><img src="/assets/img/blog/computerscience/projectoneresult.png" alt="1주차 결과" /></p>

<h2 id="주의사항">주의사항</h2>

<ul>
  <li>list에 변경 작업이 있을시에는 interrupt를 끄고 작업후에는 키는것이 좋다고 한다.</li>
</ul>

  
</article>



  <hr class="dingbat related mb6" />






  
     


  <aside class="about related mt4 mb4" role="complementary">
    
    

<div class="author mt4">
  

  
    


<img
  
    src="https://via.placeholder.com/128x128"
    srcset="https://via.placeholder.com/128x128 1x,https://via.placeholder.com/256x256 2x"
    
  
  alt="Kwansoo Kim"
  class="avatar"
  
  width="120"
  height="120"
  loading="lazy"
/>

  

  
  
  <h2  class="page-title hr-bottom">
    About
  </h2>

  <p>noob in Computer Science, currently getting education in Krafton Jungle.</p>


  <div class="sidebar-social">
    <span class="sr-only">Social:</span>
<ul>
  
    
      



  

  
  
  
  

  

  

  <li>
    <a href="https://github.com/PurifiedPotion" title="GitHub" class="no-mark-external">
      <span class="icon-github"></span>
      <span class="sr-only">GitHub</span>
    </a>
  </li>


    
      



  

  
  
  
  

  

  

  <li>
    <a href="mailto:albatrers@gmail.com" title="Email" class="no-mark-external">
      <span class="icon-mail"></span>
      <span class="sr-only">Email</span>
    </a>
  </li>


    
  
</ul>

  </div>
</div>

  </aside>


  

  
    


  

  
    


  <aside class="other-projects related mb0" role="complementary">  <h2>Related Posts</h2>  <div class="columns">          <div class="column column-1-2">                  <article class="project-card">  <a href="/blog/computersystem/donation/" class="no-hover no-print-link flip-project" tabindex="-1">    <div class="project-card-img aspect-ratio sixteen-nine flip-project-img">              <img      src="/assets/img/blog/postimage/ComputerSystem.png"    alt="Donation"      width="864"  height="486"  loading="lazy"/>          </div>  </a>  <h3 class="project-card-title flip-project-title">    <a href="/blog/computersystem/donation/" class="flip-title">Donation</a>  </h3>      <p class="project-card-text fine" property="disambiguatingDescription">      임계구역에 대한 권한은 있지만, priority가 낮아서 일을 하고 있지 않는 상태라면, 모든 시스템이 작동이 중지될 위험이 있다. 이 상황을 방지하기 위해 Donation이 등장한다.    </p>      <a class="fill-card no-hover" href="/blog/computersystem/donation/" tabindex="-1"><span class="sr-only">Continue reading Donation</span></a></article>              </div>          <div class="column column-1-2">                  <article class="project-card">  <a href="/blog/computersystem/thread/" class="no-hover no-print-link flip-project" tabindex="-1">    <div class="project-card-img aspect-ratio sixteen-nine flip-project-img">              <img      src="/assets/img/blog/postimage/ComputerSystem.png"    alt="스레드(Thread)"      width="864"  height="486"  loading="lazy"/>          </div>  </a>  <h3 class="project-card-title flip-project-title">    <a href="/blog/computersystem/thread/" class="flip-title">스레드(Thread)</a>  </h3>      <p class="project-card-text fine" property="disambiguatingDescription">      스레드는 프로세스(process) 내에서 실제로 작업을 수행하는 실행 단위이다.    </p>      <a class="fill-card no-hover" href="/blog/computersystem/thread/" tabindex="-1"><span class="sr-only">Continue reading 스레드(Thread)</span></a></article>              </div>      </div></aside>

  

  
    


  <aside class="related mb4" role="complementary">  <h2 class="hr-bottom">Random Posts</h2>  <ul class="related-posts">          <li class="h4">  <a href="/blog/algorithm/8th-week/" class="flip-title"><span>8주차 퀴즈</span></a>  <time class="faded fine" datetime="2025-05-06T00:00:00+00:00">06 May 2025</time></li>          <li class="h4">  <a href="/blog/computersystem/dma/" class="flip-title"><span>Direct Memory Access</span></a>  <time class="faded fine" datetime="2025-04-28T00:00:00+00:00">28 Apr 2025</time></li>          <li class="h4">  <a href="/blog/c/malloc-calloc-realloc/" class="flip-title"><span>동적 메모리 할당(Dynamic memory allocation)</span></a>  <time class="faded fine" datetime="2025-04-11T00:00:00+00:00">11 Apr 2025</time></li>      </ul></aside>

  

  
    

  


  
<footer class="content" role="contentinfo">
  <hr/>
  
    <p><small class="copyright">© 2024. All rights reserved.
</small></p>
  
  
    <nav class="legal"><small>
    
      
      <a class="heading flip-title" href="/LICENSE/">LICENSE</a>
      |
    
      
      <a class="heading flip-title" href="/NOTICE/">NOTICE</a>
      |
    
      
      <a class="heading flip-title" href="/CHANGELOG/">CHANGELOG</a>
      
    
    </small></nav>
  
  
  <hr class="sr-only"/>
</footer>


</main>

  <hy-drawer
  id="_drawer"
  class=""
  side="left"
  threshold="10"
  noscroll
  
>
  <header id="_sidebar" class="sidebar" role="banner">
    




<div class="sidebar-bg sidebar-overlay" style="background-color:rgb(200,200,200);background-image:url(/assets/img/sidebar-bg.png)"></div>

    <div class="sidebar-sticky">
  <div class="sidebar-about">
    
      <a class="no-hover" href="/" tabindex="-1">
        <img src="/assets/img/PurifiedPotion.png" class="avatar" alt="PurifiedPotion's Blog" width="120" height="120" loading="lazy" />
      </a>
    
    <a class="sidebar-title" href="/"><h2 class="h1">PurifiedPotion's Blog</h2></a>
    
    
      <p class="">
        Blog for Computer Science

      </p>
    
  </div>

  <nav class="sidebar-nav heading" role="navigation">
    <span class="sr-only">Navigation:</span>
<ul>
  
    
      
      <li>
        <a
          id="_drawer--opened"
          href="/algorithm/"
          class="sidebar-nav-item "
          
        >
          ALGORITHM
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/c/"
          class="sidebar-nav-item "
          
        >
          C 언어
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/computersystem/"
          class="sidebar-nav-item "
          
        >
          COMPUTER SYSTEM
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/diary/"
          class="sidebar-nav-item "
          
        >
          회고
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/projects/"
          class="sidebar-nav-item "
          
        >
          PROJECTS
        </a>
      </li>
    
      
      <li>
        <a
          
          href="/docs/"
          class="sidebar-nav-item "
          
        >
          DOCUMENTATION
        </a>
      </li>
    
  
</ul>

  </nav>

  
  <div class="sidebar-social">
    <span class="sr-only">Social:</span>
<ul>
  
    
      



  

  
  
  
  

  

  

  <li>
    <a href="https://github.com/PurifiedPotion" title="GitHub" class="no-mark-external">
      <span class="icon-github"></span>
      <span class="sr-only">GitHub</span>
    </a>
  </li>


    
      



  

  
  
  
  

  

  

  <li>
    <a href="mailto:albatrers@gmail.com" title="Email" class="no-mark-external">
      <span class="icon-mail"></span>
      <span class="sr-only">Email</span>
    </a>
  </li>


    
  
</ul>

  </div>
</div>
  </header>
</hy-drawer>
<hr class="sr-only" hidden />

</hy-push-state>


  <!--[if gt IE 10]><!---->
  <script nomodule>(()=>{var t,n=document.createElement("script");!("noModule"in n)&&"onbeforeload"in n&&(t=!1,document.addEventListener("beforeload",function(e){if(e.target===n)t=!0;else if(!e.target.hasAttribute("nomodule")||!t)return;e.preventDefault()},!0),n.type="module",n.src=".",document.head.appendChild(n),n.remove())})();
</script>
  <script src="/assets/js/hydejack-9.2.1.js" type="module"></script>
  <script src="/assets/js/LEGACY-hydejack-9.2.1.js" nomodule defer></script>
  

  

  <script type="module">
    if ('serviceWorker' in navigator) {
      /**/
      navigator.serviceWorker.getRegistration()
        .then(r => r.unregister())
        .catch(() => {});
      /**/
    }
  </script>
<!--<![endif]-->
  



<div hidden>
  
  <h2 class="sr-only">Templates (for web app):</h2>

  <template id="_animation-template">
  <div class="animation-main fixed-top">
    <nav id="breadcrumbs" class="screen-only"><ul>
  
  
</ul></nav>
    <div class="content">
      <div class="page"></div>
    </div>
  </div>
</template>

  <template id="_loading-template">
  <div class="loading nav-btn fr">
    <span class="sr-only">Loading…</span>
    <span class="icon-cog"></span>
  </div>
</template>

  <template id="_error-template">
  <div class="page">
    <h1 class="page-title">Error</h1>
    
    
    <p class="lead">
      Sorry, an error occurred while loading <a class="this-link" href=""></a>.

    </p>
  </div>
</template>

  <template id="_permalink-template">
  <a href="#" class="permalink">
    <span class="sr-only">Permalink</span>
    <span class="content-hash"></span>
  </a>
</template>

  
    <template id="_cookies-banner-template">
  <div id="_cookies-banner" class="navbar fixed-bottom CookiesOK">
    <div class="content">
      <div class="nav-btn-bar">
        <small class="faded">
          <span>This site uses cookies. <a href="/cookies-policy/">Cookies Policy</a>.
</span>
          <button id="_cookies-ok" class="btn btn-primary btn-sm">Okay</button>
        </small>
      </div>
    </div>
  </div>
</template>

  
  
    <template id="_dark-mode-template">
  <button id="_dark-mode" class="nav-btn no-hover" >
    <span class="sr-only">Dark Mode</span>
    <span class="icon-brightness-contrast"></span>
  </button>
</template>

  
  
    <template id="_search-template">
  <button id="_search" class="nav-btn no-hover">
    <label class="sr-only" for="_search-input">Search</label>
    <span class="icon-search"></span>
  </button>
  <div id="_search-box">
    <div class="nav-btn">
      <span class="icon-search"></span>
    </div>
    <input 
      id="_search-input"
      type="search"
      class="form-control form-control-lg nav-btn"
      placeholder="Build with JEKYLL_ENV=production to enable search."
    />
    <button type="reset" class="nav-btn no-hover">
      <span class="sr-only">Close</span>
      <span class="icon-cross"></span>
    </button>
  </div>
  <div id="_hits"></div>
</template>

  
</div>

</body>
</html>
