---
layout: post
title:  "수작업으로 Malloc 구현"
description: >
 C언어로 직접 Malloc을 구현해보자
image: /assets/img/blog/example-content-ii.jpg
date:   2025-04-27
image: /assets/img/blog/postimage/ComputerSystem.png
hide_last_modified: true
---

* toc  
{:toc .large-only}

말록 구현에 앞서, **명시적 할당자(Explicit allocator)**와 **묵시적 할당자(Implicit allocator)**에 대해 알아 보자 

| | Explicit allocator | Implicit allocator |
|:---:|:---:|:---:|
| 사용 예 | C언어에서 malloc 할당과 free | Java의 garbage collection, ML, and Lisp |

**Malloc**에 관하여서는 이전에 포스팅한 [동적 메모리 할당(Dynamic memory allocation)]{:.heading.flip-title} 을 참조하면 된다


## 링커의 역할 

링커는 독립적인 컴파일을 가능하게 한다. 이 뜻이 뭐냐하면, 큰 규모의 응용프로그램을 한 개의 소스 파일로 구성하는 대신에 컴파일할 수 있는 보다 관리할 만한 규모의 더 작은 모듈들로 나눌 수 있다. 그리고 이거를 별도로 수정할 수 있게 된다.

- 모듈 중에 한 개를 변경할 때, 이 파일만을 간단히 재컴파일하고 다른 파일들을 재컴파일할 필요 없이 이 응용을 다시 링크한다.

### 링킹을 왜 배워야 할까?

- **큰 규모의 프로그램을 개발**할 때, 링킹을 사용하게 될 텐데, **어떻게 링커가 참조를 핵결해 나가는지, 라이브러리가 무엇인지를 배워서 링커 에러를 해결할 수 있다.**

- 언어의 **변수 영역 규칙이 구현되었는지 이해**하는데 도움이 된다. 예를 들어, **전역변수와 지역변수의 차이**는 무엇인가?

- **공유 라이브러리에 대해 이해**할 수 있다. 

더 여러가지가 있지만, 내 기준에서 중요할 것 같은 내용들만 뽑아왔다.

## 정적 연결

**재배치 가능한 목적파일(.o)들**과 **명령줄 인자들을 입력**으로 받아들여서 로드될 수 있고 실행될 수 있는 완전히 링크된 실행 가능 목적파일을 출력으로 생성한다.

실행파일을 만들기 위해서 링커는 두 가지 주요 작업을 수행해야 함

1. **심볼 해석(symbol resolution)** : 목적파일들은 심볼들을 정의하고 참조하며 여기서 각 심볼은 함수, 전역변수 또는 정적변수(즉, C언어에서 static으로 선언된 모든 변수들)에 대응된다

- 심볼 해석의 **목적**은 **각각의 심볼 참조를 정확하게 하나의 심볼 정의에 연결**하는 것임

2. **재배치(relocation)** : 컴파일러와 어셈블러는 주소 0번지에서 시작하는 코드와 데이터 섹션들을 생성. 링커는 **이 섹션들을 각 심볼 정의와 연결시켜서 재배치 하며, 이 심볼들로 가는 모든 참조들을 수정해서 이들이 이 메모리 위치를 가리키도록 한다**

## 목적파일

목적파일에는 세 가지 형태가 있어

- 재배치 가능 목적파일(Relocatable object file) : 포맷에 컴파일 할 때 **실행 가능 목적파일을 생성하기 위해 다른 재구성가능 목적파일들과 결합될 수 있는 바이너리 코드와 데이터를 포함**한다

    - .o 로 끝나는 파일들이 그 예이다

- 실행 가능 목적파일(Executable object file) : 메모리에 직접 복사될 수 있고 **실행될 수 있는 형태**로 바이너리 코드와 데이터를 포함

- 공유 목적파일(Shared object file) : 로드타임(Load time) 또는 런타임(Runtime)시에 동적으로 링크되고 메모리에 로드될 수 있는 특수한 유형의 **재배치 가능 목적파일**이다

**컴파일러와 어셈블러**는 재배치 가능 목적파일을 생성하고 **링커**는 실행 가능한 목적파일을 생성함

## 재배치 가능 목적파일(with ELF : Executable and Linkable Format)

- **ELF** : 리눅스 같은 유닉스 시스템에서 실행 파일이나 오브젝트 파일을 위한 **표준 포맷**이다(예 : .o 파일이나 a.out 파일)

아래의 표는 ELF 재배치 가능 목적파일의 포맷을 보여준다

| ┌ | ELF header |
|:---:|:---:|
| s | .text |
| e | .rodata |
| c | .data |
| t | .bss |
| i | .symtab |
| o | .rel.text |
| n | .rel.data |
| s | .debug |
| └ | .line |
| Describes object file sections | Section header table |

- ELF header : ELF 파일의 **맨 처음에 위치한 아주 중요한 정보 블록**으로써, "이 파일은 ELF 파일입니다"를 알려주고 "이 파일은 ELF 파일입니다" 문구는 운영체제나 링커가 확인. 이 파일을 생성한 워드 크기와 시스템의 바이트 순서를 나타내는 16바이트 배열로 시작함 

    - 나머지는 링커가 목적파일을 구문분석하고 해석하도록 하는 정보를 포함하고 있음

    - 여기에는 ELF header의 크기, 목적파일 타입(예: 재배치 가능, 실행 가능, 공유), 머신 타임(예: x86-64), section header table의 파일 오프셋, section header table의 크기와 엔트리 수가 들어 있다.

    - 여러 가지 섹션들의 위치와 크기는 section header table로 나타내며, 이 테이블은 목적파일의 각 섹션에 대해 고정된 크기의 엔트리를 가짐

- .text : 컴파일된 프로그램의 머신 코드

- .rodata printf : 문장의 포맷 스트링, switch 문의 점프 테이블과 같은 읽기-허용 데이터

- .data : **초기화된 C 전역변수 및 전역변수**이며, 실제로 파일 안에 값이 저장됨**(Disk 공간 차지)**

    - int a = 10; → Binary 파일에 기록됨 → a의 초기값 10이 포함된 형태로 .data 섹션에 저장

    - 만약 아래처럼 a가 지역 변수라면? 지역 변수는 스택에 들어가기 때문에, .data에 들어가지 않아
~~~c
void func() {
    int b;   // 지역 변수 👉 스택에 들어감 ❗
}
~~~

- .bss : **초기화되지 않은 C 전역변수와 정적변수 그리고 0으로 초기화된 전역변수 및 정적변수**이며, 실제 공간을 차지하지 않고 단순히 위치를 표시해(Disk 공간 차지하지 않음)

    - int b; 또는 static int c; → 초기화되지 않은 전역/정적 변수로 .bss 공간에 해당

        - b의 값 또는 c의 값이 쓰래기 값이면 어떻게 될까? 운영체제가 프로그램을 메모리에 올릴 때, .bss 영역에 있는 변수들은 자동으로 0으로 채움!

    - int y = 0; → 0으로 초기화된 전역/정적 변수로 .bss 공간에 해당

- rel.text : 링커가 이 목적파일을 다른 파일들과 연결할 때 수정되어야 하는 .text 섹션 내 위치들의 리스트

    - 일반적으로 외부 함수를 호출하거나 전역변수를 참조하는 인스트럭션들은 모두 수정 되어야 하고 이 수정을 위해서 위치들의 정보를 갖고 있는게 아닐까 싶다

- rel.data : 해당 모듈에 의해 정의되거나 참조되는 전역변수들에 대한 재배치 정보

    - 일반적으로 초기값이 전역변수 또는 외부에 정의된 함수의 주소인 초기화된 전역변수들 모두 수정되어야 한다

- .debug : 프로그램 내에서 정의도니 지역변수들과 typedef, 프로그램과 최초 C 소스 파일에서 정의되고 참조되는 전역변수들을 위한 엔트리를 갖는 **디버깅 심볼 테이블**

    - 컴파일러 드라이버가 -g 옵션으로 불린 경우에 생성됨

- .line : 최초 C 소스 프로그램과 .text 섹션 내 머신 코드 인스트럭션 내 라인 번호들간의 매핑

    - 컴파일러 드라이버가 -g 옵션으로 불린 경우에 생성됨

- .strtab : .strtab과 .debug 섹션들 내에 있는 심볼 테이블과 섹션 헤더들에 있는 섹션 이름들을 위한 스트링 테이블. 스트링 테이블은 널 문자로 종료된 스트링의 배열

## 실행 가능 목적파일의 로딩

우리가 실행 가능 목적파일을 실행하기 위해 아래와 같은 명령어를 타입해

~~~bash
linux> ./prog
~~~

그러면 이 실행 가능 목적파일이 어떻게 로딩될까?

- **prog**는 내장 Shell 명령어가 아니야. 그래서 Shell은 prog가 실행 가능한 목적파일이라고 생각하고 Loader 라는 메모리 상주 운영체제 코드를 호출해. 호출해서 이 프로그램을 실행해

    - 리눅스 프로그램은 **execve** 함수를 호출해서 Loader를 호출할 수 있어

    - Loader는 Disk로부터 실행 가능한 목적파일 내의 코드와 데이터를 메모리로 복사하고 이 프로그램의 첫 번째 Instruction, 즉 Entry point로 Jump해서 프로그램을 실행해

    - **위와 같이 프로그램을 메모리로 복사하고 실행하는 과정을 Loading**이라함

모든 실행 중인 리눅스 프로그램은 아래 사진과 같은 런타임 메모리 이미지를 가진다

![런타임 메모리 이미지](/assets/img/blog/computerscience/LinuxRuntimeMemory.png)

- 리눅스 시스템에서 code segment는 주소 0x400000에서 시작

- 뒤이어 data segment(Read/write segment)가 옴

    - 실제로는 code와 data segment 사이에 공간이 존재함

- Run-time heap은 data segment 다음에 따라오고 malloc 라이브러리를 호출해서 위로 성장

- 이 다음에는 공유 모듈(shared libraries)들을 위해 예약된 영역이 존재

- 사용자 스택은 가장 큰 합법적 사용자 주소(2^48-1) 아래에서 시작해서 더 작은 메모리 주소 방향인 아래로 성장

- 스택 위의 영역은 운영체제의 메모리 상주 부분인 커널의 코드와 데이터를 위해 예약

### 로더 실행

로더가 실행되면 아래와 같은 workflow를 가진다

~~~mathematica
                               ┌ 가상 메모리┐    로더가 프로그램의 Entry point로 jump     _start 함수가 __libc_start_main 호출     __libc_start_main :
로더 실행 -> 실행 파일 덩어리 ->│data segment│ ->  ┌────────────crt1.o────────────┐  ->  ┌────────────libc.so────────────┐  ->            - 실행 환경 초기화
                           복사│code segment│    │        _start 함수 실행        │     │   __libc_start_main 함수 실행  │                - 사용자 수준의 main 함수호출
                               └───────────┘     └──────────────────────────────┘       └──────────────────────────────┘                 - return값 처리
                                                                                                                                         - 필요한 경우 제어권을 커널로 넘겨줌
~~~


[동적 메모리 할당(Dynamic memory allocation)]: ././blog/c/_posts/2025-04-11-malloc-calloc-realloc.md