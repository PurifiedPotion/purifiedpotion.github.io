---
layout: post
title:  "링커(Linking)"
description: >
  링킹(linking)은 여러 개의 코드와 데이터를 모아서 연결하여 메모리에 로드될 수 있고 실행될 수 있는 한 개의 파일로 만드는 작업이다.
image: /assets/img/blog/example-content-ii.jpg
date:   2025-04-21
image: /assets/img/blog/postimage/ComputerSystem.png
hide_last_modified: true
---

* toc  
{:toc .large-only}

**링킹(linking)**은 여러 개의 코드와 데이터를 모아서 연결하여 메모리에 로드될 수 있고 실행될 수 있는 한 개의 파일로 만드는 작업이다.

| | 로더에 의해서 실행 | 응용프로그램에 의해서 실행 |
|:---:|:---:|:---:|
| 링커 수행 시기 | 로드 타임 | 실행 시 |

## 링커의 역할 

링커는 독립적인 컴파일을 가능하게 한다. 이 뜻이 뭐냐하면, 큰 규모의 응용프로그램을 한 개의 소스 파일로 구성하는 대신에 컴파일할 수 있는 보다 관리할 만한 규모의 더 작은 모듈들로 나눌 수 있다. 그리고 이거를 별도로 수정할 수 있게 된다.

- 모듈 중에 한 개를 변경할 때, 이 파일만을 간단히 재컴파일하고 다른 파일들을 재컴파일할 필요 없이 이 응용을 다시 링크한다.

### 링킹을 왜 배워야 할까?

- **큰 규모의 프로그램을 개발**할 때, 링킹을 사용하게 될 텐데, **어떻게 링커가 참조를 핵결해 나가는지, 라이브러리가 무엇인지를 배워서 링커 에러를 해결할 수 있다.**

- 언어의 **변수 영역 규칙이 구현되었는지 이해**하는데 도움이 된다. 예를 들어, **전역변수와 지역변수의 차이**는 무엇인가?

- **공유 라이브러리에 대해 이해**할 수 있다. 

더 여러가지가 있지만, 내 기준에서 중요할 것 같은 내용들만 뽑아왔다.

## 정적 연결

**재배치 가능한 목적파일(.o)들**과 **명령줄 인자들을 입력**으로 받아들여서 로드될 수 있고 실행될 수 있는 완전히 링크된 실행 가능 목적파일을 출력으로 생성한다.

실행파일을 만들기 위해서 링커는 두 가지 주요 작업을 수행해야 함

1. **심볼 해석(symbol resolution)** : 목적파일들은 심볼들을 정의하고 참조하며 여기서 각 심볼은 함수, 전역변수 또는 정적변수(즉, C언어에서 static으로 선언된 모든 변수들)에 대응된다

- 심볼 해석의 **목적**은 **각각의 심볼 참조를 정확하게 하나의 심볼 정의에 연결**하는 것임

2. **재배치(relocation)** : 컴파일러와 어셈블러는 주소 0번지에서 시작하는 코드와 데이터 섹션들을 생성. 링커는 **이 섹션들을 각 심볼 정의와 연결시켜서 재배치 하며, 이 심볼들로 가는 모든 참조들을 수정해서 이들이 이 메모리 위치를 가리키도록 한다**

## 목적파일

목적파일에는 세 가지 형태가 있어

- 재배치 가능 목적파일(Relocatable object file) : 포맷에 컴파일 할 때 **실행 가능 목적파일을 생성하기 위해 다른 재구성가능 목적파일들과 결합될 수 있는 바이너리 코드와 데이터를 포함**한다

    - .o 로 끝나는 파일들이 그 예이다

- 실행 가능 목적파일(Executable object file) : 메모리에 직접 복사될 수 있고 **실행될 수 있는 형태**로 바이너리 코드와 데이터를 포함

- 공유 목적파일(Shared object file) : 로드타임(Load time) 또는 런타임(Runtime)시에 동적으로 링크되고 메모리에 로드될 수 있는 특수한 유형의 **재배치 가능 목적파일**이다

**컴파일러와 어셈블러**는 재배치 가능 목적파일을 생성하고 **링커**는 실행 가능한 목적파일을 생성함

## 재배치 가능 목적파일(with ELF : Executable and Linkable Format)

아래의 표는 ELF 재배치 가능 목적파일의 포맷을 보여준다

| ┌ | ELF header |
|:---:|:---:|
| s | .text |
| e | .rodata |
| c | .data |
| t | .bss |
| i | .symtab |
| o | .rel.text |
| n | .rel.data |
| s | .debug |
| └ | .line |
| Describes object file sections | Section header table |

- ELF header : 이 파일을 생성한 워드 크기와 시스템의 바이트 순서를 나타내는 16바이트 배열로 시작함 

    - 나머지는 링커가 목적파일을 구문분석하고 해석하도록 하는 정보를 포함하고 있음

    - 여기에는 ELF header의 크기, 목적파일 타입(예: 재배치 가능, 실행 가능, 공유), 머신 타임(예: x86-64), section header table의 파일 오프셋, section header table의 크기와 엔트리 수가 들어 있다.

    - 여러 가지 섹션들의 위치와 크기는 section header table로 나타내며, 이 테이블은 목적파일의 각 섹션에 대해 고정된 크기의 엔트리를 가짐

- .text : 컴파일된 프로그램의 머신 코드

- .rodata printf : 문장의 포맷 스트링, switch 문의 점프 테이블과 같은 읽기-허용 데이터

- .data : **초기화된 C 전역변수 및 전역변수**이며, 실제로 파일 안에 값이 저장됨**(Disk 공간 차지)**

    - int a = 10; → Binary 파일에 기록됨 → a의 초기값 10이 포함된 형태로 .data 섹션에 저장

    - 만약 아래처럼 a가 지역 변수라면? 지역 변수는 스택에 들어가기 때문에, .data에 들어가지 않아
~~~c
void func() {
    int b;   // 지역 변수 👉 스택에 들어감 ❗
}
~~~

- .bss : **초기화되지 않은 C 전역변수와 정적변수 그리고 0으로 초기화된 전역변수 및 정적변수**이며, 실제 공간을 차지하지 않고 단순히 위치를 표시해(Disk 공간 차지하지 않음)

    - int b; 또는 static int c; → 초기화되지 않은 전역/정적 변수로 .bss 공간에 해당

        - b의 값 또는 c의 값이 쓰래기 값이면 어떻게 될까? 운영체제가 프로그램을 메모리에 올릴 때, .bss 영역에 있는 변수들은 자동으로 0으로 채움!

    - int y = 0; → 0으로 초기화된 전역/정적 변수로 .bss 공간에 해당