---
layout: post
title:  "스레드(Thread)"
description: >
 스레드는 프로세스(process) 내에서 실제로 작업을 수행하는 실행 단위이다.
date:   2025-05-13
image: /assets/img/blog/postimage/ComputerSystem.png
hide_last_modified: true
---

* toc  
{:toc .large-only}

## 스레드(Thread)란?

스레드(Thread)는 프로세스(Process) 내에서 실제로 작업을 수행하는 실행 단위를 말해.

- 하나의 프로세스는 최소 하나 이상의 스레드를 가지고 있어.

- 스레드들은 **프로세스의 메모리 공간(코드, 데이터, 힙, 파일 디스크립터 등)을 공유**한다.

- 하지만 **각 스레드는 자신의 레지스터 집합과 스택을 별도로 가지고 있어**.

요약하면,

- **프로세스** : 리소스를 가진 실행 단위

- **스레드** : 프로세스 내에서 실행 흐름을 가진 실행 단위

## 왜 스레드를 사용할까?

### 성능 개선(병렬성)

- CPU 코어가 여러 개라면 여러 스레드를 동시에 실행시켜 작업 속도를 높일 수 있어.

### 리소스 공유

- 같은 프로세스 내 스레드들은 메모리를 공유하기 때문에, 프로세스 간 통신(IPC)보다 훨씬 가볍고 빠른 스레드 간 통신이 가능해.

### 응답성 향상

- 예를 들어, 서버가 요청을 처리할 때, 메인 스레드는 계속 사용자 입력을 받고, 다른 스레드가 요청 처리를 맡아버리면 시스템 응답성이 좋아져.

## 스레드의 구성 요소

각 스레드는 다음을 갖고 있어

| 구성 요소 | 설명 |
|:---:|:---:|
| Thread ID | 스레드를 식별하는 고유 ID |
| Program Counter | 다음에 실행할 명령어의 주소 |
| Registers | 스레드가 현재 수행 중인 작업에 필요한 데이터 저장 |
| Stack | 함수 호출 정보, 지역 변수 저장 |
| State | 실행 샅애 (Running, Ready, Blocked 등) |

***참고 : 코드 영역, 데이터 영역, 열린 파일들은 같은 프로세스 내 스레드끼리 공유한다.***

## 스레드의 상태 변화

스레드는 아래처럼 상태가 변한다.

~~~rust
New --> Ready --> Running --> (Blocked or Terminated)
             ↑          ↓
          (Unblocked)
~~~

- **New** : 생성됨

- **Ready** : CPU를 기다림

- **Running** : CPU를 점유해서 실행 중

- **Blocked** : 입출력 등으로 기다림

- **Terminated** : 작업 완료하고 종료

## 스레드의 종류

### 사용자 수준 스레드(User-Level Thread, ULT)

- 커널이 스레드의 존재를 모름.

- 사용자 라이브러리(예: pthread)가 직접 스케줄링.

- 컨텍스트 스위칭이 빠름(커널 호출 없음), 하지만 하나가 Block되면 전체가 Block될 수 있음.

### 커널 수준 스레드(Kernel-Level Thread, KLT)

- 커널이 스레드를 관리함.

- 하나의 스레드가 Block돼도 다른 스레드는 계속 실행 가능.

- 하지만 스케줄링할 때마다 커널모드 진입/탈출(시스템 콜)이 필요해 느릴 수 있음.

### 하이브리드(2-Level Model)

- 사용자 수준 스레드와 커널 수준 스레드를 조합하여 장점을 살림.

## 스레드 생성 방법 (예 : C언어 POSIX pthread)

~~~c
#include <pthread.h>
#include <stdio.h>

void *myThreadFunc(void *arg) {
    printf("Thread 실행 중\n");
    return NULL;
}

int main() {
    pthread_t tid;
    pthread_create(&tid, NULL, myThreadFunc, NULL);
    pthread_join(tid, NULL); // main 스레드가 tid 스레드 종료를 기다림
    return 0;
}
~~~

- `pthread_create` : 새로운 스레드 생성

- `pthread_join` : 생성된 스레드가 끝날 때까지 기다림

## 스레드 사용 시 주의할 점

### 경쟁 조건(Race Condition)

- 여러 스레드가 동시에 같은 데이터를 수정할 때 발생하는 오류

- 해결 방법 : 뮤텍스(Mutex), 세마포어(Semaphore), 락(Lock) 사용

### 데드락(Deadlock)

- 둘 이상의 스레드가 서로 자원을 기다리며 영원히 멈춰버리는 현상

- 해결 방법 : 자원 할당 순서를 정하거나, 타임아웃 적용

### 기아(Starvation)

- 어떤 스레드가 자원을 독점해서 다른 스레드가 계속 기회를 얻지 못하는 문제

## 스레드와 프로세스 비교 요약

| 항목 | 프로세스 | 스레드 |
|:---:|:---:|:---:|
| 메모리 | 각각 독립 | 공유 |
| 생성 비용 | 크다 | 작다 |
| 통신 비용 | IPC(느림) | 메모리 공유(빠름) |
| 오류 전파 | 프로세스끼리 독립 | 하나가 죽으면 전체 프로세스 영향 가능 |

## 스레드 활용 예시

- **웹 서버** : 요청마다 스레드 하나 생성

- **게임 엔진** : 물리 엔진, 렌더링 엔진, 네트워크 처리 등을 각각 다른 스레드에서 수행

- **멀티미디어 앱** : 음악 재생, 동영상 디코딩, 자막 처리 등을 별도 스레드로 처리

## 시각화 그림

프로세스 하나 안에 여러 스레드가 존재하는 모습은 이렇게 볼 수 있어

~~~lua
+----------------------------------------+
|             Process (프로세스)          |
|                                        |
|    +---------+   +---------+           |
|    | Thread 1|   | Thread 2 |           |
|    +---------+   +---------+           |
|        ↕             ↕                 |
|    (공유하는 메모리, 열린 파일, 등등)  |
+----------------------------------------+
~~~

요약하면,
**"프로세스 = 자원을 가진 집"**,
**"스레드 = 집 안에서 일하는 사람"**
이라고 이해하면 좋아

## 스레드 심화

더 깊고 자세한 내용은 [스레드(Thread) 심화](../../computersystem/thread-advanced){:.heading.flip-title}에서 다루겠다.